{
  "html/index.html": {
    "link-uuid": "e2e6962c-b389-4394-87f6-56eb5f34a47d",
    "title": "HTML",
    "content": "Sources",
    "timestamp": 1769516720612
  },
  "nsd-cli/nsd/drawio/invoke/index.html": {
    "path": "CLI/nsd/drawio/invoke",
    "link-uuid": "020c286f-6a04-4b0f-8238-5b3314e60faf",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio invoke [-hV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;bindProperty&gt;] [-c=&lt;connectionBase&gt;] [-p=&lt;processorProperty&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [&lt;parameters&gt;...] Creates an Invocable dynamic proxy from a diagram calls it with command parameters and returns result [&lt;parameters&gt;...] Invocable parameters -b, --bind-property=&lt;bindProperty&gt; Bind property providing dynamic proxy method name Defaults to bind -c, --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET -h, --help Show this help message and exit. -p, --processor-property=&lt;processorProperty&gt; Processor property Defaults to processor --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio -p my-property=&quot;My property&quot; invocable.drawio invoke 33 66 The parent drawio command loads invocable.drawio diagram with my-property property set to My property. This property is used for placeholder expansion. This command: Uses default values for --processor-property and --bind-property options to create diagram element processors and bind them to dynamic proxy methods - in this case a single invoke() method. Calls the method with command line arguments - 33 and 66 Options -p, --processor-property -p, --processor-property ",
    "timestamp": 1769516720744
  },
  "nsd-cli/nsd/model/html-app/site/index.html": {
    "path": "CLI/nsd/model/html-app/site",
    "link-uuid": "11ebd2d3-85e9-4ca3-aa45-aacf11d03c34",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd model html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720898
  },
  "ai/ollama/index.html": {
    "path": "AI/Ollama",
    "link-uuid": "9c9bce66-09f5-41ea-a676-d3756ccadf0b",
    "title": "Ollama",
    "content": "This module provides implementations of core capabilities backed by Ollama over REST API with integrated telemetry. However, it doesn&rsquo;t register capability factories - it has to be done in (CLI) assemblies. Sources Maven Central JavaDoc Below are examples of how to register capabilities1. Embeddings Capability factory \nimport java.util.concurrent.CompletionStage;\n\nimport org.nasdanika.ai.Embeddings;\nimport org.nasdanika.ai.ollama.OllamaEmbeddings;\nimport org.nasdanika.capability.CapabilityProvider;\nimport org.nasdanika.capability.ServiceCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Util;\n\nimport io.opentelemetry.api.OpenTelemetry;\n\npublic class SnowflakeArcticEmbedOllamatCapabilityFactory extends ServiceCapabilityFactory&lt;Embeddings.Requirement, Embeddings&gt; {\n\n    private static final String MODEL = &quot;snowflake-arctic-embed&quot;;\n    private static final String PROVIDER = &quot;Ollama&quot;;\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        if (Embeddings.class == type) {\n            if (requirement == null) {\n                return true;\n            }\n            if (requirement instanceof Embeddings.Requirement) {            \n                Embeddings.Requirement eReq = (Embeddings.Requirement) requirement;\n                if (!Util.isBlank(eReq.provider()) &amp;&amp; !PROVIDER.equals(eReq.provider())) {\n                    return false;\n                }\n                return Util.isBlank(eReq.model()) || MODEL.equals(eReq.model());\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Embeddings&gt;&gt;&gt; createService(\n            Class&lt;Embeddings&gt; serviceType,\n            Embeddings.Requirement serviceRequirement, \n            Loader loader, \n            ProgressMonitor progressMonitor) {\n                \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);\n        \n        int chunkSize = serviceRequirement == null ? 0 : serviceRequirement.chunkSize();\n        int overlap = serviceRequirement == null ? 0 : serviceRequirement.overlap();\n        \n        return wrapCompletionStage(openTelemetryCS.thenApply(openTelemetry -&gt; createEmbeddings(openTelemetry, chunkSize, overlap)));\n    }\n        \n    protected Embeddings createEmbeddings(\n            OpenTelemetry openTelemetry,\n            int chunkSize,\n            int overlap) {\n        return new OllamaEmbeddings(\n                &quot;http://localhost:11434/api/&quot;, \n                PROVIDER, \n                MODEL, \n                null, \n                1024,\n                null, // unknown\n                8192, \n                chunkSize,\n                overlap,\n                openTelemetry);\n    }   \n\n}\n module-info.java module &lt;module name&gt; {\n    \n    ...\n    \n    provides CapabilityFactory with SnowflakeArcticEmbedOllamatCapabilityFactory;\n    \n}\n Chat Capability factory import java.util.concurrent.CompletionStage;\n\nimport org.nasdanika.ai.Chat;\nimport org.nasdanika.ai.ollama.OllamaChat;\nimport org.nasdanika.capability.CapabilityProvider;\nimport org.nasdanika.capability.ServiceCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Util;\n\nimport io.opentelemetry.api.OpenTelemetry;\n\npublic class Llama32OllamaChatCapabilityFactory extends ServiceCapabilityFactory&lt;Chat.Requirement, Chat&gt; {\n\n    private static final String MODEL = &quot;llama3.2&quot;;\n    private static final String PROVIDER = &quot;Ollama&quot;;\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        if (Chat.class == type) {\n            if (requirement == null) {\n                return true;\n            }\n            if (requirement instanceof Chat.Requirement) {          \n                Chat.Requirement cReq = (Chat.Requirement) requirement;\n                if (!Util.isBlank(cReq.provider()) &amp;&amp; !PROVIDER.equals(cReq.provider())) {\n                    return false;\n                }\n                return Util.isBlank(cReq.model()) || MODEL.equals(cReq.model());\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Chat&gt;&gt;&gt; createService(\n            Class&lt;Chat&gt; serviceType,\n            Chat.Requirement serviceRequirement, \n            Loader loader, \n            ProgressMonitor progressMonitor) {\n                \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);\n        \n        return wrapCompletionStage(openTelemetryCS.thenApply(this::createChat));\n    }\n        \n    protected Chat createChat(OpenTelemetry openTelemetry) {\n        return new OllamaChat(\n                &quot;http://localhost:11434/api/&quot;, \n                PROVIDER, \n                MODEL, \n                null, \n                128000, \n                2048, \n                openTelemetry);\n    }   \n\n}\n module-info.java module &lt;module name&gt; {\n    \n    ...\n    \n    provides CapabilityFactory with Llama32OllamaChatCapabilityFactory;\n    \n}\n Sources â†©",
    "timestamp": 1769516720069
  },
  "core/diagram/index.html": {
    "path": "Core/Diagram",
    "link-uuid": "4b4891da-27eb-4f7d-8f34-b9d434a81977",
    "title": "Diagram",
    "content": "Sources Javadoc",
    "timestamp": 1769516720213
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram",
    "link-uuid": "c2dd4a37-d60a-4244-9ec0-7149a64fa658",
    "title": "catalog-diagram",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram [-hV] [--document] [--catalog=&lt;catalog&gt;] [--layout-height=&lt;layoutHeight&gt;] [--layout-width=&lt;layoutWidth&gt;] [--schema=&lt;schemas&gt;]... [--table=&lt;tables&gt;]... [--table-types=&lt;tableTypes&gt;]... [COMMAND] Generates a diagram from a Catalog model --catalog=&lt;catalog&gt; Catalog name --document Generate documentation for diagram elements -h, --help Show this help message and exit. --layout-height=&lt;layoutHeight&gt; Heigth for force layout defaults to 1080. --layout-width=&lt;layoutWidth&gt; Width for force layout defaults to 1920. --schema=&lt;schemas&gt; Schemas to include all schemas if not provided. --table=&lt;tables&gt; Tables to include all tables if not provided. --table-types=&lt;tableTypes&gt; Table names to include all table types if not provided. -V, --version Print version information and exit. Commands: html-app - Generates html application model from a drawio document http-server - Routes HTTP requests to a diagram element processor invoke - Creates an Invocable dynamic proxy from a diagram save - Saves diagram to a file to-model - Converts diagram to diagram model",
    "timestamp": 1769516720929
  },
  "nsd-cli/nsd/app/index.html": {
    "path": "CLI/nsd/app",
    "link-uuid": "b8ec0397-1a3b-42a6-abe1-9ab104ef4815",
    "title": "app",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd app [-hV] [COMMAND] HTML Application model commands -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: site - Generates HTML site",
    "timestamp": 1769516720715
  },
  "nsd-cli/nsd/model/ecore/crew-ai/index.html": {
    "path": "CLI/nsd/model/ecore/crew-ai",
    "link-uuid": "3806df8e-a9e6-4e8e-9866-479d088f3a1e",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model ecore crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]. .. [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720867
  },
  "nsd-cli/nsd/model/catalog-diagram/index.html": {
    "path": "CLI/nsd/model/catalog-diagram",
    "link-uuid": "d797a14e-ce7f-4b4b-9af1-f14aee44044c",
    "title": "catalog-diagram",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd model catalog-diagram [-hV] [--document] [--catalog=&lt;catalog&gt;] [--layout-height=&lt;layoutHeight&gt;] [--layout-width=&lt;layoutWidth&gt;] [--schema=&lt;schemas&gt;]... [--table=&lt;tables&gt;]... [--table-types=&lt;tableTypes&gt;]... [COMMAND] Generates a diagram from a Catalog model --catalog=&lt;catalog&gt; Catalog name --document Generate documentation for diagram elements -h, --help Show this help message and exit. --layout-height=&lt;layoutHeight&gt; Heigth for force layout defaults to 1080. --layout-width=&lt;layoutWidth&gt; Width for force layout defaults to 1920. --schema=&lt;schemas&gt; Schemas to include all schemas if not provided. --table=&lt;tables&gt; Tables to include all tables if not provided. --table-types=&lt;tableTypes&gt; Table names to include all table types if not provided. -V, --version Print version information and exit. Commands: html-app - Generates html application model from a drawio document http-server - Routes HTTP requests to a diagram element processor invoke - Creates an Invocable dynamic proxy from a diagram save - Saves diagram to a file to-model - Converts diagram to diagram model",
    "timestamp": 1769516720833
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/html-app/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/html-app",
    "link-uuid": "3bd9f3c3-7042-4bef-a160-f4d2a2143e9b",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd model catalog-diagram to-model html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720849
  },
  "nsd-cli/nsd/model/ecore/html-app/site/index.html": {
    "path": "CLI/nsd/model/ecore/html-app/site",
    "link-uuid": "3da399a2-be74-4375-baec-511df40c7094",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd model ecore html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i [=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720879
  },
  "ai/smile/index.html": {
    "path": "AI/Smile",
    "link-uuid": "62853a8e-2067-4b3e-913f-03da08675966",
    "title": "Smile",
    "content": "Sources Maven Central Javadoc This module contains wrappers of some Smile regression classes as FittedPredictor.Fitter&lt;double[], double[], Double&gt;. Examples Random forest double[][] data = createData();\nList&lt;Object&gt; dataList = Arrays.asList(data);\nRandomForestPredictorFitter rfpf = new RandomForestPredictorFitter();\nFittedPredictor&lt;double[], double[], Double&gt; predictor = rfpf.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length -1];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; new double[] { ((double[]) e)[((double[]) e).length - 1] });       \n\nSystem.out.println(predictor.getError());\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8 });\nSystem.out.println(prediction[0]);\n OLS double[][] data = createData();\nList&lt;Object&gt; dataList = Arrays.asList(data);\nOLSPredictorFitter olspf = new OLSPredictorFitter();\nFittedPredictor&lt;double[], double[], Double&gt; predictor = olspf.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length -1];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; new double[] { ((double[]) e)[((double[]) e).length - 1] });       \n\nSystem.out.println(predictor.getError());\n\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8 });\nSystem.out.println(prediction[0]);\n Composition double[][] data = createData();\nList&lt;Object&gt; dataList = Arrays.asList(data);\nOLSPredictorFitter olspf = new OLSPredictorFitter();\n\nFitter&lt;double[], double[], Double&gt; other = new AbstractDoubleFitter() {\n    \n    @Override\n    protected Function&lt;double[][], double[][]&gt; fit(double[][] features, double[][] labels) {\n        return input -&gt; {\n            double[][] result = new double[labels.length][];\n            for (int i = 0; i &lt; result.length; ++i) {\n                result[i] = new double[labels[i].length];\n                result[i][0] = 0.22;\n            }\n            return result;\n        };\n    }\n    \n};\n\nFittedPredictor.Fitter&lt;double[], double[], Double&gt; composite = olspf.compose(other);\n\nFittedPredictor&lt;double[], double[], Double&gt; predictor = composite.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length -1];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; new double[] { ((double[]) e)[((double[]) e).length - 1] });       \n\nSystem.out.println(predictor.getError());\n\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8 });\nSystem.out.println(prediction[0]);\n The other fitter above always predicts 0.22 - just for testing. Recursive (Autoregression) OLSRecursivePredictorFitter fitter = new OLSRecursivePredictorFitter();\n\ndouble[][] data = {\n    { 1, 2, 3, 4.1, 5, 6, 7 },\n    { 2, 3, 4, 4.9, 6, 7, 8 },\n    { 3, 4, 5, 6.1, 7, 8, 9 },\n    { 4, 5, 6, 6.9, 8, 9, 10 },\n    { 5, 6, 7, 8.1, 9, 10, 11 },            \n    { 6, 7, 8, 9.1, 10, 11, 12 },           \n    { 7, 8, 9.1, 10, 11, 12, 13 },          \n    { 8, 9.1, 10, 11, 12, 13, 14 }          \n};              \n\nint labels = 3;\n\nList&lt;Object&gt; dataList = org.assertj.core.util.Arrays.asList(data);\nFittedPredictor&lt;double[], double[], Double&gt; predictor = fitter.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length - labels];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] l = new double[labels];\n            System.arraycopy(s, s.length - labels, l, 0, l.length);\n            return l;\n        });     \n\nSystem.out.println(predictor.getError());\n\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8, 9 });\nSystem.out.println(prediction[0]);      \n Adapting features and labels Map&lt;String,Double&gt; ageMap = Map.of(\n    &quot;Alice&quot;, 25.0,\n    &quot;Bob&quot;, 30.0,\n    &quot;Eve&quot;, 35.0,\n    &quot;Mallory&quot;, 40.0\n);\n\nMap&lt;String,Double&gt; weightMap = Map.of(\n        &quot;Alice&quot;, 100.0,\n        &quot;Bob&quot;, 120.0,\n        &quot;Eve&quot;, 140.0,\n        &quot;Mallory&quot;, 0.0\n    );\n        \nOLSPredictorFitter olspf = new OLSPredictorFitter();\nFitter&lt;String, double[], Double&gt; featureAdapted = olspf.adaptFeature(name -&gt; new double[] { ageMap.get(name) });\nFitter&lt;String, Double, Double&gt; labelAdapted = featureAdapted.adaptLabel(\n        weight -&gt; new double[] { weight },\n        wa -&gt; wa[0]\n);\n\nFittedPredictor&lt;String, Double, Double&gt; predictor = labelAdapted.fit(\n        List.of(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Eve&quot;),\n        Function.identity(),\n        weightMap::get);        \n\nSystem.out.println(predictor.getError());\n\ndouble prediction = predictor.predict(&quot;Mallory&quot;);\nSystem.out.println(prediction);\n Regression Tree double[][] data = createData();\nList&lt;Object&gt; dataList = Arrays.asList(data);\nRegressionTreePredictorFitter rtpf = new RegressionTreePredictorFitter();\nFittedPredictor&lt;double[], double[], Double&gt; predictor = rtpf.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length -1];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; new double[] { ((double[]) e)[((double[]) e).length - 1] });       \n\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8 });\nSystem.out.println(prediction[0]);\n MLP double[][] data = createData();\nList&lt;Object&gt; dataList = Arrays.asList(data);\nMLPPredictorFitter mlppf = new MLPPredictorFitter();\nFittedPredictor&lt;double[], double[], Double&gt; predictor = mlppf.fit(\n        dataList, \n        e -&gt; { \n            double[] s = (double[]) e;\n            double[] f = new double[s.length -1];\n            System.arraycopy(s, 0, f, 0, f.length);\n            return f;\n        },\n        e -&gt; new double[] { ((double[]) e)[((double[]) e).length - 1] });       \n\nSystem.out.println(predictor.getError());\ndouble[] prediction = predictor.predict(new double[] { 6, 7, 8 });\nSystem.out.println(prediction[0]);\n The above example uses regression MLPs with a single output. As such there is an MLP per label element. An implementation using a single MLP with multiple outputs will be provided in the future.",
    "timestamp": 1769516720077
  },
  "nsd-cli/nsd/sql/metadata/ecore/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore",
    "link-uuid": "d8ac65ef-41c7-442e-a37b-2d15dabae322",
    "title": "ecore",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd sql metadata ecore [-hV] [--[no-]document] [--annotation-source=&lt;annotationSource&gt;] [--layout-height=&lt;layoutHeight&gt;] [--layout-width=&lt;layoutWidth&gt;] [--ns-prefix=&lt;nsPrefix&gt;] [--ns-uri=&lt;nsURI&gt;] [--catalog=&lt;catalogs&gt;]... [--schema=&lt;schemas&gt;]... [--table=&lt;tables&gt;]... [--table-types=&lt;tableTypes&gt;]... [COMMAND] Generates a Ecore model from a database model --annotation-source=&lt;annotationSource&gt; Annotation source defaults to urn:org.nasdanika.models.sql --catalog=&lt;catalogs&gt; Catalogs to include all catalogs if not provided --[no-]document Generate documentation for model elements defaults to true -h, --help Show this help message and exit. --layout-height=&lt;layoutHeight&gt; Heigth for force layout defaults to 1080 --layout-width=&lt;layoutWidth&gt; Width for force layout defaults to 1920 --ns-prefix=&lt;nsPrefix&gt; Database namespace prefix defaults to the database name --ns-uri=&lt;nsURI&gt; Database namespace URI defaults to the database URI (connection string) --schema=&lt;schemas&gt; Schemas to include all schemas if not provided --table=&lt;tables&gt; Tables to include all tables if not provided --table-types=&lt;tableTypes&gt; Table names to include all table types if not provided -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720972
  },
  "nsd-cli/nsd/app/site/index.html": {
    "path": "CLI/nsd/app/site",
    "link-uuid": "ecf2a12c-fcfa-40dc-b887-da98ba830567",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e[=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;model&gt; &lt;output&gt; Generates HTML site &lt;model&gt; Model URI, resolved relative to the current directory &lt;output&gt; Output directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out",
    "timestamp": 1769516720718
  },
  "nsd-cli/nsd/model/html-app/index.html": {
    "path": "CLI/nsd/model/html-app",
    "link-uuid": "276d81b6-f975-422f-9a9f-53fe69571460",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd model html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720891
  },
  "nsd-cli/nsd/model/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/model/html-app/crew-ai",
    "link-uuid": "6cffe00c-27d3-4458-b139-ece9891dbae8",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class &gt;]... [--extension-resource-factory=&lt;String=Class&gt;]. .. [--protocol-resource-factory=&lt;String=Class&gt;].. . &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720887
  },
  "nsd-cli/nsd/gitlab/contribute/invoke/index.html": {
    "path": "CLI/nsd/gitlab/contribute/invoke",
    "link-uuid": "e50e1827-3b3c-479f-ac6b-4d0bd469d997",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd gitlab contribute invoke [-fhV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... &lt;uri&gt; [&lt;bindings&gt;...] Invokes URI &lt;uri&gt; URI to invoke [&lt;bindings&gt;...] Bindings URIs -f, --file URI parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Loads an invocable from a URI as explained in Loading Invocables from URIs and then invokes it with arguments obtained from parameters invocable URIs.",
    "timestamp": 1769516720769
  },
  "html/html-http/index.html": {
    "path": "HTML/HTTP",
    "link-uuid": "52bd8d8d-1b43-4691-9a68-cb1e0af4ae47",
    "title": "HTTP",
    "content": "This module provides building blocks for HTTP-based solutions. Sources Maven Central Javadoc Chat The module provides several classes for building Bootstrap/AlpineJS chat Web UIs: ChatBuilder - builds chat UI with an optional configuration dialog. AbstractChatRoutes - extends ChatBuilder and provides two HTTP routes: GET - which builds chat UI POST - processes chat requests AbstractTelemetryChatRoutes - extends AbstractChatRoutes, takes TelemetryFilter as a constructor argument for collecting telemetry. The AbstractAIChatRoutes class in the AI HTTP module extends the AbstractTelemetryChatRoutes and takes Chat as a constructor argument. Example Below is an example of an echo chat: ReflectiveHttpServerRouteBuilder builder = new ReflectiveHttpServerRouteBuilder();\nbuilder.addTargets(&quot;/test-chat/&quot;, new AbstractChatRoutes() {\n    \n    @Override\n    protected Object getConfigurator() {\n        Input text = getBootstrapFactory().getHTMLFactory().input(InputType.text);\n        AlpineJs&lt;Input&gt; aText = getAlpineJsFactory().from(text);\n        aText.model(&quot;config.test&quot;);\n        return text;\n    }\n    \n    @Override\n    protected JSONObject getConfig() {\n        JSONObject jsonConfig = super.getConfig();\n        jsonConfig.put(&quot;test&quot;, &quot;123&quot;);\n        return jsonConfig;\n    }\n\n    @Override\n    protected Mono&lt;String&gt; chatContent(\n            HttpServerRequest request, \n            String chatId, \n            String question,\n            JSONObject config, \n            JSONObject context) {\n        return Mono.just(&quot;Here we go [&quot; + chatId +&quot;]: &quot; + question + &quot; | &quot; + config + &quot; | &quot; + context);\n    }\n    \n});\n\nDisposableServer server = HttpServer\n  .create()\n  .route(builder::buildRoutes)\n  .bindNow();       \n\nURI resolvedUri = new URI(&quot;http://localhost:&quot; + server.port() + &quot;/&quot;).resolve(&quot;/test-chat/chat&quot;);            \nDesktop.getDesktop().browse(resolvedUri);\n\ntry (Terminal terminal = TerminalBuilder.builder().system(true).build()) {\n    LineReader lineReader = LineReaderBuilder\n            .builder()\n            .terminal(terminal)\n            .build();\n    \n    String prompt = &quot;http-server&gt;&quot;;\n    while (true) {\n        String line = null;\n        line = lineReader.readLine(prompt);\n        System.out.println(&quot;Got: &quot; + line);\n        if (&quot;exit&quot;.equals(line)) {\n            break;\n        }\n    }\n}\nserver.dispose();\nserver.onDispose().block();",
    "timestamp": 1769516720610
  },
  "nsd-cli/nsd/gitlab/invoke/index.html": {
    "path": "CLI/nsd/gitlab/invoke",
    "link-uuid": "22a9cc07-1651-4f69-b95f-6e98017525a3",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd gitlab invoke [-fhV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... &lt;uri&gt; [&lt;bindings&gt;...] Invokes URI &lt;uri&gt; URI to invoke [&lt;bindings&gt;...] Bindings URIs -f, --file URI parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Loads an invocable from a URI as explained in Loading Invocables from URIs and then invokes it with arguments obtained from parameters invocable URIs.",
    "timestamp": 1769516720785
  },
  "nsd-cli/nsd/model/save/index.html": {
    "path": "CLI/nsd/model/save",
    "link-uuid": "f6d7d5fc-b65e-46b3-955d-123b41f4d29a",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720903
  },
  "nsd-cli/nsd/gitlab/contribute/retrospect/invoke/index.html": {
    "path": "CLI/nsd/gitlab/contribute/retrospect/invoke",
    "link-uuid": "83d44331-d375-44a0-ab71-ff4c605f53fb",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd gitlab contribute retrospect invoke [-fhV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... &lt;uri&gt; [&lt;bindings&gt;...] Invokes URI &lt;uri&gt; URI to invoke [&lt;bindings&gt;...] Bindings URIs -f, --file URI parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Loads an invocable from a URI as explained in Loading Invocables from URIs and then invokes it with arguments obtained from parameters invocable URIs.",
    "timestamp": 1769516720780
  },
  "ai/ai-core/index.html": {
    "path": "AI/Core",
    "link-uuid": "b1e9f8ea-842b-4dc1-a87e-d07f84cb9212",
    "title": "Core",
    "content": "This module provides AI interfaces implemented by provider modules such as OpenAI and Ollama. It also provides classes and interfaces for building similarity search and RAG solutions. Sources Maven Central Javadoc See test sources for examples of using Nasdanika AI classes. Embeddings Text Generation Synchronous With telemetry Asynchronous With telemetry Chunking Embeddings resource Images Narrate (describe) image Caching CachingImageNarrator Similarity Computing Search Chat With telemetery Retrieval-augmented generation (RAG) Prediction Predictor FittedPredictor Fitter AbstractDoubleFitter Embeddings In machine learning embedding is a representation learning technique that maps complex, high-dimensional data into a lower-dimensional vector space of numerical vectors Here the word embedding is used in more mathematical sense - dimensionality reduction with structure preservation. Below are a few examples of embeddings: Vector embeddings of text or images Textual description of an image, diagram, or another complex structure such as a graph or Ecore model. Text summary With extended definition embedding generation can be chained. Examples: image -&gt; text -&gt; vector (PDF) document, diagram or other complex structure -&gt; text and images -&gt; combine text with image descriptions -&gt; vector In this module EmbeddingGenerator&lt;S,E&gt; is the base interface for generating embeddings. Is has multiple sub-interfaces and implementations. It has the following methods: Mono&lt;E&gt; generateAsync(S) - generates an embedding of type E from source S asynchronously/reactively. This is the only method of the interface which has to be implemented - the other methods have default implementations. E generate(S) - generates an embedding synchronously. Mono&lt;Map&lt;S,E&gt;&gt; generateAsync(List&lt;S&gt;) - asynchronous batch generation. For example, generation of vectors for text chunks. Map&lt;S,E&gt; generate(List&lt;S&gt;) - synchronous batch generation. The default implementation calls generateAsync().block(), so actual processing is asynchronous. &lt;F&gt; EmbeddingGenerator&lt;S,F&gt; then(EmbeddingGenerator&lt;E,F&gt; next) - combines two generators. For example, image narrator with text vector generator. &lt;V&gt; EmbeddingGenerator&lt;V,E&gt; adapt(Function&lt;V,Mono&lt;S&gt;&gt; mapper) - adapts this generator to another source type using a mapper function. For example, image embedding generator can be adapted to input stream embedding generator. EmbeddingGenerator interface also has a nested Requirement record for obtaining embedding generators using the capability framework. EmbeddingModel interface extends EmbeddingGenerator and Coordinates interfaces, so it has provider, name, and version attributes which can be used for requesting a specific model via the capability framework. Narrator&lt;S&gt; interface extends EmbeddingGenerator&lt;S, String&gt;. Specializations of this interface can be used for generating text from images, diagrams, graphs, models, &hellip; There might be implementations generating text from text. For example a summary or translation to another language. Text Implementations of TextEmbeddingGenerator can be used to generate text embeddings. TextFloatVectorEmbeddingModel is a specialization of TextEmbeddingGenerator for generating float vector embeddins. There are implementations of this interfaces for Ollama and OpenAI. TextFloatVectorEmbeddingModel generates a list of vectors from a piece of text, which is provided by concrete subclasses of TextFloatVectorChunkingEmbeddingModel - TextFloatVectorCharChunkingEmbeddings and TextFloatVectorEncodingChunkingEmbeddingModel. Generation Synchronous CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);                \ntry {\n    Requirement&lt;EmbeddingGenerator.Requirement, TextFloatVectorEmbeddingModel&gt; requirement = ServiceCapabilityFactory.createRequirement(TextFloatVectorEmbeddingModel.class);           \n    Iterable&lt;CapabilityProvider&lt;TextFloatVectorEmbeddingModel&gt;&gt; embeddingsProviders = capabilityLoader.load(requirement, progressMonitor);\n    List&lt;TextFloatVectorEmbeddingModel  &gt; allEmbeddings = new ArrayList&lt;&gt;();\n    embeddingsProviders.forEach(ep -&gt; allEmbeddings.addAll(ep.getPublisher().collect(Collectors.toList()).block()));\n    for (TextFloatVectorEmbeddingModel embeddings: allEmbeddings) {             \n        for (List&lt;Float&gt; vector: embeddings.generate(&quot;Hello world!&quot;)) {     \n            System.out.println(&quot;\\t\\t&quot; + vector.size());\n        }\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n With telemetry All providers and models CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);new LoggerProgressMonitor(LOGGER);             \ntry {\n    OpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\n    \n    Requirement&lt;EmbeddingGenerator.Requirement, TextFloatVectorEmbeddingModel&gt; requirement = ServiceCapabilityFactory.createRequirement(TextFloatVectorEmbeddingModel.class);           \n    Iterable&lt;CapabilityProvider&lt;TextFloatVectorEmbeddingModel&gt;&gt; embeddingsProviders = capabilityLoader.load(requirement, progressMonitor);\n    List&lt;TextFloatVectorEmbeddingModel  &gt; allEmbeddings = new ArrayList&lt;&gt;();\n    embeddingsProviders.forEach(ep -&gt; allEmbeddings.addAll(ep.getPublisher().collect(Collectors.toList()).block()));\n    Tracer tracer = openTelemetry.getTracer(&quot;test.ai&quot;);        \n    Span span = tracer\n        .spanBuilder(&quot;Embeddings&quot;)\n        .startSpan();\n    \n    try (Scope scope = span.makeCurrent()) {\n        for (TextFloatVectorEmbeddingModel embeddings: allEmbeddings) {             \n            for (List&lt;Float&gt; vector: embeddings.generate(&quot;Hello world!&quot;)) {     \n                System.out.println(&quot;\\t\\t&quot; + vector.size());\n            }\n        }\n    } finally {\n        span.end();\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n A specific provider CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);             \ntry {\n    OpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\n    \n    EmbeddingGenerator.Requirement eReq = TextFloatVectorEmbeddingModel.createRequirement(&quot;Ollama&quot;, null, null);\n    Requirement&lt;EmbeddingGenerator.Requirement, TextFloatVectorEmbeddingModel&gt; requirement = ServiceCapabilityFactory.createRequirement(TextFloatVectorEmbeddingModel.class, null, eReq);           \n    Iterable&lt;CapabilityProvider&lt;TextFloatVectorEmbeddingModel&gt;&gt; embeddingsProviders = capabilityLoader.load(requirement, progressMonitor);\n    List&lt;TextFloatVectorEmbeddingModel&gt; allEmbeddings = new ArrayList&lt;&gt;();\n    embeddingsProviders.forEach(ep -&gt; ep.getPublisher().subscribe(allEmbeddings::add));\n    for (TextFloatVectorEmbeddingModel embeddings: allEmbeddings) {             \n        Tracer tracer = openTelemetry.getTracer(&quot;test.ai&quot;);        \n        Span span = tracer\n            .spanBuilder(&quot;Embeddings&quot;)\n            .startSpan();\n        \n        try (Scope scope = span.makeCurrent()) {\n            Thread.sleep(200);\n            for (Entry&lt;String, List&lt;List&lt;Float&gt;&gt;&gt; vectors: embeddings.generate(List.of(&quot;Hello world!&quot;, &quot;Hello universe!&quot;)).entrySet()) {        \n                System.out.println(&quot;\\t&quot; + vectors.getKey());\n                for (List&lt;Float&gt; vector: vectors.getValue()) {\n                    System.out.println(&quot;\\t\\t&quot; + vector.size());\n                }\n            }\n            span.setStatus(StatusCode.OK);\n        } finally {\n            span.end();\n        }\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n Asynchronous CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\ntry {\n    Requirement&lt;EmbeddingGenerator.Requirement, TextFloatVectorEmbeddingModel&gt; requirement = ServiceCapabilityFactory.createRequirement(TextFloatVectorEmbeddingModel.class);           \n    TextFloatVectorEmbeddingModel embeddings = capabilityLoader.loadOne(requirement, progressMonitor);\n    List&lt;List&lt;Float&gt;&gt; vectors = embeddings.generateAsync(&quot;Hello world!&quot;).block();\n    for (List&lt;Float&gt; vector: vectors) {\n        System.out.println(vector.size());\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n With telemetry CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\ntry {\n    Requirement&lt;EmbeddingGenerator.Requirement, TextFloatVectorEmbeddingModel&gt; requirement = ServiceCapabilityFactory.createRequirement(TextFloatVectorEmbeddingModel.class);           \n    TextFloatVectorEmbeddingModel embeddings = capabilityLoader.loadOne(requirement, progressMonitor);\n    \n    OpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\n    assertNotNull(openTelemetry);\n\n    Tracer tracer = openTelemetry.getTracer(&quot;test.ai&quot;);        \n    Span span = tracer\n        .spanBuilder(&quot;Embeddings&quot;)\n        .startSpan();\n    \n    List&lt;List&lt;Float&gt;&gt; vectors = embeddings\n        .generateAsync(&quot;Hello world!&quot;)\n        .contextWrite(reactor.util.context.Context.of(Context.class, Context.current().with(span)))\n        .doFinally(signal -&gt; span.end())\n        .block();\n\n    for (List&lt;Float&gt; vector: vectors) {\n        System.out.println(vector.size());\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n Chunking Chunking embeddings for text-embedding-ada-002 using CL100K_BASE encoding. 1000 tokens chunks with 20 tokens overlap. TextFloatVectorEncodingChunkingEmbeddingModel chunkingEmbeddings = new TextFloatVectorEncodingChunkingEmbeddingModel(\n        embeddings, \n        1000, \n        20, \n        EncodingType.CL100K_BASE);\n Embeddings resource TextFloatVectorEmbeddingResource provides content with pre-computed embeddings. It is modeled after McpSchema.Resource (see also MCP Resources) to make it easy to wrap an embedding resources into an MCP resource and vice versa. The idea is to publish text with embeddings and expose the data as an MCP resource and embeddings resource so it can be used by MCP clients, MCP tools, and there is no need to compute embeddings. Example: search-documents-embeddings.json contains plain text for the pages of this site with pre-computed Ada embeddings of page chunks. Images This module provides the following classes and interfaces for working with images: Interfaces ImageEmbeddingGenerator&lt;E&gt; extends EmbeddingGenerator&lt;BufferedImage, E&gt; ImageNarrator extends ImageEmbeddingGenerator&lt;String&gt;, Narrator&lt;BufferedImage&gt; ImageFloatVectorEmbeddingModel extends EmbeddingModel&lt;BufferedImage, List&lt;List&lt;Float&gt;&gt;&gt;, ImageEmbeddingGenerator&lt;List&lt;List&lt;Float&gt;&gt;&gt;, FloatVectorEmbeddingGenerator&lt;BufferedImage&gt; Classes CachingImageEmbeddingGenerator&lt;E&gt; extends CachingEmbeddingGenerator&lt;BufferedImage, E, String&gt; implements ImageEmbeddingGenerator&lt;E&gt; CachingImageNarrator extends CachingImageEmbeddingGenerator&lt;String&gt; implements ImageNarrator ChatImageNarrator implements ImageNarrator - uses multi-modal chat (see below) to generate image descriptions, extract text, &hellip; ImageMetadataNarrator&lt;S&gt; implements Narrator&lt;S&gt; - retrieves image description from image metadata &ldquo;Description&rdquo; keyword if it is available. The keyword can be changed by overriding getDescriptionKeyword. This class is abstract with concrete implementations below: ByteArrayImageMetadataNarrator - loads image metadata from a byte array. DocumentImageMetadataNarrator in the AI Drawio module - if an image has an embedded diagram then the diagram is narrated to produce image narration. This class is abstract with byte[], File, URI and URL concrete specializations. FileImageMetadataNarrator - loads image metadata from a file. UriImageMetadataNarrator - loads image metadata from a URI, supports data URIs. UriImageMetadataNarrator - loads image metadata from a URL. Narrate (describe) image CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\nOpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\n\nList&lt;Chat&gt; chats = new ArrayList&lt;&gt;();       \ntry {\n    Chat.Requirement cReq = new Chat.Requirement(&quot;OpenAI&quot;, &quot;gpt-4o&quot;, null);\n    Requirement&lt;Chat.Requirement, Chat&gt; requirement = ServiceCapabilityFactory.createRequirement(Chat.class, null, cReq);           \n    for (CapabilityProvider&lt;Chat&gt; chatProvider: capabilityLoader.&lt;Chat&gt;load(requirement, progressMonitor)) {\n        chatProvider.getPublisher().subscribe(chats::add);\n    }\n    \n    Tracer tracer = openTelemetry.getTracer(&quot;test.ai&quot;);        \n    Span span = tracer\n        .spanBuilder(&quot;Chat&quot;)\n        .startSpan();\n    try (Scope scope = span.makeCurrent()) {            \n        for (Chat chat: chats) {\n            ChatImageNarrator chatImageNarrator = new ChatImageNarrator(chat);\n            String narration = chatImageNarrator.asFileEmbeddingGenerator().generate(new File(&quot;llama.png&quot;));\n            System.out.println(narration);\n        }\n    } finally {\n        span.end();\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n Caching Generation of embeddigns can be an expensive operation time and money wise (token cost). CachingEmbeddingGenerator and its subclasses can be used for caching and sharing embeddings. One application of caching of image -&gt; textual description caching is manual modification of descriptions for images such as icons and logos where there is much more than meets the eye. For example, an architectural diagram may have an element with an image from an image library representing, say, a mainframe as on this diagram. Or it may represent a specific enterprise system such as a payment processing mainframe. Having a shared &ldquo;visual glossary&rdquo; would allow to generate higher quality diagram descriptions. CachingImageNarrator // Load cache here\n\nChatImageNarrator chatImageNarrator = new ChatImageNarrator(chat);\nImageNarrator cachingImageNarrator = new CachingImageNarrator(chatImageNarrator, cache);\nString narration = cachingImageNarrator.asFileEmbeddingGenerator().generate(new File(&quot;llama.png&quot;));\nSystem.out.println(narration);\n\n// Save cache here\n Similarity One application of generating embeddings is to compute similarity between things such as text and images. Computing SimilarityComputer interface and its extensions and implementation provide functionality for computing similarity for text and images. SimilarityComputer has the following methods: S compute(T, T) Mono&lt;S&gt; computeAsync(T, T) Mono&lt;S&gt; computeAsync(Mono&lt;T&gt;, Mono&lt;T&gt;) &lt;V&gt; SimilarityComputer&lt;V,S&gt; adapt(Function&lt;V, Mono&lt;T&gt;&gt;) - adapts to another input type using a mapper function Sub-interfaces: BufferedImageSimilarityComputer - binds the input generic parameter to BufferedImage and provides adapter methods loading images from InputStream, URL or File and then computing similarity TextSimilarityComputer - binds the input generic parameter to String VectorSimilarityComputer&lt;E,S&gt; extends SimilarityComputer&lt;List&lt;E&gt;, S&gt; - binds the input generic parameter to a list of vector elements FloatVectorSimilarityComputer extends VectorSimilarityComputer&lt;Float, Float&gt; - binds input element and similarity to Float. Provides COSINE_SIMILARITY_COMPUTER constant Implementations: CompositeFloatSimilarityComputer&lt;T&gt; implements SimilarityComputer&lt;T,Float&gt; - computes combined float similarity from several similarity computers. Computers are added using addComputer(SimilarityComputer&lt;? super T, Float&gt; computer, float weight) method. Possible application - compute image similarity using visual similarity methods, e.g. leveraging OpenCV or Deep Java Library. Then generate text descriptions and compute similarity between them. Finally, combine visual and textual similarity with weights. Search SimilaritySearch interface is intended to be used for finding items similar to a query using one of find methods: List&lt;SearchResult&lt;D&gt;&gt; find(U query, int numberOfItems) Mono&lt;List&lt;SearchResult&lt;D&gt;&gt;&gt; findAsync(U query, int numberOfItems) Similarity search can work on any data type with a distance defined. The distance type must be Comparable. For example, for text distance can be computed using embeddings, a bag of words, a semantic graph, or a combination of thereof. Semantic graphs may be useful with internal terminology. Let&rsquo;s say there is a GBS system which uses IBM MQ for communication with payload structure defined as TVT and encoded to bytes using XLF. The semantic/knowledge graph would &ldquo;know&rdquo; that GBS stands for &ldquo;Global Booking System&rdquo; and it is related to TVT, MQ, and XLF1. An instance of similarity search can be adapted to another type using adapt(Function&lt;U,T&gt; mapper, Function&lt;U, Mono&lt;T&gt;&gt; asyncMapper) method. One usage scenario is to adapt a structured type to text by &ldquo;narrating&rdquo; it. For example, there is a Drawio diagram element or a C4 Model element, say API Application. In the case of a diagram element, it can be converted to text by explaining its label, tooltip, layer it belongs to, and other elements it connects to - this is different from computer vision because tooltips and layers are not visible. The narration may also include styling such as color, description of a shape image and geometry. E.g. &ldquo;above&rdquo;, &ldquo;to the right of&rdquo;. In the case of a model element the narration would include element documentation, its references, and its type. E.g.: The &ldquo;API Application&rdquo; is a Container. Paul is a Man. Documentation may be in plain text or, for example, Markdown. In the latter case fenced blocks with diagrams can be narrated as explained above and images can be explained using vision models like ChatGPT. Image alternative text can be used as well. Static textFloatVectorEmbeddingSearch() method adapts a float multi-vector search to string (text) search. There is a static method to adapt a single vector search to a multi-vector search. The below code snippet shows how to create a vector search instance on top of Hnswlib: HnswIndex&lt;IndexId, float[], EmbeddingsItem, Float&gt; hnswIndex = HnswIndex\n    .newBuilder(1536, DistanceFunctions.FLOAT_COSINE_DISTANCE, resources.size())\n    .withM(16)\n    .withEf(200)\n    .withEfConstruction(200)\n    .build();\n\nMap&lt;String, String&gt; contentMap = new HashMap&lt;&gt;();\n\nresourceSet.getResources().subscribe(er -&gt; {\n    List&lt;List&lt;Float&gt;&gt; vectors = er.getEmbeddings();\n    for (int i = 0; i &lt; vectors.size(); ++i) {\n        List&lt;Float&gt; vector = vectors.get(i);\n        float[] fVector = new float[vector.size()];\n        for (int j = 0; j &lt; fVector.length; ++j) {\n            fVector[j] = vector.get(j);\n        }\n        hnswIndex.add(new EmbeddingsItem(\n                new IndexId(er.getUri(), i), \n                fVector, \n                er.getDimensions()));               \n    }\n    contentMap.put(er.getUri(), er.getContent());\n});\n\nhnswIndex.save(new File(&quot;test-data/hnsw-index.bin&quot;));\n\nSimilaritySearch&lt;List&lt;Float&gt;, Float&gt; vectorSearch = new SimilaritySearch&lt;List&lt;Float&gt;, Float&gt;() {\n    \n    @Override\n    public Mono&lt;List&lt;SearchResult&lt;Float&gt;&gt;&gt; findAsync(List&lt;Float&gt; query, int numberOfItems) {\n        return Mono.just(find(query, numberOfItems));\n    }\n    \n    @Override\n    public List&lt;SearchResult&lt;Float&gt;&gt; find(List&lt;Float&gt; query, int numberOfItems) {\n        float[] fVector = new float[query.size()];\n        for (int j = 0; j &lt; fVector.length; ++j) {\n            fVector[j] = query.get(j);\n        }\n        List&lt;SearchResult&lt;Float&gt;&gt; ret = new ArrayList&lt;&gt;();\n        for (com.github.jelmerk.hnswlib.core.SearchResult&lt;EmbeddingsItem, Float&gt; nearest: hnswIndex.findNearest(fVector, numberOfItems)) {\n            ret.add(new SearchResult&lt;Float&gt;() {\n                \n                @Override\n                public String getUri() {\n                    return nearest.item().id().uri();\n                }\n                \n                @Override\n                public int getIndex() {\n                    return nearest.item().id().index();\n                }\n                \n                @Override\n                public Float getDistance() {\n                    return nearest.distance();\n                }\n                \n            });\n        }\n        return ret;\n    }\n    \n};      \n\n An instance of vector search can be adapted to a multi-vector search: SimilaritySearch&lt;List&lt;List&lt;Float&gt;&gt;, Float&gt; multiVectorSearch = SimilaritySearch.adapt(vectorSearch);\n and then to a text search: TextFloatVectorChunkingEmbeddingModel chunkingEmbeddings = new TextFloatVectorChunkingEmbeddingModel(\n        embeddings, \n        1000, \n        20, \n        EncodingType.CL100K_BASE);\n\nSimilaritySearch&lt;String, Float&gt; textSearch = SimilaritySearch.textFloatVectorEmbeddingSearch(multiVectorSearch, chunkingEmbeddings);\n Chat CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\ntry {\n    Requirement&lt;Void, Chat&gt; requirement = ServiceCapabilityFactory.createRequirement(Chat.class);           \n    org.nasdanika.ai.Chat chat = capabilityLoader.loadOne(requirement, progressMonitor);\n    \n    List&lt;ResponseMessage&gt; responses = chat.chat(\n        Chat.Role.system.createMessage(&quot;You are a helpful assistant. You will talk like a pirate.&quot;),\n        Chat.Role.user.createMessage(&quot;Can you help me?&quot;),\n        Chat.Role.system.createMessage(&quot;Of course, me hearty! What can I do for ye?&quot;),\n        Chat.Role.user.createMessage(&quot;What's the best way to train a parrot?&quot;)\n    );\n        \n    for (ResponseMessage response: responses) {\n        System.out.println(response.getContent());\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n With telemetery CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\ntry {\n    Requirement&lt;Void, Chat&gt; requirement = ServiceCapabilityFactory.createRequirement(Chat.class);           \n    org.nasdanika.ai.Chat chat = capabilityLoader.loadOne(requirement, progressMonitor);\n    \n    OpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\n\n    Tracer tracer = openTelemetry.getTracer(&quot;test.openai&quot;);        \n    Span span = tracer\n        .spanBuilder(&quot;Chat&quot;)\n        .startSpan();\n    \n    try (Scope scope = span.makeCurrent()) {\n        List&lt;ResponseMessage&gt; responses = chat.chat(\n            Chat.Role.system.createMessage(&quot;You are a helpful assistant. You will talk like a pirate.&quot;),\n            Chat.Role.user.createMessage(&quot;Can you help me?&quot;),\n            Chat.Role.system.createMessage(&quot;Of course, me hearty! What can I do for ye?&quot;),\n            Chat.Role.user.createMessage(&quot;What's the best way to train a parrot?&quot;)\n        );\n        \n        for (ResponseMessage response: responses) {\n            System.out.println(response.getContent());\n        }\n    } finally {\n        span.end();\n    }\n} finally {\n    capabilityLoader.close(progressMonitor);\n}\n Retrieval-augmented generation (RAG) The below code snippet shows how chat can be used with the text search for retrieval-augmented generation: String query = ...\nList&lt;SearchResult&lt;Float&gt;&gt; searchResults = textSearch.find(query, 10);\n  \n// Chat\nChat.Requirement cReq = new Chat.Requirement(&quot;OpenAI&quot;, &quot;gpt-4o&quot;, null);\nRequirement&lt;Chat.Requirement, Chat&gt; chatRequirement = ServiceCapabilityFactory.createRequirement(Chat.class, null, cReq);\nChat chat = capabilityLoader.loadOne(chatRequirement, progressMonitor);\n\nList&lt;Chat.Message&gt; messages = new ArrayList&lt;&gt;();\nmessages.add(Chat.Role.system.createMessage(&quot;You are a helpful assistant. You will answer user question leveraging provided documents and provide references to the used documents. Output your answer in markdown&quot;));\nmessages.add(Chat.Role.user.createMessage(query));\n\nMap&lt;String, List&lt;SearchResult&lt;Float&gt;&gt;&gt; groupedResults = org.nasdanika.common.Util.groupBy(searchResults, SearchResult::getUri);\nfor (Entry&lt;String, List&lt;SearchResult&lt;Float&gt;&gt;&gt; sre: groupedResults.entrySet()) {\n    StringBuilder messageBuilder = new StringBuilder(&quot;Use this document with URL &quot; + sre.getKey() + &quot;:&quot; + System.lineSeparator());\n    List&lt;String&gt; chunks = chunkingEmbeddings.chunk(contentMap.get(sre.getKey()));\n    for (SearchResult&lt;Float&gt; chunkResult: sre.getValue()) {\n        String chunk = chunks.get(chunkResult.getIndex());\n        messageBuilder.append(System.lineSeparator() + System.lineSeparator() + chunk);\n    }\n    \n    messages.add(Chat.Role.system.createMessage(messageBuilder.toString()));\n}       \n\nList&lt;ResponseMessage&gt; responses = chat.chat(messages);                              \n\nfor (ResponseMessage response: responses) {\n    System.out.println(response.getContent());\n}               \n Please note that this is a very basic implementation: It doesn&rsquo;t take the size of the context window into account and doesn&rsquo;t count input tokens. It uses all search results regardless of the distance. A more robust implementation would discard results with the distance greater than some threshold and perhaps would reply &ldquo;Not enough information&rdquo; if there are no good matches. Also the example above is a single-shot - ask a question, get an answer, it is not a dialog. Prediction Predictor interface and its sub-interfaces and implementations provide a framework for making predictions (forecasting). These interfaces do not implement any prediction algorithms - they provide methods for data processing and conversion. There are several concrete implementations on top of Smile and Apache Commons Math classes. Predictor A base generic interface predicting output (labels) from input (features) synchronously or asynchronously. The default synchronous prediction calls the asynchronous and blocks. There are default methods for batch prediction. There are also methods to adapt between input/output types using mapping functions. Let&rsquo;s say you have a predictor of person&rsquo;s buying or banking preferences based on their income (BigDecimal) and where they live (Zip code). You may adapt that predictor to take Person object as input my providing a mapping function which takes person argument and returns income and zip code. You can do it asynchronously, if the function needs to call, say remote services. FittedPredictor This is a sub-interface of Predictor for predictors which were &ldquo;fitted&rdquo; or &ldquo;trained&rdquo; on a body of samples by a Fitter. Fitter Fitters create (fit) FittedPredictors synchronously or asynchronously. Asynchronous fitter takes a Flux and returns a Mono. Implementations may emit a predictor once there are enough samples to start making predictions or once predictions reach some level of quality (error drops below some threshold). Such predictors may continue to be fitted on the Flux and make predictions at the same time. For example, an MLP may make a prediction and once the correct answer is known be updated with that answer. This way you may have predictors which &ldquo;learn on the job&rdquo;. Fitters can be adapted to different feature and label types synchronously and asynchronously with mapping functions. Fitters can also be composed by using binary operators which add and subtract labels. When composed the first fitter fits a predictor on input features and labels. Then it uses the fitted predictor to predict values, computes difference with labels and predictions and fits the next predictor on the original features and the differences as labels. When predicting, predictions are added to each other. This way you may, say, predict linear trend with the first predictor, monthly seasonality with the second, weekly with the third, &hellip; Using adapter methods you may compose predictors which use different parts of a complex structure, like a mmodel, to make predictions. AbstractDoubleFitter This is a base abstract class which implements Fitter&lt;double[], double[], Double&gt;. It collects all samples to double[][] features and double[][] labels and then then calls fit(double[][] features, double[][] labels) to fit Function&lt;double[][],double[][]&gt; which makes predictions for multiple features at once. This allows to use a single base class for multiple types of predictors including Multilayer perceptrons. Essentially it takes NxF matrix of features and NxL matrix of labels to fit a predictor. N is the number of samples, F is the number of features, and L is the number of labels. Then the predictor takes MxF matrix as input and outputs MxL matrix as prediction. This class has two sub-classes: AbstractMapReduceDoubleFitter - creates a Function&lt;double[][],double[] predictor for each label element, predicts label elements using provided predictors and then combines AbstractRecursiveDoubleFitter - creates a Function&lt;double[][],double[]&gt; predictor for each label element with features for the later elements including labels for the earlier. During prediction earlier predictors outputs are used as inputs for later predictors. This is essentially how autoregression works. You can find concrete implementations in Smile and Math modules. See Connecting the dots and Architecture as code stories for more details. â†©",
    "timestamp": 1769516720003
  },
  "nsd-cli/nsd/gitlab/contribute/junit/jacoco/index.html": {
    "path": "CLI/nsd/gitlab/contribute/junit/jacoco",
    "link-uuid": "9257cd2b-34d2-42b9-8ff0-9f9fe0fd8401",
    "title": "jacoco",
    "content": "Usage: nsd gitlab contribute junit jacoco [-hV] [-c=&lt;classes&gt;] [-j=&lt;jacoco&gt;] [-m=&lt;moduleName&gt;] Loads coverage from jacoco.exec and classes directory -c, --classes=&lt;classes&gt; Classes directory path relative to the project directory, defaults to target/classes -h, --help Show this help message and exit. -j, --jacoco=&lt;jacoco&gt; jacoco.exec file path relative to the project directory, defaults to target/jacoco.exec -m, --module=&lt;moduleName&gt; Coverage module name -V, --version Print version information and exit.",
    "timestamp": 1769516720775
  },
  "practices/java/index.html": {
    "path": "Practices/Java Analysis, Visualization &amp; Generation",
    "link-uuid": "13387924-e85c-4182-a097-ebddc8dec9ba",
    "title": "Java Analysis, Visualization &amp; Generation",
    "content": "This practice is a specialization of the Analysis, Visualization &amp; Generation Practice for using the Java model as a source model, target model, or both. This page provides a high level reference and the book goes into details. So what is possible to do with the Java model/language in addition to generic analysis, visualization and generation? Analysis Java model can be loaded from sources and bytecode. Tests coverage can be loaded from jacoco.exec and class files and associated with model elements. Bytecode information can be used to establish bi-directional references between model elements - field access, method calls. Bytecode can be instrumented to collect runtime cross-referencing such as reflective method calls and field access. Visualization Module, package, class, method dependency graphs. The graphs may reflect coverage data so they can be used for prioritization of addressing technical debt. For example, many well-covered microservices may use a shared library with low coverage. Sequence diagrams Generation Documentation Documentation similar to documentation generated from Ecore models such as Java model above, Family model, or Enterprise model with: * Visualizations mentioned above\n* Documentation produced by GenAI - explainations and recommendations.\n Such documentation may be useful in modernization efforts where there is a need to understand a legacy codebase. It may also be useful in onboarding of new team members and it might help provide deeper insights into the codebase for all team members. Source code Source code with @Generated annotations or @generated Javadoc tags to allow detection of changes in the generated code and re-generation only if there changes in the generator inputs, and the output was not modified since the last generation. It allows concurrent evolution of the generator, generator inputs, and manual modifications. For more details see Solution instantiation. RAG/Chat RAG/Chat on top of the Java model may use bytecode and runtime introspection information in addition to just source code. For example &ldquo;This method is overridden by &hellip; and is called by &hellip;&rdquo;. RAG may be contextual - chat with a class, a method, a package, a module or an application (group of modules) if the model elements are &ldquo;mounted&rdquo; under higher level constructs such as products and segments.",
    "timestamp": 1769516721007
  },
  "nsd-cli/nsd/shell/index.html": {
    "path": "CLI/nsd/shell",
    "link-uuid": "81cdd936-1c8d-4179-9481-2f44d652c936",
    "title": "shell",
    "content": "Usage: nsd shell [-hV] Starts an interactive shell or executes commands from input files or URL's -h, --help Show this help message and exit. -V, --version Print version information and exit.",
    "timestamp": 1769516720905
  },
  "nsd-cli/nsd/model/ecore/index.html": {
    "path": "CLI/nsd/model/ecore",
    "link-uuid": "ccac1743-3235-43d2-aadc-e753f6539605",
    "title": "ecore",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd model ecore [-hV] [--[no-]document] [--annotation-source=&lt;annotationSource&gt;] [--layout-height=&lt;layoutHeight&gt;] [--layout-width=&lt;layoutWidth&gt;] [--ns-prefix=&lt;nsPrefix&gt;] [--ns-uri=&lt;nsURI&gt;] [--catalog=&lt;catalogs&gt;]... [--schema=&lt;schemas&gt;]... [--table=&lt;tables&gt;]... [--table-types=&lt;tableTypes&gt;]... [COMMAND] Generates a Ecore model from a database model --annotation-source=&lt;annotationSource&gt; Annotation source defaults to urn:org.nasdanika.models.sql --catalog=&lt;catalogs&gt; Catalogs to include all catalogs if not provided --[no-]document Generate documentation for model elements defaults to true -h, --help Show this help message and exit. --layout-height=&lt;layoutHeight&gt; Heigth for force layout defaults to 1080 --layout-width=&lt;layoutWidth&gt; Width for force layout defaults to 1920 --ns-prefix=&lt;nsPrefix&gt; Database namespace prefix defaults to the database name --ns-uri=&lt;nsURI&gt; Database namespace URI defaults to the database URI (connection string) --schema=&lt;schemas&gt; Schemas to include all schemas if not provided --table=&lt;tables&gt; Tables to include all tables if not provided --table-types=&lt;tableTypes&gt; Table names to include all table types if not provided -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720882
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/http-server/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/http-server",
    "link-uuid": "bee059d1-633f-4fb4-b1a3-3792aebf48a3",
    "title": "http-server",
    "content": "Version: org.nasdanika.http@2025.12.0 Usage: nsd sql metadata catalog-diagram http-server [-hV] [--[no-]console] [--progress-console] [--progress-data] [--progress-json] [--connection-base=&lt;connectionBase&gt;] [--http-host=&lt;httpHost&gt;] [--http-port=&lt;httpPort&gt;] [--http-server-shutdown-timeout=&lt;timeout&gt;] [--open=&lt;uriToOpen&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;processorProperty&gt; &lt;routeProperty&gt; Routes HTTP requests to a diagram element processor &lt;processorProperty&gt; Processor property &lt;routeProperty&gt; Route property --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET --[no-]console If true, starts a console and waits for the exit command, otherwise creates a shutdown hook disposing the server -h, --help Show this help message and exit. --http-host=&lt;httpHost&gt; HTTP host (network interface) to bind to --http-port=&lt;httpPort&gt; HTTP port. If a port is not specified, an ephemeral port is used --http-server-shutdown-timeout=&lt;timeout&gt; Timeout in seconds, defaults to 3 seconds --open=&lt;uriToOpen&gt; Opens provided URI in the system browser the URI is resolved relative to http://localhost:&lt;port&gt;/ --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio diagram.drawio http-server --http-port=8080 processor route Parent drawio command loads diagram.drawio file This command: Loads processor invocable URIs from the processor property Loads route definitions from the route property Serves diagram element routes on port 8080 Resources Serving HTTP &mdash; Diagrams &amp; Reflection story Routing HTTP Reactor Netty Reference Guide Parameters &lt;processorProperty&gt; &lt;routeProperty&gt; &lt;processorProperty&gt; &lt;routeProperty&gt;  ",
    "timestamp": 1769516720927
  },
  "nsd-cli/nsd/drawio/to-model/save/index.html": {
    "path": "CLI/nsd/drawio/to-model/save",
    "link-uuid": "04daac1b-8d66-462e-a08a-635b1e4874c7",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio to-model save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;] ... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720764
  },
  "nsd-cli/nsd/model/html-app/save/index.html": {
    "path": "CLI/nsd/model/html-app/save",
    "link-uuid": "220ba230-a052-4140-8f09-e6e6d4cee34c",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]. .. [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720895
  },
  "nsd-cli/nsd/sql/metadata/ecore/html-app/site/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/html-app/site",
    "link-uuid": "6cfc7386-c069-4a51-8927-a0076ffbe144",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd sql metadata ecore html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720970
  },
  "nsd-cli/nsd/sql/metadata/ecore/html-app/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/html-app",
    "link-uuid": "22699faa-0ce1-44b4-8908-8ea88e03e83d",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd sql metadata ecore html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String= Class&gt;]... [--extension-resource-factory=&lt;String=Cla ss&gt;]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Clas s&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720964
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/invoke/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/invoke",
    "link-uuid": "bd139391-2cdd-4158-8091-d418d915313a",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram invoke [-hV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;bindProperty&gt;] [-c=&lt;connectionBase&gt;] [-p=&lt;processorProperty&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [&lt;parameters&gt;...] Creates an Invocable dynamic proxy from a diagram calls it with command parameters and returns result [&lt;parameters&gt;...] Invocable parameters -b, --bind-property=&lt;bindProperty&gt; Bind property providing dynamic proxy method name Defaults to bind -c, --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET -h, --help Show this help message and exit. -p, --processor-property=&lt;processorProperty&gt; Processor property Defaults to processor --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio -p my-property=&quot;My property&quot; invocable.drawio invoke 33 66 The parent drawio command loads invocable.drawio diagram with my-property property set to My property. This property is used for placeholder expansion. This command: Uses default values for --processor-property and --bind-property options to create diagram element processors and bind them to dynamic proxy methods - in this case a single invoke() method. Calls the method with command line arguments - 33 and 66 Options -p, --processor-property -p, --processor-property ",
    "timestamp": 1769516720932
  },
  "nsd-cli/nsd/http-server/index.html": {
    "path": "CLI/nsd/http-server",
    "link-uuid": "050b9fd2-51c7-486c-830f-bd10fd4e1f4d",
    "title": "http-server",
    "content": "Usage: nsd http-server [-hV] [--[no-]console] [--http-host=&lt;httpHost&gt;] [--http-port=&lt;httpPort&gt;] [--http-server-shutdown-timeout=&lt;timeout&gt;] [--open=&lt;uriToOpen&gt;] Serves HTTP routes --[no-]console If true, starts a console and waits for the exit command, otherwise creates a shutdown hook disposing the server -h, --help Show this help message and exit. --http-host=&lt;httpHost&gt; HTTP host (network interface) to bind to --http-port=&lt;httpPort&gt; HTTP port. If a port is not specified, an ephemeral port is used --http-server-shutdown-timeout=&lt;timeout&gt; Timeout in seconds, defaults to 3 seconds --open=&lt;uriToOpen&gt; Opens provided URI in the system browser the URI is resolved relative to http://localhost:&lt;port&gt;/ -V, --version Print version information and exit.",
    "timestamp": 1769516720795
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/html-app/crew-ai",
    "link-uuid": "7b69735c-85d9-4629-ae25-d207698d8332",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720939
  },
  "nsd-cli/nsd/launcher/index.html": {
    "path": "CLI/nsd/launcher",
    "link-uuid": "01bcdc8e-2c88-4666-a032-2614ef70c751",
    "title": "launcher",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd launcher [-hstvV] [-a=&lt;args&gt;] [--add-modules=&lt;addModules&gt;] [-b=&lt;base&gt;] [-c=&lt;className&gt;] [-C=&lt;classPathModules&gt;] [-f=&lt;optionsFile&gt;] [-j=&lt;javaCommand&gt;] [-m=&lt;moduleName&gt;] [-M=&lt;modulesFile&gt;] [-o=&lt;output&gt;] [-p=&lt;pathSeparator&gt;] [-P=&lt;prefix&gt;] [-r=&lt;rootModules&gt;] [&lt;repositories&gt;...] Generates Java command line from directories of modules/jars [&lt;repositories&gt;...] Directories to scan for modules, defaults to lib -a, --args=&lt;args&gt; Arguments, defaults to %* --add-modules=&lt;addModules&gt; Comma-separated list of modules to add to Java command --add-modules Computed if not specified -b, --base=&lt;base&gt; Base repositories directory -c, --class=&lt;className&gt; Application class, defaults to org.nasdanika.cli.Application -C, --claspath-modules=&lt;classPathModules&gt; Comma-separated list of classpath modules -f, --options-file=&lt;optionsFile&gt; File to output options to -h, --help Show this help message and exit. -j, --java=&lt;javaCommand&gt; Java command, defaults to java Can be used to add extra options such as system properties -m, --module=&lt;moduleName&gt; Application module, defaults to org.nasdanika.cli -M, --modules=&lt;modulesFile&gt; Modules to add to the module path -o, --output=&lt;output&gt; Output file -p, --path-separator=&lt;pathSeparator&gt; Path separator, defaults to the system path separator -P, --prefix=&lt;prefix&gt; Module path prefix -r, --root-modules=&lt;rootModules&gt; Comma-separated list of root modules Supports .* and .** patterns -s, --absolute Use absolute paths -t, --options Output only options -v, --verbose Output debug information -V, --version Print version information and exit.",
    "timestamp": 1769516720812
  },
  "nsd-cli/nsd/sql/metadata/ecore/save/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/save",
    "link-uuid": "08950609-a77d-431f-af71-4edd53b32e03",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata ecore save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Clas s&gt;]... [--extension-resource-factory=&lt;String=Class&gt;] ... [--protocol-resource-factory=&lt;String=Class&gt;]. .. &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720975
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/save/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/save",
    "link-uuid": "b0032fe8-7eaf-498f-9b4b-ccf852325867",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram save [-hV] [--[no-]compress] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;output&gt; Saves diagram to a file &lt;output&gt; Output file --[no-]compress Compress output -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit.",
    "timestamp": 1769516720934
  },
  "nsd-cli/nsd/drawio/index.html": {
    "path": "CLI/nsd/drawio",
    "link-uuid": "434509bd-a229-40e6-83c4-16139486ed53",
    "title": "drawio",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio [-fhV] [-b=&lt;baseUri&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... [-u=&lt;String=String&gt;]... [-U=URL of URI to URL mapping resource]... &lt;document&gt; [COMMAND] Loads Drawio document from a URI or file &lt;document&gt; Document URI or file path, resolved relative to the current directory -b, --base-url=&lt;baseUri&gt; Base URI for reolving document and target URIs. Defaults to the current directory URI Resolved relative to the current directory URI -f, --file Document parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former -u, --uri=&lt;String=String&gt; URI mapping. Target URIs are resolved relative to the base URI -U, --uris=URL of URI to URL mapping resource URI map resource URL relative to the document file YAML, JSON, or properties Type is inferred from the content type header, if it is present, or extension -V, --version Print version information and exit. Commands: html-app - Generates html application model from a drawio document http-server - Routes HTTP requests to a diagram element processor invoke - Creates an Invocable dynamic proxy from a diagram save - Saves diagram to a file to-model - Converts diagram to diagram model Examples drawio test-data/jira/diagram.drawio html-app -r test-data/jira/root-action.yml --add-to-root site -r=-1 -F test-data/jira/page-template.yml test-data/jira/docs Loads test-data/drawio-http/diagram.drawio diagram resource Executes html-app sub-command and its site sub-command to generate a documentation site drawio test-data/drawio-http/diagram.drawio http-server --http-port=8080 processor route Loads test-data/drawio-http/diagram.drawio diagram resource Executes http-server sub-command which serves diagram element routes at port 8080 drawio -p my-property=&quot;My property&quot; test-data/invocable.drawio invoke 33 66 Sets property my-property to My property Loads test-data/invocable.drawio diagram document Executes invoke sub-command with 33 and 66 arguments URI Handlers The command loads URI Handlers using the capability framework. You can load resources from Maven with the Maven URI Handler. You can also create and register a custom URI handler, for example GitLabURIHandler to load diagram resources from GitLab. Below is an example of a capability factory: \nimport org.eclipse.emf.ecore.resource.URIConverter;\nimport org.eclipse.emf.ecore.resource.URIHandler;\nimport org.nasdanika.capability.emf.URIConverterContributorCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\n\n/**\n * Contributes {@link URIHandler} loading from Maven repositories\n */\npublic class MavenURIHandlerCapabilityFactory extends URIConverterContributorCapabilityFactory {\n\n    @Override\n    protected void contribute(\n            URIConverter uriConverter, \n            Loader loader,\n            ProgressMonitor progressMonitor) {  \n        uriConverter.getURIHandlers().add(0, new MavenURIHandler(loader.getCapabilityLoader(), progressMonitor));\n        \n    }\n    \n}\n Contributing sub-commands To contribute a sub-command: Add @ParentCommands(Document.Supplier.class) annotation to your command class Declare a field of type Document.Supplier and annotate it with @ParentCommand. You may declare a setter method instead. Use the field value to obtain an instance of Document. as shown in the code snippet below: import org.nasdanika.cli.ParentCommands;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.drawio.Document;\n\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.ParentCommand;\n\n@Command(...)\n@ParentCommands(Document.Supplier.class)\npublic class MyCommand {\n    \n    @ParentCommand\n    private Document.Supplier documentSupplier;\n\n    public void myMethod(ProgressMonitor progressMonitor) {\n        Document document = documentSupplier.getDocument(progressMonitor); \n        ...\n    }       \n\n}\n Below is a factory: import java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionStage;\n\nimport org.nasdanika.common.ProgressMonitor;\n\nimport picocli.CommandLine;\n\npublic class MyCommanddFactory extends SubCommandCapabilityFactory&lt;MyCommand&gt; {\n\n    @Override\n    protected Class&lt;MyCommand&gt; getCommandType() {\n        return MyCommand.class;\n    }\n    \n    @Override\n    protected CompletionStage&lt;MyCommand&gt; doCreateCommand(\n            List&lt;CommandLine&gt; parentPath,\n            Loader loader,\n            ProgressMonitor progressMonitor) {\n        return CompletableFuture.completedStage(new MyCommand(loader.getCapabilityLoader()));\n    }\n\n}\n The factory shall be registered as a CapabilityFactory provider in module-info.java: import org.nasdanika.capability.CapabilityFactory;\n\nmodule &lt;module name&gt; {\n\n    ...    \n    \n    opens &lt;package with commands&gt;; // For reflection and documentation resource loading\n    \n    provides CapabilityFactory with MyCommandFactory;\n    \n}\n Executable diagrams sub-commands You can create sub-commands which execute diagrams by extending AbstractElementInvocableCommand. invoke is an example of such a command. General purpose executable graphs and diagrams Medium story explains how to create diagram element processors.",
    "timestamp": 1769516720741
  },
  "nsd-cli/nsd/drawio/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/drawio/html-app/crew-ai",
    "link-uuid": "8138d6d1-977b-443b-9688-3e9941c5b607",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd drawio html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Clas s&gt;]... [--extension-resource-factory=&lt;String=Class&gt;] ... [--protocol-resource-factory=&lt;String=Class&gt;]. .. &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720722
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/html-app/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/html-app",
    "link-uuid": "17416d7a-fa75-4feb-8462-74ed7b6659f1",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram html-app [-fhRV] [--[no-]tooltip] [-b=&lt;base&gt;] [-P=&lt;insertionIndex&gt;] [--page=Page name] [--predicate=&lt;predicate&gt;] [-r=&lt;rootLabel&gt;] [--ref-base-uri=&lt;refBase&gt;] [-x=&lt;indexName&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-F=Invocable URI]... [--predicate-property=Predicate property]... [--protocol-resource-factory=&lt;String=Class&gt;]... [--representation-filter-property=Predicate property]... [--tag=&lt;tag&gt;]... [COMMAND] Generates html application model from a drawio document -b, --base-uri=&lt;base&gt; Base URI. E.g. 'pages/' --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -F, --representation-element-filter=Invocable URI Invocable URI of a representation element filter URIs are resolved relative to the current directory -h, --help Show this help message and exit. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --page=Page name If provided, actions are generated for the page with matching name --predicate=&lt;predicate&gt; SpEL expression for filtering diagram elements --predicate-property=Predicate property Mapping of a script language name to the property name containing predicate script in this language 'spel' is reserved for SpEL --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present --ref-base-uri=&lt;refBase&gt; Base URI for resolving documentation and prototype references. Resolved relative to the document URI --representation-filter-property=Predicate property Mapping of a script language name to the property name containing representation filter script in this language --tag=&lt;tag&gt; Tag(s) to filter diagram elements --[no-]tooltip Use tooltip as documentation if documentation is empty. Default: true -V, --version Print version information and exit. -x, --index=&lt;indexName&gt; Index file name, defaults to index.html Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Parent drawio command loads diagram.drawio diagram resource This command: Generates an html application model from the diagram elements Loads a root action from root-action.yml resource Adds the generated labels to the root action Passes the resulting model to the site sub-command to generate a documentation site Diagram element configuration Diagram elements can be configured with the following properties: child-comparator - a YAML specification for sorting child elements as explained below documentation - documentation text in documentation format doc-format - explicitly specified documentation format for documentation and doc-ref. Out of the box: markdown (default), html text doc-ref - URI of a documentation resource resolved relative to the URI of the diagram file. Documentation format is derived from the URI extension, defaulting to markdown. Use doc-format to override. icon - diagram element icon URL resolved relative to the diagram file. If there is no slash (/) in the icon name then it is treated as a CSS style, e.g. fas fa-user. For image diagram elements icons are derived from element images. It is recommended to use SVG 20x20 OR 18x18 pixels for icons because they are also used in page titles and PNG images get blurry when scaled up. parent - Connection property with values source or target. Use to generate documentation from mind maps where parent/child relationship is defined by connections, not by containment. prototype &amp; proto-ref &ndash; YAML specification of html application action, link or label. See load specifications of respective model elements for supported configuration keys. If both properties are specified, prototype takes precedence over proto-ref. With prototypes you can: Generate complex site pages (actions) with children, navigation, sections, &hellip; Reuse action models. For example, generate an action model from one diagram and use it as a prototype for an element of another diagram. Or generate an action model for CLI or Ecore documentation. role - action/page role: anonymous (default for connections) child (default for nodes) navigation section sort-key - By default generated pages (actions) are sorted alphabetically by title. This property can be used to customize sorting. If it is set then pages are sorted first by the property value and then by page title. title - By default the element label is used as page title (action text). Use this property to explicitly set the page title. For example, for elements with long labels. Site pages are generated only for elements with: Documentation (documentation or doc-ref), prototypes (prototype or prototype-ref), or both. Labels or title property. If you don&rsquo;t want an element label to be visible (e.g. on connections) uncheck &ldquo;Font color&rdquo; checkbox on the &ldquo;Text&rdquo; tab. child-comparator The specification can be a list, a string, or a map. Lists are treated as maps with null values and strings are treated as singleton maps with null values. Map entry keys are comparator names and values are configurations. The following comparators are supported: enumerate and reverse-enumerate order model elements using enumerate value. Elements without enumerate value are considered equal to any other elements including those with enumerate value. This is done to allow chaining with, say, flow comparator. As a result, this comparator will violate the transitivity requirement if some elements don&rsquo;t have enumerate value. Therefore, it shall be chained with other comparators. For example, flow and then position or label. Enumerate value is treated as path of dot-separated values and two enumerate values are compared element-by-element with elements containing only digits parsed and compared as integers. For example, 20 would be greater than 3, 1.1.1 would be greater than 1.1 and smaller than 2.5.6 or 3. Numbers are considered smaller than strings 1.12 is smaller than 1.a Practical use - ordering connections emanating from the same node. Say, excursions from the same location. If those excursions have multiple segments, then this comparator can be chained with the flow comparator and possibly terminated by the position or label comparator just in case. flow and reverse-flow order elements based on how they are connected to each other. These comparators configuration is either null, string or a list of strings. Strings are evaluated as Spring Expression Language (SpEL) boolean expressions in the context of connections. If the expression evaluates to false, then the given connection is not included in the flow traversal. It can be used if there are loops. For example, you plan a trip and want the destinations to be sorted in the visit order. There is a loop - the returning flight home. You can provide an expression which evaluates to false for that flight. position and reverse-position order elements by their position in the container&rsquo;s children list (z-order). down-right - Compares nodes by their vertical order first with higher nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. This comparator can be used for org. charts. left-down - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. left-up - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-down - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-up - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. up-left - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the right being smaller. Nodes are considered vertically equal if they vertically overlap. up-right - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. icon Drawio has more than two thousand built-in icons. You can find more icons on the below sites: Font Awesome 5 icons FlatIcons - 16.8 million icons. Free with attribution, a paid plan is available - no attribution. In-browser editor. PNG and SVG (premium) formats. IconFinder - the world&rsquo;s largest marketplace for icons, &hellip; 6 million icons at your fingertips including free icons. Multiple subscription levels. Iconduck - more than 250 000 free open source icons Techicons - SVG and PNG tech icons, sourced from https://github.com/devicons/devicon. 473 icons. Cloud providers: Azure AWS prototype If your top-level diagram page is generated as a principal action and the root action or link references some external site, e.g. your company site, then you need to use the following prototype for proper generation: Action:\n  location: ${base-uri}index.html\n Below is an example of a prototype which defines a navigation action: Action:\n    navigation:\n      - Action:\n          location: about-wendy.html\n          icon: fas fa-help\n          text: About\n          content:\n            Interpolator:\n              source:\n                exec.content.Text: |    \n                  This is an example of a page from an action prototype.\n proto-ref Property value is a URI of the prototype action or label resolved relative to the element base URI. For example bob-prototype.yml#/. Element ID Element IDs are used to construct element page URLs. Element IDs are generated as long random strings. They are editable - double-click on the ID at the top of the data dialog. So, if you&rsquo;d like to have semantic URLs - customize the IDs. Page and element links You may link elements to pages and other element using the extended link syntax. When an element links to a page, the page root1 is logically merged with the linking element and page elements (except elements liking to other elements) become logical children of the linking element. If an element links to another element, then that element is not considered a logical child of the page/root/page linking element. The link chain is traversed and the diagram element on the generated site is linked to the page of the link target element if that element has a page (i.e. it is documented). Otherwise there is no link. Multiple top-level pages A top-level diagram page is a page that is not linked from any diagram element. If there is more than one top-level page, add a principal action to the root-action.yml and link pages to the principal action. Examples: Beyond Diagrams Illustrations Declarative Command Pipelines See Drawio API â†© Options -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx. -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.   You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.",
    "timestamp": 1769516720918
  },
  "nsd-cli/nsd/java/junit/jacoco/index.html": {
    "path": "CLI/nsd/java/junit/jacoco",
    "link-uuid": "a03fedec-7e07-4795-b083-37881d4b3229",
    "title": "jacoco",
    "content": "Usage: nsd java junit jacoco [-hV] [-c=&lt;classes&gt;] [-j=&lt;jacoco&gt;] [-m=&lt;moduleName&gt;] Loads coverage from jacoco.exec and classes directory -c, --classes=&lt;classes&gt; Classes directory path relative to the project directory, defaults to target/classes -h, --help Show this help message and exit. -j, --jacoco=&lt;jacoco&gt; jacoco.exec file path relative to the project directory, defaults to target/jacoco.exec -m, --module=&lt;moduleName&gt; Coverage module name -V, --version Print version information and exit.",
    "timestamp": 1769516720809
  },
  "html/html-graph/index.html": {
    "path": "HTML/Graph",
    "link-uuid": "ed5f8c23-b9d6-4db4-9a5d-60af5390ba25",
    "title": "Graph",
    "content": "Requirement and core factory for producer processors to generate HTML from graphs. Sources Javadoc",
    "timestamp": 1769516720607
  },
  "nsd-cli/nsd/gitlab/contribute/index.html": {
    "path": "CLI/nsd/gitlab/contribute",
    "link-uuid": "046f1205-eba8-4055-ae13-1fb4ace1d70d",
    "title": "contribute",
    "content": "Usage: nsd gitlab contribute [-hV] [-a=&lt;String=String&gt;]... (&lt;authorEmail&gt; &lt;authorName&gt; [-m=&lt;commitMessage&gt;] [-b=&lt;branch&gt;] [-f] [-s]) [[-t=&lt;targetBranch&gt;] [--[no-] allow-collaboration] [--approvals-before-merge=&lt;approvalsBeforeMerge&gt;] [--assignee=&lt;Assignee ID&gt;]... [--merge-request-description=&lt;description&gt;] [-- [no-]discussion-locked] [--label=&lt;labels&gt;]... [--milestone=&lt;milestoneId&gt;] [--[no-] remove-source-branch] [--reviewer=&lt;Reviewer ID&gt;]... [--[no-]squash] [--merge-request-title=&lt;title&gt;] [--state-event=&lt;stateEvent&gt;]] [COMMAND] Parent for sub-command contributing via GitLabURIHandler -a, --alias=&lt;String=String&gt; Map project alias (key) to project ID or path (value) -h, --help Show this help message and exit. -V, --version Print version information and exit. Commit &lt;authorEmail&gt; Commit author eMail &lt;authorName&gt; Commit author name -b, --branch=&lt;branch&gt; Branch to commit to -f, --force Force commit -m, --commit-message=&lt;commitMessage&gt; Commit message -s, --stats With stats Merge request --[no-]allow-collaboration --approvals-before-merge=&lt;approvalsBeforeMerge&gt; Number of approvals before merge --assignee=&lt;Assignee ID&gt; Assignee ID --[no-]discussion-locked --label=&lt;labels&gt; --merge-request-description=&lt;description&gt; --merge-request-title=&lt;title&gt; --milestone=&lt;milestoneId&gt; Milestone ID --[no-]remove-source-branch --reviewer=&lt;Reviewer ID&gt; Reviewer ID --[no-]squash --state-event=&lt;stateEvent&gt; Valid values: close, reopen -t, --target-branch=&lt;targetBranch&gt; Target branch, defaults to the original branch Commands: invoke - Invokes URI junit - Generates JUnit tests retrospect - Parent for sub-commands contributing based on history",
    "timestamp": 1769516720767
  },
  "nsd-cli/nsd/sql/invoke/index.html": {
    "path": "CLI/nsd/sql/invoke",
    "link-uuid": "3dfe41ae-28e6-4825-8d0b-461e2a5ca7db",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql invoke [-fhV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... &lt;uri&gt; [&lt;bindings&gt;...] Invokes URI &lt;uri&gt; URI to invoke [&lt;bindings&gt;...] Bindings URIs -f, --file URI parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Loads an invocable from a URI as explained in Loading Invocables from URIs and then invokes it with arguments obtained from parameters invocable URIs.",
    "timestamp": 1769516720911
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/html-app/site/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/html-app/site",
    "link-uuid": "231af1a4-fab5-4da5-84b9-7494ac016cc6",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720924
  },
  "ai/ai-math/index.html": {
    "path": "AI/Math",
    "link-uuid": "dc97b03a-3634-48ba-a530-c0de1f085ce0",
    "title": "Math",
    "content": "Sources Maven Central Javadoc This module contains wrappers of some Apache Commons Math regression classes as FittedPredictor.Fitter&lt;double[], double[], Double&gt;. Example PolynomialPredictorFitter ppf = new PolynomialPredictorFitter(1);\n\nWeightedObservedPoints wobs = new WeightedObservedPoints();\nwobs.add(1, 2);\nwobs.add(2, 2.9);\nwobs.add(3, 4.1);\nwobs.add(4, 5);\nwobs.add(5, 6);\n        \nFittedPredictor&lt;double[], double[], Double&gt; predictor = ppf.fit(\n        wobs.toList(), \n        p -&gt; new double[] { p.getX() }, \n        p -&gt; new double[] { p.getY(), p.getY() + 10 });\n\nSystem.out.println(predictor.getError());\n\ndouble[] prediction = predictor.predict(new double[] { 6.0 });              \nSystem.out.println(Arrays.toString(prediction));",
    "timestamp": 1769516720038
  },
  "core/cli/index.html": {
    "path": "Core/CLI",
    "link-uuid": "dff548a3-6a58-4ad4-9516-f71fdd1f2663",
    "title": "CLI",
    "content": "Classes in this module allow to declaratively construct command line interfaces. It uses picocli to execute commands and capability framework to collect sub-commands and mix-ins. This way command line interfaces can be constructed top-down (default picocli functionality) - parent commands explicitly define sub-commands, and bottom-up - sub-commands are added to parent commands by the framework. Top-down construction can be done using out-the-box picocli capabilities - programmatic add and annotations. Both top-down and bottom-up construction can be done using the capability framework which allows sub-commands/mix-ins to request capabilities they need and add themselves to parent commands only if all requirements are met. The module provides a capability to build polymorphic CLI&rsquo;s - sub-commands and mix-ins may override other sub-commands and mix-ins with the same name. This is similar to method overriding in Object-Oriented languages like Java. For example, a base CLI package may have a basic implementation of some sub-command. A derived package would add dependencies with advanced sub-commands to pom.xml. These sub-commands would replace (override) basic sub-commands during construction of the command hierarchy. Sources Javadoc Medium stories: Beyond PicoCLI Declarative Command Pipelines Contributing sub-commands @SubCommands annotation @ParentCommands annotation Programmatic match Contributing mix-ins @MixIns annotation @ParentCommands annotation Programmatic match Overriding Extended documentation Commands Mix-ins Shell Closing commands Building distributions Downloading dependencies Generating launcher scripts Assembly Contributing sub-commands In addition to the picocli way of adding sub-commands programmatically and using @Command annotation subcommands element this module provides a few more ways to contribute sub-commands which are explained below. In all cases create a sub-class of SubCommandCapabilityFactory and implement/override the following methods: getCommandType - used for declarative matching createCommand for imperative (programmatic) matching doCreateCommand: Declarative - in combination with @SubCommands or @Parent Imperative - override match() as well. Add to module-info.java: provides org.nasdanika.capability.CapabilityFactory with &lt;factory class&gt; opens &lt;sub-command package name&gt; to info.picocli, org.nasdanika.html.model.app.gen.cli; Opening to org.nasdanika.html.model.app.gen.cli is needed if you want to generate extended documentation (see below). @SubCommands annotation This one is similar to @Command.subcommands - the parent command declares types of sub-commands. However: Sub-commands are collected using the capability framework from SubCommandCapabilityFactory&rsquo;s. Sub-commands types listed in the annotation are base types - classes or interfaces - not necessarily concrete implementation types. E.g. you may have HelpCommand interface or base class and all commands implementing/extending this class will be added to the parent command. If there are two commands with the same name one of them might override the other as explained below. @ParentCommands annotation In this case the sub-command or mix-in class are annotated with @ParentCommands annotation listing types of parents. The sub-command/mix-in will be added to all commands in the hierarchy which are instances of the specified parent types - exact class, interface implementation, or sub-class, or implement Adaptable and return non-null value from adaptTo(Class) method. This allows to create declarative command pipelines as explained in the Declarative Command Pipelines Medium story. Programmatic match The above two ways of matching parent commands and sub-commands are handled by the SubCommandCapabilityFactory.match() method. You may override this method or createCommand() method to programmatically match parent path and decide whether to contribute a sub-command or not. Contributing mix-ins Similar to sub-commands, mix-ins can be contributed top-down and bottom-up - declaratively using annotations and programmatically. In all cased create s sub-class of MixInCapabilityFactory, implement/override: getMixInType() - for declarative matching getName() createMixIn() for imperative matching, or doCreateMixIn() Declarative - in combination with @MixIns or @Parent Imperative - override match() as well. Add to module-info.java: provides org.nasdanika.capability.CapabilityFactory with &lt;factory class&gt; opens &lt;mix-in package name&gt; to info.picocli; @MixIns annotation Mix-ins are collected using the capability framework from MixInCapabilityFactory&rsquo;s. Mix-in types listed in the annotation are base types - classes or interfaces - not necessarily concrete implementation types. @ParentCommands annotation See &ldquo;@ParentCommands annotation&rdquo; sub-section in &ldquo;Contributing sub-commands&rdquo; section above. Programmatic match The above two ways of matching parent commands and sub-commands/mix-ins are handled by the MixInCapabilityFactory.match() method. You may override this method or createMixIn() method to programmatically match parent path and decide whether to contribute a mix-in or not. Overriding A command/mix-in overrides another command/mix-in if: It is a sub-class of that command/mix-in It implements Overrider interface and returns true from overrides(Object other) method. It is annotated with @Overrides and the other command is an instance of one of the value classes. Extended documentation You may annotate commands, parameters, and options with @Description to provide additional information in the generated HTML site. If @Description annotation does not have value or resource attributes set, then documentation resource name is implied from command, parameter, or option as follows: Command - documentation resource name is &lt;class name&gt;.&lt;extension&gt; where &lt;extension&gt; is one of extensions supported by documentation factories. All factories and all extensions are iterated and the first found resource is used to generate documentation. Example: MyCommand.md. Option - documentation resource name is &lt;declaring class name&gt;-opt&lt;option name&gt;.&lt;extension&gt;. All factories, all extensions, and all option names are iterated and the first found resource is used to generate documentation. Example: MyCommand-opt--my-option.md. Parameter - supported only for field parameters. Documentation resource name is &lt;declaring class name&gt;-param-&lt;field name&gt;.&lt;extension&gt;. All factories and all extensions are iterated and the first found resource is used to generate documentation. Example: MyCommand-param--myParam.md. Commands The CLI module provides several base command classes: CommandBase - base class with standard help mix-in CommandGroup - base class for commands which don&rsquo;t have own functionality, only sub-commands ContextCommand - command with options to configure Context DelegatingCommand - options to configure Context and ProgressMonitor and delegate execution to SupplierFactory HelpCommand - outputs usage for the command hierarchy in text, html, action model, or generates a documentation site Mix-ins The module also provides several mix-ins: ContextMixIn - creates and configures Context ProgressMonitorMixIn - creates and configures ProgressMonitor ResourceSetMixIn - creates and configures ResourceSet using CapabilityLoader to add packages, resource and adapter factories, &hellip; Shell ShellCommand can be used to execute multiple commands in the same JVM. Closing commands Commands implementing org.nasdanika.common.Closeable, including CommandBase and its subclasses are closed recursively. This functionality can be used to release resources or save state to the permanent storage, e.g. file system. Building distributions A distribution is a collection of modules contributing commands and mix-ins plus launcher scripts for different operating systems. org.nasdanika.cli and org.nasdanika.launcher modules are examples of building distributions as part of a Maven build. Building a distribution involves the following steps: Downloading modules (dependencies) Generating launcher scripts Building an assembly (zip) All of the above steps are executed by mvn verify or mvn clean verify Downloading dependencies Dependencies can be downloaded using Maven dependency plug-in: &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n\txmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n\txsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n\t\n\t...\n\n\t&lt;dependencies&gt;\n\t\t...\n\t&lt;/dependencies&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t...\n\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n\t\t\t\t&lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n\t\t\t\t&lt;version&gt;3.6.1&lt;/version&gt;\n\t\t\t\t&lt;executions&gt;\n\t\t\t\t\t&lt;execution&gt;\n\t\t\t\t\t\t&lt;id&gt;copy-dependencies&lt;/id&gt;\n\t\t\t\t\t\t&lt;phase&gt;prepare-package&lt;/phase&gt;\n\t\t\t\t\t\t&lt;goals&gt;\n\t\t\t\t\t\t\t&lt;goal&gt;copy-dependencies&lt;/goal&gt;\n\t\t\t\t\t\t&lt;/goals&gt;\n\t\t\t\t\t\t&lt;configuration&gt;\n\t\t\t\t\t\t\t&lt;outputDirectory&gt;\n\t\t\t\t\t\t\t\t${project.build.directory}/dist/lib\n\t\t\t\t\t\t\t&lt;/outputDirectory&gt;\n\t\t\t\t\t\t\t&lt;useRepositoryLayout&gt;true&lt;/useRepositoryLayout&gt;\t\t\t\t\t\t\t\n\t\t\t\t\t\t&lt;/configuration&gt;\n\t\t\t\t\t&lt;/execution&gt;\n\t\t\t\t&lt;/executions&gt;\n\t\t\t&lt;/plugin&gt;\n\t\t\t\n\t\t\t...\n\t&lt;/build&gt;\n\n\t...   \n&lt;/project&gt;\n Generating launcher scripts Launcher scripts can be generated using launcher command. The command can be issued manually from the command line. Alternatively, you can execute the launcher command from an integration test as shown below: public class BuildDistributionIT {\n\t\t\n\t@Test\n\tpublic void generateLauncher() throws IOException {\n\t\tfor (File tf: new File(&quot;target&quot;).listFiles()) {\n\t\t\tif (tf.getName().endsWith(&quot;.jar&quot;) &amp;&amp; !tf.getName().endsWith(&quot;-sources.jar&quot;) &amp;&amp; !tf.getName().endsWith(&quot;-javadoc.jar&quot;)) {\n\t\t\t\tFiles.copy(\n\t\t\t\t\t\ttf.toPath(), \n\t\t\t\t\t\tnew File(new File(&quot;target/dist/lib&quot;), tf.getName()).toPath(), \n\t\t\t\t\t\tStandardCopyOption.REPLACE_EXISTING);\t\t\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tModuleLayer layer = Application.class.getModule().getLayer();\n\t\ttry (Writer writer = new FileWriter(new File(&quot;target/dist/modules&quot;))) {\n\t\t\tfor (String name: layer.modules().stream().map(Module::getName).sorted().toList()) {\n\t\t\t\twriter.write(name);\n\t\t\t\twriter.write(System.lineSeparator());\n\t\t\t};\n\t\t}\n\t\t\n\t\tCommandLine launcherCommandLine = new CommandLine(new LauncherCommand());\n\t\tlauncherCommandLine.execute(\n\t\t\t\t&quot;-b&quot;, &quot;target/dist&quot;, \n\t\t\t\t&quot;-M&quot;, &quot;target/dist/modules&quot;, \n\t\t\t\t&quot;-f&quot;, &quot;options&quot;,\n\t\t\t\t&quot;-j&quot;, &quot;@java&quot;,\n\t\t\t\t&quot;-o&quot;, &quot;nsd.bat&quot;);\n\t\t\n\t\tlauncherCommandLine.execute(\n\t\t\t\t&quot;-b&quot;, &quot;target/dist&quot;, \n\t\t\t\t&quot;-M&quot;, &quot;target/dist/modules&quot;, \n\t\t\t\t&quot;-j&quot;, &quot;#!/bin/bash\\n\\njava&quot;,\n\t\t\t\t&quot;-o&quot;, &quot;nsd&quot;,\n\t\t\t\t&quot;-p&quot;, &quot;:&quot;,\n\t\t\t\t&quot;-a&quot;, &quot;$@&quot;);\t\t\n\t\t\n\t}\n\n}\n If the Maven project which builds the distribution does not contribute its own code, then the for loop copying the jar file can be omitted. Assembly Create an assembly file dist.xml similar to the one below in src\\assembly directory: &lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.0.0&quot;\n  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n  xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.0.0 http://maven.apache.org/xsd/assembly-2.0.0.xsd&quot;&gt;\n  &lt;id&gt;dist&lt;/id&gt;\n  &lt;formats&gt;\n    &lt;format&gt;tar.gz&lt;/format&gt;\n    &lt;format&gt;tar.bz2&lt;/format&gt;\n    &lt;format&gt;zip&lt;/format&gt;\n  &lt;/formats&gt;\n  &lt;fileSets&gt;\n    &lt;fileSet&gt;\n      &lt;directory&gt;${project.build.directory}/dist&lt;/directory&gt;\n      &lt;outputDirectory&gt;/&lt;/outputDirectory&gt;\n      &lt;useDefaultExcludes&gt;false&lt;/useDefaultExcludes&gt;\n    &lt;/fileSet&gt;\n  &lt;/fileSets&gt;\n&lt;/assembly&gt;\n then add the following plugin definition to pom.xml: &lt;plugin&gt;\n\t&lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;\n\t&lt;version&gt;3.7.1&lt;/version&gt;\n\t&lt;configuration&gt;\n\t\t&lt;outputDirectory&gt;${project.build.directory}&lt;/outputDirectory&gt;\n\t\t&lt;formats&gt;zip&lt;/formats&gt;\n\t\t&lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;\n\t\t&lt;finalName&gt;nsd-cli-${project.version}&lt;/finalName&gt;\n\t\t&lt;descriptors&gt;\n\t\t\t&lt;descriptor&gt;src/assembly/dist.xml&lt;/descriptor&gt;\n\t\t&lt;/descriptors&gt;\n\t&lt;/configuration&gt;\n        &lt;executions&gt;\n          &lt;execution&gt;\n            &lt;id&gt;create-archive&lt;/id&gt;\n            &lt;phase&gt;verify&lt;/phase&gt;\n            &lt;goals&gt;\n              &lt;goal&gt;single&lt;/goal&gt;\n            &lt;/goals&gt;\n          &lt;/execution&gt;\n        &lt;/executions&gt;\n&lt;/plugin&gt;\t\t        \t\t\t\n Change the final name to your CLI name. E.g. my-company-cli.",
    "timestamp": 1769516720203
  },
  "nsd-cli/nsd/sql/index.html": {
    "path": "CLI/nsd/sql",
    "link-uuid": "6118306a-04a2-4e51-a345-3ad26b1117b3",
    "title": "sql",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd sql [-hV] [--progress-console] [--progress-data] [--progress-json] [--password[=&lt;password&gt;]] [--driver-class=&lt;driverClass&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--user=&lt;user&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... [--driver-jar=&lt;driverJar&gt; [--driver-jar=&lt;driverJar&gt;]... | --driver-dependency=&lt;driverDependency&gt; [--driver-dependency=&lt;driverDependency&gt;]...] &lt;connectionURL&gt; [COMMAND] Connects to a SQL database &lt;connectionURL&gt; Connection URL --driver-class=&lt;driverClass&gt; Driver class. Required if the driver class is loaded from a Maven dependency or a jar file --driver-dependency=&lt;driverDependency&gt; Driver Maven dependencies in &lt;group id&gt;:&lt;artifact id&gt;[:&lt;classifier&gt;]:&lt;version&gt; format. For example, com.h2database:h2:2.4.240 --driver-jar=&lt;driverJar&gt; URLs of driver jar file(s) resolved relative to the current directory. -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --password[=&lt;password&gt;] Database user password The password can be provided directly as the value of this option, or entered interactively via a prompt if the option is specified without a value --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --user=&lt;user&gt; Database user -V, --version Print version information and exit. Commands: invoke - Invokes URI metadata - Loads database metadata into a model",
    "timestamp": 1769516720908
  },
  "nsd-cli/nsd/model/catalog-diagram/save/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/save",
    "link-uuid": "2ae642b8-ec0e-42e5-94d1-f36bba6bb058",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram save [-hV] [--[no-]compress] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;output&gt; Saves diagram to a file &lt;output&gt; Output file --[no-]compress Compress output -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit.",
    "timestamp": 1769516720838
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/html-app/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/html-app",
    "link-uuid": "0333c47b-b7cf-48c4-be64-915457734929",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720943
  },
  "html/jstree/index.html": {
    "path": "HTML/JsTree",
    "link-uuid": "c46b81c1-2294-4832-b0fc-ecbff169299a",
    "title": "JsTree",
    "content": "Sources Javadoc",
    "timestamp": 1769516720614
  },
  "core/telemetry/index.html": {
    "path": "Core/Telemetry",
    "link-uuid": "f1bfcaa9-af62-420f-a7e9-da8ce2236f79",
    "title": "Telemetry",
    "content": "This module provides an instance of OpenTelemetry as a capability. The instance is obtained from GlobalOpenTelemetry. The capability factory takes care of installing a logback appender to bridge OpenTelemetry with logging frameworks. If you are new to OpenTelemetry, check out Open Telemetry Quick Reference (Java) for general information. This page focuses on Nasdanika-specific functionality. Configuration By default auto-configuration is disabled. Set otel.java.global-autoconfigure.enabled to true to enable auto-configuration. Then use Environment variables and system properties to configure the global instance. This is an example of Java command line properties to configure telemetry repoting to a collector over OTLP protocol: -Dotel.java.global-autoconfigure.enabled=true -Dotel.metrics.exporter=otlp -Dotel.logs.exporter=otlp -Dotel.traces.exporter=otlp -Dotel.exporter.otlp.endpoint=http://&lt;VM external IP&gt;:4317 -Dotel.service.name=&lt;service name&gt;. Logging Below is a sample logback.xml file/resource: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;\n        &lt;file&gt;nsd.log&lt;/file&gt;\n        &lt;append&gt;true&lt;/append&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg %kvp{DOUBLE}%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;    \n    &lt;appender name=&quot;OpenTelemetry&quot;\n              class=&quot;io.opentelemetry.instrumentation.logback.appender.v1_0.OpenTelemetryAppender&quot;&gt;\n        &lt;captureExperimentalAttributes&gt;true&lt;/captureExperimentalAttributes&gt;\n        &lt;captureKeyValuePairAttributes&gt;true&lt;/captureKeyValuePairAttributes&gt;\n    &lt;/appender&gt;\n    &lt;root level=&quot;INFO&quot;&gt;\n        &lt;appender-ref ref=&quot;file&quot;/&gt;\n        &lt;appender-ref ref=&quot;OpenTelemetry&quot;/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n Obtain a capability From a non-capability code ProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nCapabilityLoader capabilityLoader = new CapabilityLoader();\ntry {\n    Requirement&lt;Object, OpenTelemetry&gt; requirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n    OpenTelemetry openTelemetry = capabilityLoader.loadOne(requirement, progressMonitor);\n    \n    ...\n    \n    } finally {\n        parentSpan.end();\n    }\n} finally {             \n    capabilityLoader.close(progressMonitor);\n}\n See Capability for more details. From another capability provider If an instance of OpenTelemetry is required by another capability provider, use CapabilityFactory.Loader instead of CapabilityLoader and chain capability completion stages with thenApply and thenCombine(). thenApply() If your capability depends just on the OpenTelemetry capability then use thenApply() as shown below: public class MyCapabilityFactory extends ServiceCapabilityFactory&lt;MyRequirement, MyCapability&gt; {\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        return MyCapability.class == type &amp;&amp; (requirement == null || requirement instanceof MyRequirement);\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;MyCapability&gt;&gt;&gt; createService(\n            Class&lt;MyCapability&gt; serviceType, \n            MyRequirement requirement, \n            Loader loader,\n            ProgressMonitor progressMonitor) {\n        \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);      \n        return wrapCompletionStage(openTelemetryCS.thenApply(openTelemetry -&gt; createMyCapability(openTelemetry, requirement)));\n    }\n    \n    protected MyCapability createMyCapability(OpenTelemetry openTelemetry, MyRequirement requirement) {\n        return new MyCapabilityImpl(openTelemetry, requirement);\n    }\n\n}\n thenCombine() If your capability depends on the OpenTelemetry capability and other capabilities, then use thenCombine() as shown below: public class MyCapabilityFactory extends ServiceCapabilityFactory&lt;Void, MyCapability&gt; {\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        return MyCapability.class == type &amp;&amp; requirement == null;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;MyCapability&gt;&gt;&gt; createService(\n            Class&lt;MyCapability&gt; serviceType,\n            Void serviceRequirement, \n            Loader loader, \n            ProgressMonitor progressMonitor) {\n        \n        \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);\n        \n        Requirement&lt;String, OpenAIClientBuilder&gt; openAIClientBuilderRequirement = ServiceCapabilityFactory.createRequirement(\n                OpenAIClientBuilder.class,\n                null,\n                &quot;https://api.openai.com/v1/&quot;);\n        \n        CompletionStage&lt;OpenAIClientBuilder&gt; openAIClientBuilderCS = loader.loadOne(openAIClientBuilderRequirement, progressMonitor);\n        \n        return wrapCompletionStage(openAIClientBuilderCS.thenCombine(openTelemetryCS, this::createEmbeddings));\n    }\n        \n    protected MyCapability createMyCapability(OpenAIClientBuilder openAIClientBuilder, OpenTelemetry openTelemetry) {\n        return new MyCapabilityImpl(openAIClientBuilder, openTelemetry);\n    }\n    \n}\n Observability presentation",
    "timestamp": 1769516720551
  },
  "nsd-cli/nsd/sql/metadata/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/crew-ai",
    "link-uuid": "bc713e8a-346e-4550-99ca-c6f00d5bb278",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;] ... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720955
  },
  "nsd-cli/nsd/drawio/to-model/html-app/index.html": {
    "path": "CLI/nsd/drawio/to-model/html-app",
    "link-uuid": "a5821c69-bc67-4605-82a7-32bb2dfb9e89",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd drawio to-model html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Cla ss&gt;]... [--extension-resource-factory=&lt;String=Class&gt; ]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;] ... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720754
  },
  "html/html/index.html": {
    "path": "HTML/HTML",
    "link-uuid": "fbae561d-dfd4-4031-873d-679eaee14a87",
    "title": "HTML",
    "content": "Sources Javadoc",
    "timestamp": 1769516720605
  },
  "core/core-echarts/index.html": {
    "path": "Core/ECharts",
    "link-uuid": "c22a9117-939a-4589-b24d-ec1fc33da8be",
    "title": "ECharts",
    "content": "Sources Javadoc This module provides functionality on top of ECharts-Java to simplify charts generation. SeriesChart&lt;E,X,Y,S&gt; - an interface for creating charts from collections of data with X and Y mapper functions, writing charts to a file and optionally opening them in a Web browser. AbstractSericesChart&lt;E,X,Y,S, C extends Chart&lt;?,?&gt;&gt; - an abstract class implementing the above interface and using ECharts Java Chart. Provides a built-in HTML page template with required scripts and stylesheets. Provides additional write() methods and generateChartJSON() for adding a chart to a custom web page. LineSeriesChart&lt;E,X,Y&gt; - a concrete subclass of the above abstract class which uses ECharts Java Line chart. Example LineSeriesChart&lt;Map.Entry&lt;String,Number&gt;, String, Number&gt; lineSeriesChart = new LineSeriesChart&lt;&gt;((a,b) -&gt; a.compareTo(b), Function.identity());        \n\nLineEmphasis emphasis = new LineEmphasis();\nemphasis.setFocus(&quot;series&quot;);\n\nLineSeriesBuilder&lt;Entry&lt;String, Number&gt;&gt; builder = lineSeriesChart.createSeries(&quot;Test&quot;, Map.Entry::getKey, Map.Entry::getValue);\nbuilder.addElement(Map.entry(&quot;Monday&quot;, 1));\nbuilder.addElement(Map.entry(&quot;Tuesday&quot;, 2));\nbuilder.addElement(Map.entry(&quot;Wednesday&quot;, 3));\nbuilder.addElement(Map.entry(&quot;Thursday&quot;, 8));\nbuilder.addElement(Map.entry(&quot;Friday&quot;, 11));\nbuilder.lineSeries().setEmphasis(emphasis);\n\nMarkArea2DDataItemDim startPoint = new MarkArea2DDataItemDim();\nstartPoint.setName(&quot;Area&quot;);\nstartPoint.setXAxis(&quot;Monday&quot;);\n\nMarkArea2DDataItem markAreaItem = new MarkArea2DDataItem();\nmarkAreaItem.setStartPoint(startPoint);\n\nMarkArea2DDataItemDim endPoint = new MarkArea2DDataItemDim();\nendPoint.setXAxis(&quot;Tuesday&quot;);\nmarkAreaItem.setEndPoint(endPoint);\n\nMarkArea markArea = new MarkArea();\nmarkArea.setData(new MarkAreaDataItemOption[] { markAreaItem });\n\nbuilder.lineSeries().setMarkArea(markArea);\n\nLineSeriesBuilder&lt;Entry&lt;String, Number&gt;&gt; builder2 = lineSeriesChart.createSeries(&quot;Test 2&quot;, Map.Entry::getKey, Map.Entry::getValue);\nbuilder2.addElement(Map.entry(&quot;Monday&quot;, 2));\nbuilder2.addElement(Map.entry(&quot;Tuesday&quot;, 3));\nbuilder2.addElement(Map.entry(&quot;Wednesday&quot;, 5));\nbuilder2.addElement(Map.entry(&quot;Thursday&quot;, 6));\nbuilder2.addElement(Map.entry(&quot;Friday&quot;, 7));\nbuilder2.lineSeries().setEmphasis(emphasis);\n\nlineSeriesChart.write(\n        new File(&quot;target/line.html&quot;), \n        &quot;Test&quot;, \n        true,\n        chart -&gt; {\n            Option option = chart.getOption();\n            DataZoom dataZoom = new DataZoom();\n            dataZoom.setType(&quot;inside&quot;);\n            option.setDataZoom(dataZoom);\n        },\n        null);\n Result",
    "timestamp": 1769516720209
  },
  "nsd-cli/nsd/java/index.html": {
    "path": "CLI/nsd/java",
    "link-uuid": "59b3b481-3a9f-4863-a952-ede9eead6248",
    "title": "java",
    "content": "Version: org.nasdanika.models.java.cli@2025.12.0 Usage: nsd java [-hV] [COMMAND] Commands related to Java -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: junit - Generates JUnit tests",
    "timestamp": 1769516720803
  },
  "ai/ai-http/index.html": {
    "path": "AI/HTTP",
    "link-uuid": "eff01f03-3ddc-46bc-b686-c7e5c7fc4957",
    "title": "HTTP",
    "content": "This module provides building blocks for HTTP-based AI solutions. Sources Maven Central Javadoc Chat The module provides a class for building Bootstrap/AlpineJS AI chat Web UIs - AbstractAIChatRoutes. The class extends AbstractTelemetryChatRoutes from the HTML/HTTP module and takes Chat as a constructor argument. Subclasses shall implement two abstract methods: * Mono&lt;List&lt;Chat.Message&gt;&gt; generateChatRequestMessages(String chatId, String question, JSONObject config, JSONObject context) * Mono&lt;String&gt; generateResponseContent(String chatId, String question, List&lt;? extends Chat.ResponseMessage&gt; responses, JSONObject config, JSONObject context) Below is a code snippet of a server with with gpt-5 chat: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new LoggerProgressMonitor(LOGGER);\nOpenTelemetry openTelemetry = capabilityLoader.loadOne(ServiceCapabilityFactory.createRequirement(OpenTelemetry.class), progressMonitor);\nTracer tracer = openTelemetry.getTracer(TestAI.class.getName() + &quot;.testChatServerWithTelemetry&quot;);\nTelemetryFilter telemetryFilter = new TelemetryFilter(\n        tracer, \n        openTelemetry.getPropagators().getTextMapPropagator(), \n        (k, v) -&gt; System.out.println(k + &quot;: &quot; + v), \n        true);\n\nChat.Requirement cReq = new Chat.Requirement(&quot;OpenAI&quot;, &quot;gpt-5&quot;, null);\nRequirement&lt;Chat.Requirement, Chat&gt; chatRequirement = ServiceCapabilityFactory.createRequirement(Chat.class, null, cReq);           \nChat chat = capabilityLoader.loadOne(chatRequirement, progressMonitor);\n        \nReflectiveHttpServerRouteBuilder builder = new ReflectiveHttpServerRouteBuilder();\nbuilder.addTargets(&quot;/test-chat/&quot;, new AbstractAIChatRoutes(telemetryFilter, chat) {\n    \n    @Override\n    protected Object getConfigurator() {\n        Input text = getBootstrapFactory().getHTMLFactory().input(InputType.text);\n        AlpineJs&lt;Input&gt; aText = getAlpineJsFactory().from(text);\n        aText.model(&quot;config.test&quot;);\n        return text;\n    }\n    \n    @Override\n    protected JSONObject getConfig() {\n        JSONObject jsonConfig = super.getConfig();\n        jsonConfig.put(&quot;chat-provider&quot;, chat.getProvider());\n        jsonConfig.put(&quot;chat-model&quot;, chat.getName());\n        return jsonConfig;\n    }\n\n    @Override\n    protected Mono&lt;List&lt;org.nasdanika.ai.Chat.Message&gt;&gt; generateChatRequestMessages(\n            String chatId,\n            String question,\n            JSONObject config,\n            JSONObject context) {\n        return Mono.just(List.of(\n            Chat.Role.system.createMessage(&quot;You are a helpful assistant. You you will be provided a user question. Answer in Markdown format with references to resources you used.&quot;),\n            Chat.Role.user.createMessage(question))\n        );\n    }\n\n    @Override\n    protected Mono&lt;String&gt; generateResponseContent(\n            String chatId, \n            String question,\n            List&lt;? extends ResponseMessage&gt; responses, \n            JSONObject config,\n            JSONObject context) {\n        String responseContent = responses.get(0).getContent();\n        return Mono.just(MarkdownHelper.INSTANCE.markdownToHtml(responseContent));\n    }\n    \n});\n\nDisposableServer server = HttpServer\n  .create()\n  .route(builder::buildRoutes)\n  .bindNow();       \n\nURI resolvedUri = new URI(&quot;http://localhost:&quot; + server.port() + &quot;/&quot;).resolve(&quot;/test-chat/chat&quot;);            \nDesktop.getDesktop().browse(resolvedUri);\n\ntry (Terminal terminal = TerminalBuilder.builder().system(true).build()) {\n    LineReader lineReader = LineReaderBuilder\n            .builder()\n            .terminal(terminal)\n            .build();\n    \n    String prompt = &quot;http-server&gt;&quot;;\n    while (true) {\n        String line = null;\n        line = lineReader.readLine(prompt);\n        System.out.println(&quot;Got: &quot; + line);\n        if (&quot;exit&quot;.equals(line)) {\n            break;\n        }\n    }\n}\nserver.dispose();\nserver.onDispose().block();     \n Response screenshot Telemetry screenshot The above example is hardcoded for GPT-5. It can be modified to collect all available chat models to allow user to select a model to use in the configuration dialog. It can also be modified to provide contextual information in generateChatRequestMessages. Such information can include data from the context object sent as part of the chat request. This approach allows to generate multiple static chat pages with &ldquo;baked-in&rdquo; context and use a shared chat route. One application would be chat pages for generated documentation from models and other sources with a chat page per model element, say, Internet Banking System. Context may include a &ldquo;narration&rdquo; of the model element and related model elements.r",
    "timestamp": 1769516720034
  },
  "nsd-cli/nsd/drawio/to-model/html-app/save/index.html": {
    "path": "CLI/nsd/drawio/to-model/html-app/save",
    "link-uuid": "ad783d5d-76dd-4622-9c0f-8063ab3a65f1",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio to-model html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720756
  },
  "nsd-cli/nsd/help/site/index.html": {
    "path": "CLI/nsd/help/site",
    "link-uuid": "0c67225d-ed9f-48bb-841d-aed1265a3d50",
    "title": "site",
    "content": "Usage: nsd help site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [--root-action-icon=&lt;rootActionIcon&gt;] [--root-action-location=&lt;rootActionLocation&gt;] [--root-action-text=&lt;rootActionText&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--command-path=&lt;commandPath&gt;[, &lt;commandPath&gt;...]]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates help HTML site &lt;output&gt; Output directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --command-path=&lt;commandPath&gt;[,&lt;commandPath&gt;...] Comma-separated list of command names help is generated for the last command in the path -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 --root-action-icon=&lt;rootActionIcon&gt; Root action icon --root-action-location=&lt;rootActionLocation&gt; Root action location --root-action-text=&lt;rootActionText&gt; Root action text -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example help site --page-template=&quot;page-template.yml#/&quot; --root-action-icon=https://docs.nasdanika.org/images/nasdanika-logo.png --root-action-location=https://github.com/Nasdanika-Demos --root-action-text=&quot;Nasdanika Demos&quot; target/doc-site\n Options --command-path Use this option if you want to generate help not for the root command, but for a sub-command. --command-path Use this option if you want to generate help not for the root command, but for a sub-command. Use this option if you want to generate help not for the root command, but for a sub-command.",
    "timestamp": 1769516720793
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/html-app/save/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/html-app/save",
    "link-uuid": "e9fab0d8-b41a-4cb4-be67-2ae25f1fd8d6",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720921
  },
  "nsd-cli/nsd/drawio/http-server/index.html": {
    "path": "CLI/nsd/drawio/http-server",
    "link-uuid": "6b7b96fa-10a0-42bd-863a-41c414ab87cd",
    "title": "http-server",
    "content": "Version: org.nasdanika.http@2025.12.0 Usage: nsd drawio http-server [-hV] [--[no-]console] [--progress-console] [--progress-data] [--progress-json] [--connection-base=&lt;connectionBase&gt;] [--http-host=&lt;httpHost&gt;] [--http-port=&lt;httpPort&gt;] [--http-server-shutdown-timeout=&lt;timeout&gt;] [--open=&lt;uriToOpen&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;processorProperty&gt; &lt;routeProperty&gt; Routes HTTP requests to a diagram element processor &lt;processorProperty&gt; Processor property &lt;routeProperty&gt; Route property --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET --[no-]console If true, starts a console and waits for the exit command, otherwise creates a shutdown hook disposing the server -h, --help Show this help message and exit. --http-host=&lt;httpHost&gt; HTTP host (network interface) to bind to --http-port=&lt;httpPort&gt; HTTP port. If a port is not specified, an ephemeral port is used --http-server-shutdown-timeout=&lt;timeout&gt; Timeout in seconds, defaults to 3 seconds --open=&lt;uriToOpen&gt; Opens provided URI in the system browser the URI is resolved relative to http://localhost:&lt;port&gt;/ --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio diagram.drawio http-server --http-port=8080 processor route Parent drawio command loads diagram.drawio file This command: Loads processor invocable URIs from the processor property Loads route definitions from the route property Serves diagram element routes on port 8080 Resources Serving HTTP &mdash; Diagrams &amp; Reflection story Routing HTTP Reactor Netty Reference Guide Parameters &lt;processorProperty&gt; &lt;routeProperty&gt; &lt;processorProperty&gt; &lt;routeProperty&gt;  ",
    "timestamp": 1769516720739
  },
  "nsd-cli/nsd/drawio/to-model/index.html": {
    "path": "CLI/nsd/drawio/to-model",
    "link-uuid": "05fb7d83-6ba2-4938-8024-600b17ebed69",
    "title": "to-model",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio to-model [-hV] [COMMAND] Converts diagram to diagram model -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720762
  },
  "nsd-cli/nsd/gitlab/index.html": {
    "path": "CLI/nsd/gitlab",
    "link-uuid": "c022aad4-c74f-48ef-85bd-460bee2c4db9",
    "title": "gitlab",
    "content": "Usage: nsd gitlab [-hV] [-l=&lt;clientRateLimit&gt;] [-t=&lt;accessToken&gt;] [-u=&lt;url&gt;] [-w=&lt;clientRateLimitWindow&gt;] [COMMAND] Commands for working with GitLab -h, --help Show this help message and exit. -l, --client-rate-limit=&lt;clientRateLimit&gt; Client enforced rate limit use this option if the server limits requests rate, but does not rate limit headers to the client only errors if the rate limit is exceeded -t, --access-token=&lt;accessToken&gt; GitLab access token, defaults to the value of GITLAB_ACCESS_TOKEN environment variable -u, --url=&lt;url&gt; GitLab URL, defaults to the value of GITLAB_URL environment variable -V, --version Print version information and exit. -w, --client-rate-limit-window=&lt;clientRateLimitWindow&gt; Client enforced rate limit window in seconds defaults to 10 ignored if the client rate limit is not set Commands: contribute - Parent for sub-command contributing via GitLabURIHandler invoke - Invokes URI",
    "timestamp": 1769516720783
  },
  "nsd-cli/nsd/sql/metadata/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/html-app/crew-ai",
    "link-uuid": "76da1ecd-f0d4-46b1-9bfd-9a798b6690d8",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720977
  },
  "core/http/index.html": {
    "path": "Core/HTTP",
    "link-uuid": "dc84e03c-8739-44dd-ac3c-b4c17cc8b896",
    "title": "HTTP",
    "content": "Nasdanika Core HTTP module provides classes and interfaces for serving HTTP requests with Reactor Netty HTTP Server routes. Sources Javadoc Reflective routing Factories Serving Java http-server CLI command Capability factory module-info.java Telemetry Graph/Diagram processors Processors Groovy Java Route (BiFunction) Route Builder (HttpServerRouteBuilder) Serving drawio http-server http-server Java SerpapiConnector Reflective routing ReflectiveHttpServerRouteBuilder uses Route and RouteBuilder annotations on methods, fields and types to build server routes. Example: package org.nasdanika.launcher.demo.http;\n\nimport org.nasdanika.http.ReflectiveHttpServerRouteBuilder.Route;\nimport org.reactivestreams.Publisher;\n\nimport reactor.core.publisher.Mono;\nimport reactor.netty.http.server.HttpServerRequest;\nimport reactor.netty.http.server.HttpServerResponse;\n\n@Route(&quot;/test/&quot;)\npublic class DemoReflectiveHttpRoutes {\n\n    /**\n     * In this handler method GET is derived from the get prefix\n     * and path is derived from Hello \n     */\n    @Route\n    public Publisher&lt;Void&gt; getHello(\n            HttpServerRequest request, \n            HttpServerResponse response) {\n        return response.sendString(Mono.just(&quot;getHello()&quot;));\n    }\n    \n    /**\n     * In this handler the HTTP method is GET because the \n     * first segment &quot;hola&quot; doesn't  match any HTTP method.\n     * The path is &quot;hola/soy/dora&quot;\n     */\n    @Route\n    public Publisher&lt;Void&gt; holaSoyDora(\n            HttpServerRequest request, \n            HttpServerResponse response) {\n        return response.sendString(Mono.just(&quot;holaSoyDora()&quot;));\n    }\n    \n    /**\n     * In this handler the path is explicitly specified\n     * by the Route annotation \n     */\n    @Route(&quot;do-something&quot;)\n    public Publisher&lt;Void&gt; doSomething(\n            HttpServerRequest request, \n            HttpServerResponse response) {\n        return response.sendString(Mono.just(&quot;do someting&quot;));\n    }\n    \n    @RouteBuilder(&quot;field-route-builder&quot;)\n    public HttpServerRouteBuilder routeBuilder = routes -&gt; {\n        routes.get(&quot;/hello&quot;, (request, response) -&gt; response.sendString(Mono.just(&quot;Hello from field route builder!&quot;)));             \n    };\n\n    @RouteBuilder(&quot;getter-route-builder&quot;)\n    public HttpServerRouteBuilder getRouteBuilder() {\n        return  routes -&gt; {\n            routes.get(&quot;/hello&quot;, (request, response) -&gt; response.sendString(Mono.just(&quot;Hello from getter route builder!&quot;)));\n        };\n    };  \n\n    @RouteBuilder(&quot;route-builder-method&quot;)\n    public void buildRoutes(HttpServerRoutes routes) {\n        routes.get(&quot;/hello&quot;, (request, response) -&gt; response.sendString(Mono.just(&quot;Hello from route builder method!&quot;)));\n    };  \n    \n    @Route\n    public JSONObject getApiSearch(\n            HttpServerRequest request, \n            HttpServerResponse response) {\n        JSONObject result = new JSONObject();\n        result.put(&quot;result&quot;, &quot;Hello World!&quot;);\n        return result;\n    }\n        \n    @Route(&quot;do-something-else&quot;)\n    public Mono&lt;String&gt; doSomethingElse(\n            HttpServerRequest request, \n            HttpServerResponse response) {\n        return Mono.just(&quot;do someting else&quot;);\n    }   \n    \n}\n The code snippet above shows three GET handler methods, a route builder field and two flavors of builder methods. All of their paths are prefixed with /test/ from the class level annotation. The getApiSearch() method returns JSONObject. The returned value is converted to String and is sent as a response with application/json content type header. Conversion works as explained below. For Mono and Flux Mono|Flux&lt;String&gt; is assumed by default and request.sendString() is used. The mono result is mapped to String using ReflectiveHttpServerRouteBuilder.toString(Object). Set binary attribute of @Route annotation to true for binary content so request.sendByteArray() is used. In this case mapping to byte[] is performed by ReflectiveHttpServerRouteBuilder.toByteArray(Object). Both ReflectiveHttpServerRouteBuilder.toString(Object) and ReflectiveHttpServerRouteBuilder.toByteArray(Object) use DefaultConverter.INSTANCE obtained from getConverter() method. These methods can be overridden to add support for additional conversions. E.g. URI to String or byte[] using ResourceSet URI Converter obtained as capability to, say, serve resources from Maven jars or GitLab using respective URIHandlers - see Maven/Gitlab models documentation for more details. Publisher which is not Mono or Flux is cast to Publisher&lt;Void&gt; and returned. String is not converted JSONObject is converted to string and also application/json content type header is added JSONArray is converted to string and also application/json content type header is added byte[] is not converted InputStream is converted to byte[] Other types are converted to a byte array, using ReflectiveHttpServerRouteBuilder.toByteArray(Object), if binary is true and to a string using ReflectiveHttpServerRouteBuilder.toString(Object) otherwise. The code snippet below shows how to use the above handlers. Note that the handler target is registered with /reflective prefix. As such, the full path for, say, getHello() method, is /reflective/test/hello. ReflectiveHttpServerRouteBuilder builder = new ReflectiveHttpServerRouteBuilder();\nbuilder.addTargets(&quot;/reflective&quot;, new DemoReflectiveHttpRoutes());\n\nDisposableServer server = HttpServer\n  .create()\n  .port(8080)\n  .route(builder::buildRoutes)\n  .bindNow();\n\ntry (Terminal terminal = TerminalBuilder.builder().system(true).build()) {\n LineReader lineReader = LineReaderBuilder\n   .builder()\n            .terminal(terminal)\n            .build();\n \n String prompt = &quot;http-server&gt;&quot;;\n    while (true) {\n        String line = null;\n        line = lineReader.readLine(prompt);\n        System.out.println(&quot;Got: &quot; + line);\n        if (&quot;exit&quot;.equals(line)) {\n         break;\n        }\n    }\n}\n\nserver.dispose();\nserver.onDispose().block();\n Factories Route building can be organized into hierarchy using methods and fields annotated with Reflector.Factory or Reflector.Factories annotations. Such methods can also be annotated with Route\u200a-\u200ain this case route value is used as a prefix. Below snippets show two levels of factory hierarchy: import org.nasdanika.common.Reflector;\nimport org.nasdanika.http.ReflectiveHttpServerRouteBuilder.Route;\n\n/**\n * Demo of a hierarchical routing with factory\n */\n@Route(&quot;/super-factory&quot;)\npublic class ReflectorSuperFactory {\n    \n    @Route(&quot;/super-demo&quot;)\n    @Reflector.Factory\n    public ReflectorFactory getRoutes() {\n        return new ReflectorFactory();\n    }   \n\n}\n import org.nasdanika.common.Reflector;\nimport org.nasdanika.http.ReflectiveHttpServerRouteBuilder.Route;\n\n/**\n * Demo of a hierarchical routing with factory\n */\n@Route(&quot;/factory&quot;)\npublic class ReflectorFactory {\n    \n    @Route(&quot;/demo&quot;)\n    @Reflector.Factory\n    public DemoReflectiveHttpRoutes getRoutes() {\n        return new DemoReflectiveHttpRoutes();\n    }   \n\n}\n With factories you can assemble web applications from parameterizable building blocks. Serving Java ReflectiveHttpServerRouteBuilder builder = new ReflectiveHttpServerRouteBuilder();\nbuilder.addTargets(&quot;/reflective&quot;, new DemoReflectiveHttpRoutes());\n\nDisposableServer server = HttpServer\n  .create()\n  .port(8080)\n  .route(builder::buildRoutes)\n  .bindNow();\n\ntry (Terminal terminal = TerminalBuilder.builder().system(true).build()) {\n LineReader lineReader = LineReaderBuilder\n   .builder()\n            .terminal(terminal)\n            .build();\n \n String prompt = &quot;http-server&gt;&quot;;\n    while (true) {\n        String line = null;\n        line = lineReader.readLine(prompt);\n        System.out.println(&quot;Got: &quot; + line);\n        if (&quot;exit&quot;.equals(line)) {\n         break;\n        }\n    }\n}\n\nserver.dispose();\nserver.onDispose().block();\n http-server CLI command You can build a custom CLI and serve routes with http-server command by creating a capability factory and registering it in module-info.java. Capability factory public class DemoReflectiveHttpRoutesFactory extends ServiceCapabilityFactory&lt;Void, HttpServerRouteBuilder&gt; {\n  \n @Override\n public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n  return HttpServerRouteBuilder.class == type &amp;&amp; requirement == null;\n }\n\n @Override\n protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;HttpServerRouteBuilder&gt;&gt;&gt; createService(\n   Class&lt;HttpServerRouteBuilder&gt; serviceType, \n   Void serviceRequirement, \n   Loader loader,\n   ProgressMonitor progressMonitor) {\n  \n  ReflectiveHttpServerRouteBuilder builder = new ReflectiveHttpServerRouteBuilder();\n  builder.addTargets(&quot;/reflective&quot;, new DemoReflectiveHttpRoutes());    \n  return wrap(builder);\n }\n \n}\n module-info.java ...\nprovides CapabilityFactory with DemoDiagramRoutesBuilderFactory;    \n...\n\n Telemetry You may pass TelemetryFilter to ReflectiveHttpServerRouteBuilder. In this case route methods which return String, JSONArray, JSONObject, byte[] or InputStream will be filtered to collect telemetry and propagate telemetry context along the reactive chain. Graph/Diagram processors HttpServerRouteBuilder has a static buildRoutes(Collection&lt;ProcessorInfo&lt;P&gt;&gt; processorInfos, String routeProperty, HttpServerRoutes routes) method for building routes from graph/diagram processors implementing BiFunction&lt;HttpServerRequest, HttpServerResponse, Publisher&lt;Void&gt;&gt; or implementing/adaptable to HttpServerRouteBuilder. You can find examples in Nasdanika Demo CLI. Processors Groovy Below is a Groovy processor for single route:  1  import reactor.core.publisher.Mono \n 2  import org.nasdanika.drawio.Node\n 3  import org.nasdanika.graph.processor.ProcessorElement\n 4  \n 5  new java.util.function.BiFunction() {\n 6  \n 7      @ProcessorElement\n 8      public Node element;\n 9      \n10      def apply(request, response) {\n11          response.sendString(Mono.just(element.getLabel()))\n12      }\n13  \n14  }\n The diagram element is injected into the element field at line 8 because the fields is annotated with @ProcessorElement annotation (line 7). apply() method at line 10 processes HTTP requests by sending the element label. Java Route (BiFunction) Below is a Java processor serving a single route:  1  package org.nasdanika.launcher.demo.drawio;\n 2  \n 3  import java.util.concurrent.CompletionStage;\n 4  import java.util.function.BiConsumer;\n 5  import java.util.function.BiFunction;\n 6  import java.util.function.Consumer;\n 7  \n 8  import org.nasdanika.capability.CapabilityFactory.Loader;\n 9  import org.nasdanika.common.Invocable;\n10  import org.nasdanika.common.ProgressMonitor;\n11  import org.nasdanika.drawio.Node;\n12  import org.nasdanika.graph.Element;\n13  import org.nasdanika.graph.processor.ConnectionProcessorConfig;\n14  import org.nasdanika.graph.processor.NodeProcessorConfig;\n15  import org.nasdanika.graph.processor.ProcessorConfig;\n16  import org.nasdanika.graph.processor.ProcessorElement;\n17  import org.nasdanika.graph.processor.ProcessorInfo;\n18  import org.reactivestreams.Publisher;\n19  \n20  import reactor.core.publisher.Mono;\n21  import reactor.netty.http.server.HttpServerRequest;\n22  import reactor.netty.http.server.HttpServerResponse;\n23  \n24  /**\n25   * Diagram element processor which processes HTTP requests \n26   */\n27  public class SystemHttpHandler implements BiFunction&lt;HttpServerRequest, HttpServerResponse, Publisher&lt;Void&gt;&gt; {\n28      \n29      private String amount;\n30      \n31      @ProcessorElement\n32      public void setElement(Node element) {\n33          this.amount = element.getProperty(&quot;amount&quot;);\n34      }\n35  \n36      /**\n37       * This is the constructor signature for graph processor classes which are to be instantiated by URIInvocableCapabilityFactory (org.nasdanika.capability.factories.URIInvocableCapabilityFactory).\n38       * Config may be of specific types {@link ProcessorConfig} - {@link NodeProcessorConfig} or {@link ConnectionProcessorConfig}.  \n39       * @param loader\n40       * @param loaderProgressMonitor\n41       * @param data\n42       * @param fragment\n43       * @param config\n44       * @param infoProvider\n45       * @param endpointWiringStageConsumer\n46       * @param wiringProgressMonitor\n47       */\n48      public SystemHttpHandler(\n49              Loader loader,\n50              ProgressMonitor loaderProgressMonitor,\n51              Object data,\n52              String fragment,\n53              ProcessorConfig config,\n54              BiConsumer&lt;Element, BiConsumer&lt;ProcessorInfo&lt;Invocable&gt;, ProgressMonitor&gt;&gt; infoProvider,\n55              Consumer&lt;CompletionStage&lt;?&gt;&gt; endpointWiringStageConsumer,\n56              ProgressMonitor wiringProgressMonitor) {\n57          \n58          System.out.println(&quot;I got constructed &quot; + this);\n59      }\n60  \n61      @Override\n62      public Publisher&lt;Void&gt; apply(HttpServerRequest request, HttpServerResponse response) {\n63          return response.sendString(Mono.just(&quot;Account: &quot; + request.param(&quot;account&quot;) + &quot;, Amount: &quot; + amount));\n64      }\n65  \n66  }\n apply() method at line 62 processes HTTP GET requests. Route Builder (HttpServerRouteBuilder) The below processor implements HttpServerRouteBuilder: package org.nasdanika.launcher.demo.drawio;\n\nimport java.util.concurrent.CompletionStage;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\nimport org.nasdanika.capability.CapabilityFactory.Loader;\nimport org.nasdanika.common.Invocable;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.drawio.Node;\nimport org.nasdanika.graph.Element;\nimport org.nasdanika.graph.processor.ConnectionProcessorConfig;\nimport org.nasdanika.graph.processor.NodeProcessorConfig;\nimport org.nasdanika.graph.processor.ProcessorConfig;\nimport org.nasdanika.graph.processor.ProcessorElement;\nimport org.nasdanika.graph.processor.ProcessorInfo;\nimport org.nasdanika.http.HttpServerRouteBuilder;\n\nimport reactor.core.publisher.Mono;\nimport reactor.netty.http.server.HttpServerRoutes;\n\n/**\n * Diagram element processor which builds HTTP routes \n */\npublic class RouteBuilderProcessor implements HttpServerRouteBuilder {\n    \n    private String amount;\n    \n    @ProcessorElement\n    public void setElement(Node element) {\n        this.amount = element.getProperty(&quot;amount&quot;);\n    }\n\n    /**\n     * This is the constructor signature for graph processor classes which are to be instantiated by URIInvocableCapabilityFactory (org.nasdanika.capability.factories.URIInvocableCapabilityFactory).\n     * Config may be of specific types {@link ProcessorConfig} - {@link NodeProcessorConfig} or {@link ConnectionProcessorConfig}.  \n     * @param loader\n     * @param loaderProgressMonitor\n     * @param data\n     * @param fragment\n     * @param config\n     * @param infoProvider\n     * @param endpointWiringStageConsumer\n     * @param wiringProgressMonitor\n     */\n    public RouteBuilderProcessor(\n            Loader loader,\n            ProgressMonitor loaderProgressMonitor,\n            Object data,\n            String fragment,\n            ProcessorConfig config,\n            BiConsumer&lt;Element, BiConsumer&lt;ProcessorInfo&lt;Invocable&gt;, ProgressMonitor&gt;&gt; infoProvider,\n            Consumer&lt;CompletionStage&lt;?&gt;&gt; endpointWiringStageConsumer,\n            ProgressMonitor wiringProgressMonitor) {\n        \n        System.out.println(&quot;I got constructed &quot; + this);\n    }\n\n    @Override\n    public void buildRoutes(HttpServerRoutes routes) {\n        routes.get(&quot;/balance&quot;, (request, response) -&gt; response.sendString(Mono.just(&quot;Account: &quot; + request.param(&quot;account&quot;) + &quot;, Amount: &quot; + amount)));      \n    }\n\n}\n Serving drawio http-server One way to have diagrams to process HTTP requests is to use drawio http-server command pipeline. Below is a sample command line: drawio test-data/drawio-http/diagram.drawio http-server --http-port=8080 processor route\n http-server Another option is to use the http-server command in a custom CLI assembly. In this case diagrams shall be provided as HttpServerRouteBuilder capabilities. This is done by creating a subclass of DiagramRoutesBuilderFactory: package org.nasdanika.launcher.demo.drawio;\n\nimport org.eclipse.emf.common.util.URI;\nimport org.nasdanika.common.Util;\nimport org.nasdanika.http.DiagramRoutesBuilderFactory;\n\npublic class DemoDiagramRoutesBuilderFactory extends DiagramRoutesBuilderFactory {\n\n public DemoDiagramRoutesBuilderFactory() {\n  super(\n    URI\n     .createURI(&quot;system.drawio&quot;)\n     .resolve(Util.createClassURI(DemoDiagramRoutesBuilderFactory.class)), \n    &quot;processor&quot;, \n    &quot;route&quot;);\n }\n \n}\n and adding it to module-info.java provides. Java The below snippet shows how to serve diagram processors routes with Java: Document document = Document.load(\n        URI.createFileURI(new File(&quot;test-data/drawio-http/diagram.drawio&quot;).getCanonicalPath()), \n        null, \n        null);\n\nElementProcessorFactory&lt;Object&gt; elementProcessorFactory = new ElementProcessorFactory&lt;Object&gt;(\n        document, \n        new CapabilityLoader(), \n        &quot;processor&quot;);\n    \nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\nMap&lt;Element, ProcessorInfo&lt;Object&gt;&gt; processors = elementProcessorFactory.createProcessors(\n        null, \n        null, \n        progressMonitor);\n\nDisposableServer server = HttpServer\n        .create()\n        .port(8080)\n        .route(routes -&gt; HttpServerRouteBuilder.buildRoutes(processors.values(), &quot;route&quot;, routes))\n        .bindNow();\n\ntry (Terminal terminal = TerminalBuilder.builder().system(true).build()) {\n    LineReader lineReader = LineReaderBuilder\n            .builder()\n            .terminal(terminal)\n            .build();\n    \n    String prompt = &quot;http-server&gt;&quot;;\n    while (true) {\n        String line = null;\n        line = lineReader.readLine(prompt);\n        System.out.println(&quot;Got: &quot; + line);\n        if (&quot;exit&quot;.equals(line)) {\n            break;\n        }\n    }\n}\n\nserver.dispose();\nserver.onDispose().block();\n SerpapiConnector SerpapiConnector class uses SerpApi Google search to find pages. Then it retrieves them, extracts main content (content of the main element, configurable) and the converts the main content to Markdown. Search result includes SerpApi data, page content, main content and markdown main content. The primary purpose of this class it to provide grounding for LLMs and AI agents with information that matters (main content) and in a format which is semantically structured. Example: String apiKey = System.getenv(&quot;SERPER_KEY&quot;);\nString query = &quot;What is a kernel function in microsoft semantic kernel&quot;;\n\nSerpapiConnector serpApiConnector = new SerpapiConnector(apiKey, &quot;learn.microsoft.com/en-us/semantic-kernel&quot;);\nFlux&lt;SearchResult&gt; results = serpApiConnector.search(query, 10, 0);\nList&lt;SearchResult&gt; resultList = results.collectList().block();\nfor (SearchResult result: resultList) {\n    System.out.println(&quot;===&quot;);\n    System.out.println(result.title());\n    System.out.println();\n    System.out.println(result.markdownMainContent());\n}",
    "timestamp": 1769516720306
  },
  "nsd-cli/nsd/sql/metadata/index.html": {
    "path": "CLI/nsd/sql/metadata",
    "link-uuid": "9271d19c-3507-47ec-ac34-79608903c18c",
    "title": "metadata",
    "content": "Version: org.nasdanika.models.sql.cli@2025.12.0 Usage: nsd sql metadata [-hV] [--schema=&lt;schemaPattern&gt;] [--table=&lt;tableNamePattern&gt;] [--catalog=&lt;catalogs&gt;]... [--table-types=&lt;tableTypes&gt;]... [COMMAND] Loads database metadata into a model --catalog=&lt;catalogs&gt; Catalogs to include all catalogsif not provided. -h, --help Show this help message and exit. --schema=&lt;schemaPattern&gt; Schema pattern all schemas if not provided. --table=&lt;tableNamePattern&gt; Table name pattern all tables if not provided. --table-types=&lt;tableTypes&gt; Table names to include all table types if not provided. -V, --version Print version information and exit. Commands: catalog-diagram - Generates a diagram from a Catalog model crew-ai - Generates CrewAI code and configuration from a model ecore - Generates a Ecore model from a database model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720988
  },
  "core/maven/index.html": {
    "path": "Core/Maven",
    "link-uuid": "a34cd86e-5459-4918-9dff-ed587ceed59c",
    "title": "Maven",
    "content": "Nasdanika Maven module uses Maven Resolver Supplier to provide capabilities for Dependency and ClassLoader requirements. Sources Javadoc Dependency CapabilityLoader capabilityLoader = new CapabilityLoader();\nDependencyRequestRecord requirement = new DependencyRequestRecord(\n\t\tnew String[] { &quot;org.apache.groovy:groovy-all:pom:4.0.23&quot; }, \n\t\tnull, \n\t\tnull, \n\t\t&quot;target/test-repo&quot;);\n\t\t\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nCollection&lt;File&gt; result = capabilityLoader.loadOne(requirement, progressMonitor);\n The above code snippet loads org.apache.groovy:groovy-all:pom:4.0.23 and its dependencies into target/test-repo directory and returns a list of jar files. ClassLoader CapabilityLoader capabilityLoader = new CapabilityLoader();\nClassLoaderRequirement requirement = new ClassLoaderRequirement(\n\t\tnull, // String[] modulePath,\n\t\tnull, // String[] rootModules,\n\t\tnew ModuleLayer[] { getClass().getModule().getLayer() }, \n\t\tgetClass().getClassLoader(), // ClassLoader parentClassLoader,\n\t\ttrue, // boolean singleLayerClassLoader,\t\t\t\t\n\t\tnew String[] { &quot;org.apache.groovy:groovy-all:pom:4.0.23&quot; }, \n\t\tnull, \n\t\tnull, \n\t\t&quot;target/test-repo&quot;,\n\t\tSystem.out::println);\n\t\t\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nClassLoader result = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(ClassLoader.class, null, requirement),\n\t\tprogressMonitor);\n\t\t\nClass&lt;?&gt; scriptEngineFactoryClass = result.loadClass(&quot;org.codehaus.groovy.jsr223.GroovyScriptEngineFactory&quot;);\n The above code snippet: Loads org.apache.groovy:groovy-all:pom:4.0.23 and its dependencies into target/test-repo directory Creates a ClassLoader Loads org.codehaus.groovy.jsr223.GroovyScriptEngineFactory class Default configuration DependencyCapabilityFactory, which is responsible for resolving and downloading dependencies, loads default configuration in the following way: If org.nasdanika.maven.DependencyCapabilityFactory.config.yml system property is set, then it is treated as a URL of a configuration YAML resource. The URL is resolved relative to the current directory. If org.nasdanika.maven.DependencyCapabilityFactory.config.json system property is set, then it is treated as a URL of a configuration JSON resource. The URL is resolved relative to the current directory. If NSD_DEPENDENCY_RESOLVER_CONFIG_YAML_URL environment variable is set, then it is treated as an absolute URL of a configuration YAML resource. If NSD_DEPENDENCY_RESOLVER_CONFIG_JSON_URL environment variable is set, then it is treated as an absolute URL of a configuration JSON resource. If NSD_DEPENDENCY_RESOLVER_CONFIG_YAML environment variable is set, then it is treated as YAML configuration. If NSD_DEPENDENCY_RESOLVER_CONFIG_JSON environment variable is set, then it is treated as JSON configuration. If dependency-reolver-config.yml file exists in the current directory the it is loaded as YAML. If dependency-reolver-config.json file exists in the current directory the it is loaded as JSON. The loaded configuration is interpolated with system properties and environment variables. E.g. ${my-property} will be expanded to the value of my-property system property if it is set. Respectively, ${env.MY_ENV_VAR} will be expanded to the value of MY_ENV_VAR environment variable if it is set. Property expansion can be escaped with additional {} e.g. ${my-property} will be expanded to ${my-property} regardless of whether my-properety system property is set or not. Configuration specification modulePath - optional String or List, module path. If null, derived from root modules if they are present rootModules - optional String or List, root modules. The first root module is used to obtain the class loader oneLayerClassLoader - optional boolean indicating whether a single class loader shall be used for all modules in in the layer dependencies - optional String or List of dependencies in &lt;groupId&gt;:&lt;artifactId&gt;[:&lt;extension&gt;[:&lt;classifier&gt;]]:&lt;version&gt;} format. E.g. org.apache.groovy:groovy-all:pom:4.0.23 managedDependencies - optional String or List of dependencies in &lt;groupId&gt;:&lt;artifactId&gt;[:&lt;extension&gt;[:&lt;classifier&gt;]]:&lt;version&gt;} format remoteRepositories - Map (single remote repository) or List of Maps of remote repository definitions loaded into RemoteRepoRecord: id - String, repo ID type - String, optional repo type url - String, repository URL proxy - optional Map: type - String, http or https host - String port - integer auth - authentication (see below) auth - Map: username - String password - String mirroredRepositories - Map or List, mirrored repositories localRepository - optional String, path to the local repository to download dependencies to. Defaults to repository. URI Handler Maven URIHandler handles URIs of the following format: maven://&lt;groupId&gt;/&lt;artifactId&gt;/&lt;extension&gt;/&lt;version&gt;/&lt;resource path&gt;[?classifier=&lt;classifier&gt;]. For example, for maven://org.nasdanika.models.architecture/model/jar/2024.8.0/model/architecture.ecore?classifier=model URI model/architecture.ecore resource would be loaded from model-2024.8.0-model.jar in org.nasdanika.models.architecture group model artifact version 2024.8.0 as shown in the snippet below: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nRequirement&lt;ResourceSetRequirement, ResourceSet&gt; requirement = ServiceCapabilityFactory.createRequirement(ResourceSet.class);\t\t\nResourceSet resourceSet = capabilityLoader.loadOne(requirement, progressMonitor);\nURI modeURI = URI.createURI(&quot;maven://org.nasdanika.models.architecture/model/jar/2024.8.0/model/architecture.ecore?classifier=model&quot;);\nResource resource = resourceSet.getResource(modeURI, true);\nSystem.out.println(resource.getContents());",
    "timestamp": 1769516720540
  },
  "nsd-cli/nsd/model/catalog-diagram/http-server/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/http-server",
    "link-uuid": "89181b76-98a6-4220-973a-377eda3f345e",
    "title": "http-server",
    "content": "Version: org.nasdanika.http@2025.12.0 Usage: nsd model catalog-diagram http-server [-hV] [--[no-]console] [--progress-console] [--progress-data] [--progress-json] [--connection-base=&lt;connectionBase&gt;] [--http-host=&lt;httpHost&gt;] [--http-port=&lt;httpPort&gt;] [--http-server-shutdown-timeout=&lt;timeout&gt;] [--open=&lt;uriToOpen&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;processorProperty&gt; &lt;routeProperty&gt; Routes HTTP requests to a diagram element processor &lt;processorProperty&gt; Processor property &lt;routeProperty&gt; Route property --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET --[no-]console If true, starts a console and waits for the exit command, otherwise creates a shutdown hook disposing the server -h, --help Show this help message and exit. --http-host=&lt;httpHost&gt; HTTP host (network interface) to bind to --http-port=&lt;httpPort&gt; HTTP port. If a port is not specified, an ephemeral port is used --http-server-shutdown-timeout=&lt;timeout&gt; Timeout in seconds, defaults to 3 seconds --open=&lt;uriToOpen&gt; Opens provided URI in the system browser the URI is resolved relative to http://localhost:&lt;port&gt;/ --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio diagram.drawio http-server --http-port=8080 processor route Parent drawio command loads diagram.drawio file This command: Loads processor invocable URIs from the processor property Loads route definitions from the route property Serves diagram element routes on port 8080 Resources Serving HTTP &mdash; Diagrams &amp; Reflection story Routing HTTP Reactor Netty Reference Guide Parameters &lt;processorProperty&gt; &lt;routeProperty&gt; &lt;processorProperty&gt; &lt;routeProperty&gt;  ",
    "timestamp": 1769516720831
  },
  "html/bootstrap/index.html": {
    "path": "HTML/Bootstrap",
    "link-uuid": "4005ea86-5da0-4198-8bb1-ec2e30502fb6",
    "title": "Bootstrap",
    "content": "Sources Javadoc Java API for building Bootstrap Web UIs.",
    "timestamp": 1769516720602
  },
  "nsd-cli/nsd/model/catalog-diagram/html-app/site/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/html-app/site",
    "link-uuid": "d13a3357-c5ad-4406-aa28-5ad24173d126",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd model catalog-diagram html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720827
  },
  "nsd-cli/nsd/sql/metadata/ecore/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/html-app/crew-ai",
    "link-uuid": "ab542c8a-91f1-49c2-a7b7-6f923d9ce0d5",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata ecore html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720961
  },
  "index.html": {
    "link-uuid": "ee7c0031-d43e-4c10-a83e-a2335238f7ba",
    "title": "Nasdanika",
    "content": "Overview Common Resources Persistence Ncore Diagram Graph Drawio EMF Exec Maven Capability CLI HTTP Mapping Telemetry ECharts A collection of classes on top of ECharts Java to simplify chart creation Core JsTree Bootstrap HTML AlpineJS 3D Force Graph Graph HTTP HTML GitLab Architecture Git Excel ECharts Graph Nature Bank PDF Party Semantic Kernel Java Maven Enterprise Function Flow Rules Azure Ecore Jira Bootstrap App Capability Coverage Decision Analysis Family Flow HTML CrewAI Python A2a Graph SQL Compare Process Source Engineering Resume Eclipse Layout Kernel Models Analysis, Visualization &amp; Generation Java Analysis, Visualization &amp; Generation JUnit Tests Generation Practices Beyond Diagrams CrewAI Visual Synopsis OpenTelemetry Quick Reference (Java) Knowledge CLI YouTube Channel Medium Publication Template Repositories AWS Diagram (Drawio Site) Bob the Builder (Drawio site) Function Flow Concurrent Executable Diagrams Executable Diagram Dynamic Proxy General Purpose Executable Diagrams Internet Banking System (Drawio Site) Internet Banking System (C4 Model mapping) Maven Graph Semantic Mapping CLI Compute Graph Latest AI Development (CrewAI Model mapping) Latest AI Development - Swimlanes (CrewAI Model mapping) MCP Server Family Semanic Mapping Maven 3D Graph Wireframes Patagonia Trip Demos Core OpenAI Ollama MCP CLI EMF Drawio Math Smile HTTP Nasdanika Draw.AI AI Nasdanika",
    "timestamp": 1769516720706
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/html-app/site/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/html-app/site",
    "link-uuid": "eb561447-0a8c-45b1-b40c-a14a774a8407",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720949
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/save/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/save",
    "link-uuid": "0fc62e4c-0a25-48ab-b97c-0affd579c8ae",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720953
  },
  "nsd-cli/nsd/model/ecore/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/model/ecore/html-app/crew-ai",
    "link-uuid": "c4d34f8e-9676-4e16-8b79-a57b2aaecd3b",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model ecore html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String =Class&gt;]... [--extension-resource-factory=&lt;String=Cl ass&gt;]... [--protocol-resource-factory=&lt;String=Cla ss&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720869
  },
  "ai/ai-drawio/index.html": {
    "path": "AI/Drawio",
    "link-uuid": "d44acb51-5be2-46ad-a44c-29c1b9039344",
    "title": "Drawio",
    "content": "This module (work in progress) provides building blocks for AI solutions on top of Drawio documents. In particular, narration of documents for the purposes of semantic search and RAG. The narration process narrates images of diagram elements, tooltips, style, other properties and element connections and relative geometry. Sources Maven Central Javadoc",
    "timestamp": 1769516720007
  },
  "nsd-cli/nsd/model/crew-ai/index.html": {
    "path": "CLI/nsd/model/crew-ai",
    "link-uuid": "e946111d-c390-4dd4-862a-7ad56c1ab0fc",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720864
  },
  "core/common/index.html": {
    "path": "Core/Common",
    "link-uuid": "c6cd2276-560d-4220-9be1-5db600cb00b5",
    "title": "Common",
    "content": "Sources Javadoc",
    "timestamp": 1769516720206
  },
  "nsd-cli/nsd/sql/metadata/html-app/index.html": {
    "path": "CLI/nsd/sql/metadata/html-app",
    "link-uuid": "b4f3ebd4-2ad7-47f4-a0c5-bbcd87cbc68b",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd sql metadata html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Class&gt; ]... [--extension-resource-factory=&lt;String=Class&gt;].. . [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720981
  },
  "practices/junit/index.html": {
    "path": "Practices/JUnit Tests Generation",
    "link-uuid": "4d8d39cc-3bef-44c0-9c77-1031c69f6b33",
    "title": "JUnit Tests Generation",
    "content": "This practice is a specialization of the Java Analysis, Visualization &amp; Generation Practice for generation of JUnit tests. In particular: Generation of tests for methods or classes with low test coverage Leveraging Gen AI such as OpenAI ChatGPT or Azure OpenAI Service for test generation The above diagram shows Java development activities and artifacts. Black arrows show the typical process, blue arrows show the test generation loop. The developer produces source artifacts which may include non-java artifacts used to generate Java code (e.g. Ecore models), &ldquo;main&rdquo; Java sources and test Java sources. Java sources are compiled into bytecode (class files). Here it is important to note that matching of bytecode classes and methods to source code classes and methods might be non-trivial because of: Lambdas Anonymous and method-scope classes Annotation processors like Lombok JUnit tests are compiled and executed. If code coverage, such as jacoco, is configured then test execution produces coverage data. Jacoco stores coverage data in jacoco.exec file. This file is used to generate a coverage report and upload coverage information to systems like SonarQube. In this practice it is also used to select which methods to generate tests for based on coverage data. This diagram provides an insight into the test generation activity: Coverage data and bytecode are used as input to load the Coverage model. Source files, the coverage model, and bytecode (optional) are used to load the Java model of source code. The generator traverses the model and generates unit tests for method with low coverage using a combination of programmatic (traditional) generation and Gen AI. Tests are generated as a Java model as well and then are delivered to the developer for review, modification, and inclusion into the unit test suite. The following section provides an overview of two &ldquo;local loop&rdquo; reference implementations (a.k.a. designs/embodiments) - all-in-one and componentized. There are many possible designs leveraging different alternatives at multiple variation points. The sections after the reference implementations section provide an overview of variation points, alternatives, and factors to take into consideration during alternative selection. Command line Reference Implementations All-in-one Componentized Repository scan/crawl Variation points and alternatives Stakeholders &amp; Activities Developer Build machine Test generator GenAI Messages Channels Developer -&gt; Build Machine/Test Generation : Source code Build Machine -&gt; Test Generator : Coverage results, possibly with bytecode Test Generation -&gt; Developer : Generated tests Test Generation - GenAI : Prompt Command line Nasdanika CLI features JUnit command which generates JUnit tests as explained above. Reference Implementations This section explains reference implementations All-in-one All-in-one generations is implemented as a JUnit test is available in TestGenerator. An example of tests generated by this generator - PetControllerTests. As the name implies, all steps of source analysis and generation are implemented in a single class and are executed in one go. Componentized Componentized test generation which is also executed in one go is implemented in these classes: TestJavaAnalyzers - loads sources, coverage, and inspectors, passes the sources to the inspectors, aggregates and saves results. Coverage Inspector - generates tests for methods with low coverage leveraging TestGenerator capability provided by OpenAITestGenerator. Repository scan/crawl TestGitLab demonstrates how to scan a source repository (GitLab) using REST API, inspect code, generate unit tests, commit them to the server (also over the REST API) and create a merge request. This implementation does not use coverage information, its purpose is to demonstrate operation over the REST API without having to clone a repository, which might be an expensive operation. The implementation uses GitLab Model to communicate with the repository. It uses Java model to load sources and StringBuilder to build test cases. Variation points and alternatives As you have seen above, you can have an AI-powered JUnit test generator in about 230 lines of code, and maybe it would all you need. However, there are many variation points (design dimensions), alternatives at each point and, as such, possible permutations of thereof (designs). This section provides a high level overview of variation points and alternatives. How to assemble a solution from those alternative is specific to your context and there might be different solutions for different contexts and multiple solutions complementing each other. As you proceed with assembling a solution, or a portfolio of solutions, you may identify more variation points and alternatives. To manage the complexity you may use: Enterprise Model for general guidance, Capability framework or Capability model to create a catalog of variation points and alternatives and compute solutions (designs) from them Decision Analysis to select from the computed list of designs Flow to map your development process AS-IS and then augment it with test generation activities at different points. In this section we&rsquo;ll use the below diagram and the concept of an Enterprise with Stakeholders performing activities and exchanging Messages over Channels. The mission of our enterprise is to deliver quality Java code. The loss function to minimize is loss function = cost * risk / business value. For our purposes we&rsquo;ll define risk as inversely proportional to tests coverage risk = missed lines / total lines - that&rsquo;s all we can measure in this simple model. The cost includes resources costs - salary, usage fees for OpenAI. Below is a summary of our enterprise: Stakeholders &amp; Activities: Developer - writes code Build machine - compiles code and executes tests Test generator - generates unit tests GenAI - leveraged by the Test Generator Messages: Source code Bytecode Coverage results Prompt to generate a test Generated tests Channels Developer -&gt; Build Machine : Source code Developer -&gt; Test Generation : Source code Build Machine -&gt; Test Generator : Coverage results, possibly with bytecode Test Generation -&gt; Developer : Generated tests Test Generation - GenAI : Prompt The below sections outline variation points and alternatives for the list items above Stakeholders &amp; Activities Developer A developer writes code - both &ldquo;business&rdquo; and test. They use some kind of an editor, likely an IDE - Eclipse, IntelliJ, VS Code. Different IDE&rsquo;s come with different sets of plug-ins, including AI assistants. Forcing a developer to switch from their IDE of preference to another IDE is likely to cause considerable productivity drop, at least for some period of time, even if the new IDE is considered superior to the old IDE. So, if you want to switch to another IDE just because it has some plug-in which you like - think twice. Build machine A build machine compiles code and executes tests. Technically, compilation and test execution may be separated in two individual activities. We are not doing it for this analysis because it doesn&rsquo;t carry much relevance to test generation. You can do it for yours. Test generator Test generator generates tests by &ldquo;looking&rdquo; at the source code, bytecode, and code coverage results. Because the source code is a model element representing piece of code (method, constructor, &hellip;), the generator may traverse the model to &ldquo;understand&rdquo; the context. E.g. it may take a look at the method&rsquo;s class, other classes in the module. If the sources are loaded from a version control system, it may take a look at the commits. And if the source model is part of an organization model, it may look at &ldquo;sibling&rdquo; modules and other resources. By analyzing source and bytecode the generator would know methods a given method calls, objects it creates, and also it would know methods calling the method. It will also &ldquo;know&rdquo; branch conditions, e.g. switch cases. Using this information the generator may: Generate comments to help the developer Generate mocks, including constructor and static methods mocks Generate tests for different branches Build a variety of prompts for GenAI The test generator may do the following code generated by GenAI: Add to generated test methods commented out - as it is done in the reference implementations &ldquo;Massage&rdquo; - remove backticks, parse, add imports - generated and implied. In addition to code generation the generator may ask GenAI to explain code and generate recommendations - it will help the developer to understand the source method and possibly improve it along the way. It may also generate dependency graphs and sequence diagrams. GenAI There may GenAI models out there - cloud, self hosted. Which one to use heavily depends on the context. For example, if you have a large codebase with considerable amount of technical debt having an on-prem model may be a good choice because: You may fine-tune it. Even if you don&rsquo;t have tons of GPU power and your model is relatively slow you can crawl you code base, generate tests and deliver them to developers for review and inclusion into test suites. In this scenario your cost is on-prem infrastructure and power. Your savings are not having to pay for GenAI in the cloud and developer productivity if your fined tuned model turns out to be more efficient than a &ldquo;vanilla&rdquo; LLM. There are many other considerations, of course! Messages In this section we&rsquo;ll take a look just at bytecode and coverage results delivered to the test generator. The generator operates on models. As such, bytecode and coverage results can be delivered in a &ldquo;raw&rdquo; format to be loaded to a model by the generator, or pre-loaded to a model and saved to a file. The second option results in fewer files to pass to the test generator. The model file can be in XMI format or in compressed binary. The XMI format is human-readable, the binary format takes less space on disk. Channels Developer -&gt; Build Machine/Test Generation : Source code For local development the build machine is the same machine where developer creates sources. The test generator is also executed on the developer&rsquo;s workstation. As such, the delivery channels is the file system. In the case of CI/CD pipeline/build server such as Jenkins or GitHub Actions, a version control systems is the delivery channel. Build Machine -&gt; Test Generator : Coverage results, possibly with bytecode The test generator needs coverage results. If the coverage results are delivered in the raw form, it also needs bytecode (class files) to make sense of the results. Coverage results can be delivered to the test generator using the following channels: Filesystem Jenkins workspace made available to the test generator over HTTP(S) Binary repository. For example, coverage results might be published to the Maven repository as an assembly along with sources, jar file, and javadoc. They can be published in a raw format or as a model. In this modality the tests generator can get everything it needs from a Maven repository. You can use Maven model or Maven Artifact Resolver API to work with Maven repositories. See also Apache Maven Artifact Resolver. Additional value of storing coverage data in a binary repository is that it can serve as an evidence of code quality stored with the compiled code, not in some other system. Source repository. Traditionally storing derived artifacts in a source repository is frowned upon. However, storage is cheap, GitHub Pages use this approach - so, whatever floats your boat! SonarQube - it doesn&rsquo;t store method level coverage, so the solution would have to operate on the class level and generate test methods for all methods in a class with low coverage. You may have a specialized application/model repository/database and store coverage information there, possibly aligned to your organization structure. Test Generation -&gt; Developer : Generated tests The goal is to deliver generated tests to the developer, make the developer aware that they are available, and possibly track progress of incorporating the generated tests into the test suite. With this in mind, there are the following alternatives/options: Filesystem - for the local loop Source control system - commit, create a merge/pull request. When using this channels you can check if there is already a generated test and whether it needs to be re-generated. If, say, the source method hasn&rsquo;t changed (the same SHA digest), and the generator version and configuration hasn&rsquo;t changed - do not re-generate, it will only consume resources and create &ldquo;noise&rdquo; - the LLM may return a different response, developers will have to spend time understanding what has changed. You may fork a repository instead of creating a branch. This way all work on tests will be done in the forked repository and the source repository will receive pull requests with fully functional tests. Tests can be generated to a separate directory and then copied to the source directory, or they can be generated directly to the source directory. Tests may be generated with @Disabled annotation so they are clearly visible in the test execution tree, and with @Generated annotation to track changes and merge generated and hand-crafted code. Issue tracking system - either attach generated tests to issues, or create a merge request and reference it from the generated issues. In systems like Jira you may create a hierarchy of issues (epic/story), assign components, labels, fix versions, assignees, etc. You may assign different generated tests to different developers based on size and complexity of the source method. E.g. tests for short methods with low complexity can be assigned to junior developers. This alone may give your team a productivity boost! E-mail or other messaging system. Issue trackers and messaging systems may be used to deliver generated documentation while source control will deliver generated tests. Developers will use the generated documentation such as graphs, sequence diagrams and GenAI explanations/recommendations in conjunction with the generated test code. This channel may implement some sort of backpressure by saying &ldquo;it is enough for now&rdquo;, as a human developer would by crying &ldquo;Enough is enough, I have other stories to work on in this sprint!&rdquo;. Generating just enough tests is beneficial in the following ways: Does not overwhelm developers Does not result in a stale generated code waiting to be taken a look at Does not waste resources and time to generate code which nobody would look at in the near future Uses the latest (and hopefully the greatest) generator version With backpressure a question of prioritization/sorting arises - what to work on first? Source methods can be sorted according to: Size/complexity Dependency. E.g. method b (caller) calls method a (callee) One strategy might be to work on callee methods first (method a) to provide a solid foundation. Another is to work on caller methods first because callee methods might be tested along the way. These strategies might be combined - some developers (say junior) may work on callee tests and senior developers may be assigned to test (complex) caller (top level) methods. Also, the top-down approach (callers first) might be better for addressing technical debt accrued over time, while bottom-up (callees first) for new development. Test Generation - GenAI : Prompt GenAI is neither free nor blazing fast. As such, this channel may implement: Billing Rate limiting (throttling) Budgeting - so many calls per time period Caching Java Sources Source Artifacts Bytecode Coverage Data Developer JUnit Tests Gen AI Code Generation Compilation Test Execution JUnit Test Generation Coverage Report Retrieval Augmented Generation Java Sources Bytecode Coverage Data Developer Gen AI Coverage Model Source Code Model Tests Model Generator JUnit Test Generation Retrieval Augmented Generation Writing Code Compilation Testing Test Generation Gen AI Retrieval Augmented Generation",
    "timestamp": 1769516721046
  },
  "nsd-cli/index.html": {
    "link-uuid": "fb4b3660-9724-4bae-918c-3b96b67ccc8d",
    "title": "CLI",
    "content": "Nasdanika Command Line Interface (CLI) is a suite of Nasdanika capabilities packaged as command line tools. Sources Prerequisites To run Nasdanika CLI you&rsquo;d need Java 21+. To build from sources you&rsquo;d also need Maven. Installation Download installation archive from the releases page. On Linux make nsd executable: chmod a+x nsd. Building from sources Download sources as a zip file or clone the repository Run mvn clean verify After the build completes the distribuion will be available in target/dist directory Adding to PATH The distribution is portable and local - it can be put to any directory, but it can only be executed from that directory. To create an installation which can be used from any directory you will need to create launcher files with absolute paths. Windows nsd.bat launcher -f options-global -o nsd-global.bat -s -m org.nasdanika.launcher -c org.nasdanika.launcher.Launcher --add-modules ALL-SYSTEM -M modules -j &quot;@java&quot;\n If you are using telemetry, add telemetry options after @java Add the installation to the PATH environment variable. You may delete/rename nsd.bat and rename nsd-global.bat to nsd.bat. Linux ./nsd launcher -o nsd-global -s -m org.nasdanika.launcher -c org.nasdanika.launcher.Launcher -M modules\n Open nsd-global in a text editor and add #!/bin/bash line before the java command line. Make the file executable and add the installation directory to the path. You may remove/rename nsd and rename nsd-global to nsd. If you get java.lang.module.FindException: Module &lt;module name&gt; not found error, open the file in a text editor, locate the problematic module and remove it from the --add-modules list.",
    "timestamp": 1769516720712
  },
  "core/drawio/index.html": {
    "path": "Core/Drawio",
    "link-uuid": "13e2b305-582c-4421-a202-55576edcb50c",
    "title": "Drawio",
    "content": "Nasdankia provides two Maven modules for working with Drawio diagrams - API and Model. The modules require Java 17 or above. API Page and element links Magic properties $style $spel Generating documentation sites Overview video Executable diagrams Invocable URIs Java Ecore Model API Drawio module provides Java API for reading and manipulating Drawio diagrams. It is built on top of Graph. The module provides the following interfaces representing elements of a diagram file: Document - the root object of the API representing a file/resource which contains one or more pages. Page - a page containing a diagram (Model). Model - a diagram model containing the diagram root. Root - the root of the model containing layers. Layer - a diagram may have one or more layers. Layers contain Nodes and Connections. Node - a node can be connected to other nodes with connections. A node may contain other nodes and connections. ConnectionPoint - Points on a node (ports) where connections exit and enter. For more details about connection points see Connection Points, functionality and customization Connection - a connection between two connectables - nodes or connection points. The below diagram shows relationships between the above interfaces including their super-interfaces: Drawio Element, Node and Connection interfaces extend their Graph namesakes. Therefore, any diagram is a graph and, as such, can be made executable by creating graph processors. Need to do some non-trivial processing? Draw it, document it, then create processors. Util provides utility methods such as layout() and methods to navigate and query documents and their elements. Sources JavaDoc Maven Central Page and element links Nasdanika Drawio API extends the concept of linking to pages to cross-document linking to pages and page elements by name, ID, or SpEL expression. Link targets (pages or elements) are available via getLinkTarget() method. Drawio page links have the following format: data:page/id,&lt;page id&gt; with page/id being the &ldquo;media type&rdquo; and &lt;page id&gt; being the &ldquo;data&rdquo; of a Data URL. Nasdanika Drawio API extends it to additional media types: page/name element/id element/name spel - Uses a SpEL expression to evaluate the link target in the context of the current element. Format: data:spel,&lt;expression&gt; The data (selector) format has the following format: Page: [&lt;diagram resource&gt;#]&lt;page selector&gt; Diagram resource is a URI resolved relative to the current document URI. If not present then the link target page is in the same document. Page selector is either page ID or URL encoded page name depending on the media type - id or name. Element: [&lt;diagram resource&gt;#][&lt;page selector&gt;/]&lt;element selector&gt;] Diagram resource is a URI resolved relative to the current document URI. If not present then the link target element is in the same document. Page selector is either of: id,&lt;page id&gt; name,&lt;URL encoded page name&gt; Element selector is either page ID or URL encoded element label text (stripped of HTML formatting) depending on the media type - id or name. For elements URL&rsquo;s page selector is required if diagram resource URI is present. Examples: Page links: data:page/name,compressed.drawio#Page-1 - Link to compressed first page data:page/name,compressed.drawio#Page+2 - Link to compressed second page Element links: data:element/id,7KSC1_O8d7ACaxm1iSCq-1 - Link by ID to an element on the same page data:element/name,name,Page+2/Linked - Link by name to Linked on Page 2 referenced by name data:element/name,compressed.drawio#name,Page+2/Linked - Link to Linked on compressed second page This approach allows to create a multi-resource graph of diagrams. Nasdanika Drawio API also supports loading of documents from arbitrary URI&rsquo;s using a URI resolver. For example, maven://&lt;gav&gt;/&lt;resource path&gt; to load from Maven resources or gitlab://&lt;project&gt;/&lt;path&gt; to load resources from GitLab without cloning a repository, provided there is a handler (Function&lt;URI,InputStream&gt;) supporting the aforementioned URI&rsquo;s. Magic properties The API implements placeholder interpolation %&lt;property name&gt;% in the same way as Draw.io does if the &ldquo;Placeholders&rdquo; checkbox is checked. It also adds two &ldquo;magic&rdquo; properties to help with using model element values in structured properties. For example, you may have a property with YAML configuration with some values computed from the element properties. $style Evaluates to a value of the style key provided after the colon. Example: $style:fillColor $spel Evaluates a Spring Expression Langauge (SpEL) expression. Example: $spel:style[&quot;fillColor&quot;] Generating documentation sites With Nasdanika CLI drawio &gt; html-app &gt; site command pipeline can be used to generate documentation web sites from Drawio diagrams: Demo Video explaining how the above demo was created Template repository Internet Banking System - another demo: a sample C4 Model Visual Communication Continuum - a Medium story which provides an overview of the approach and compares it with semantic mapping Semantic Mapping - a medium story focusing on Semantic Mapping Overview video Below is an AI-generated overview video: Executable diagrams With Nasdanika Drawio API and other products you can make your diagrams executable as explained in the following sections. Invocable URIs You may set diagram element properties to URIs of processors. This approach is explained in General Purpose Executable Graphs and Diagrams Medium story. A demo repository is here - https://github.com/Nasdanika-Demos/executable-diagram-dynamic-proxy. You can use this site/ repository as a starting point for your diagramming ecosystem: Site Code Java You can create graph element processors for diagram elements in Java. Executable (computational) graphs &amp; diagrams story provides a high level overview of executable graphs and diagrams. Graph documentation features more technical details and code samples. Compute Graph Demo provides examples of this and semantic mapping (below) approaches using the compute graph from the &ldquo;Executable (computational) graphs &amp; diagrams&rdquo; story. Ecore Model Drawio Model module provides an EMF Ecore model for diagrams. A model instance can be obtained from the API document by calling Document.toModelDocument() method. The model makes it more convenient to work with the diagram elements by: Making links from diagram elements to pages and other diagram elements bi-directional. Introducing Tag class as opposed to a string in the API. Tag is contained by Page and has bi-directional reference with tagged elements. Sources JavaDoc Document The root object of the API representing a file/resource which contains one or more pages Page A page containing a diagram (Model) Model A diagram model containing the diagram root Root The root of the model containing layers Layer A diagram may have one or more layers. Layers contain Nodes and Connections. Layer Element Element Model Element Connectable A connectable can be connected to other connectables with connections. Connection A connection between two nodes * source 0..1 outgoingConnections * 1 1 1..* * target 0..1 incomingConnections * Tag * * Link Target linkTarget 0..1 Node Being a layer, a node may contain other nodes and connections. ConnectionPoint * Page-1",
    "timestamp": 1769516720252
  },
  "core/mapping/index.html": {
    "path": "Core/Mapping",
    "link-uuid": "7d6e934c-e832-404b-a562-0d25dc2b665b",
    "title": "Mapping",
    "content": "(Semantic) mapping is a process of creating and populating Ecore models from other data sources, Drawio diagrams in particular. This module provides base mapping functionality and the Drawio module provides concrete implementation classes and several Drawio-specific comparators which use element properties and geometry. This page provides a combined documentation for both generic and Drawio-specific mapping. Resources: Semantic Mapping Medium Story provides a high-level overview focusing more on the WHAT and the WHY while this page focuses more on the HOW. Most code snippets below are taken from the semantic mapping demo. Below is an AI-generated overview video: Table of Contents Table of Contents EMF Ecore ContentProvider DrawioContentProvider Loading Drawio resources Phases &amp; properties Initialization initializer Groovy initializer Mapping Script Java intitializer Mapping Initializer method type ref-id Contributor.initialize() page-element prototype selector target-selector reference features end container Example contents Examples USA Joe self source start target features-ref Representations Filtering Configuration config-prototype Documentation Label Markers identity configuration Tooltip Contributor.configure() Operations arguments iterator pass selector invoke Groovy mapper Mapping Script Java mapper Mapping Mapping method Mapping Selector Feature Mapping argument-type comparator condition expression greedy invoke path nop position type Comparators Geometric Angular clockwise counterclockwise Cartesian down-left down-right left-down left-up right-down right-up up-left up-right Dependency flow reverse-flow enumerate reverse-enumerate expression key label label-descending natural position reverse-position property property-descending Contributors Reflective contributors Example Configurator Client code EMF Ecore This section is a brief introduction to EMF Ecore, which is used to create metamodels of problem domains. These metamodels are then used as mapping targets. It is important to mention that metamodels and documentation generated from them have value on their own - they establish a common (ubiquitous) language.1 Eclipse Modeling Framework (EMF) is an Eclipse-based modeling framework and code generation facility for building tools and other applications based on a structured data model. Ecore is the core (meta-)model at the heart of EMF. It allows expressing other models by leveraging its constructs. Ecore is also its own metamodel (i.e.: Ecore is defined in terms of itself).2 Simply put, Ecore is a way to create (domain specific) languages understandable by both humans and computers. The above diagrams shows key Ecore concepts and their relationships. E prefix is dropped for clarity. E.g. EPackage is shown as Package. More detailed documentation can be found here - https://ecore.models.nasdanika.org/ (work in progress) Metamodel Module - Java/Maven module or an OSGi bundle. Contains zero or more models with each model containing a root package. Package - a group of classifiers and sub-packages. Packages are identified (keyed) by namespace URI&rsquo;s. Classifier - a class, data type or enumeration. Data type - a bridge to the Java type system. Enumeration - a collection of literals. Class - contains zero or more structural features - attributes and references and zero or more operations. May inherit from zero or more superclasses. Can be abstract and can be an interface. Structural feature - can hold single or multiple values Attribute - holds a &ldquo;simple&rdquo; value such as String, Date, number. Reference - relationship between two objects (EObjects). Unidirectional, but can be associated with another reference (opposite) to form a bi-directional relationship. References can be containment (composition) and non-containment (aggregation). Model Resource set - a group of related resources identified by a URI. Resource sets have associated packages, resource factories, adapter factories, and URI handlers. Resource - a group of objects. A resource is identified by a URI. Model Element - an instance of a metamodel class. Below is a concrete example using the Family metamodel and model: Metamodel Module - org.nasdanika.models.family:model Maven module, org.nasdanika.models.family Java module. Package - family defined in family.ecore resource with ecore://nasdanika.org/models/family namespace URI, several Java packages. Class - Man class inheriting from Person class. Structural feature Attribute - name attribute of Man (inherited from NamedElement). Reference Person.father - single non-containment reference, Person.children - many non-containment reference. Family.members - many containment reference. Model Resource set - created with a factory which treats .drawio diagram files as resources with diagram elements mapped to the family model. Resource - family.drawio file. Model Element - Paul and Elias are instances of Man class. Elias references Paul as his father. It is important to note that resources are identified by URI&rsquo;s, not URL&rsquo;s. It allows to load resources from multiple data sources - files, URL&rsquo;s, databases, source repositories such as Git, binary repositories such as Maven. Using Nasdanika classes it is also possible to load objects from multiple sources on access. For example, a person&rsquo;s id and name can be loaded from, say, Excel file or a database. Some other attributes may be loaded by making HTTP requests only if the client code reads those attributes. EMF Ecore provides facilities to read/write resources from/to XMI files and binary files. It also provides tools for creating models. Eclipse CDO allows to store models in distributed repositories. Nasdanika provides factories to load models from Drawio diagrams, MS Excel, Java sources, PDF files, and CSV files. It also provides URI handlers for loading models from classpath resources, GitLab &amp; Maven repositories. There is also a documentation generator for Ecore models. In addition to the family model mentioned above, you can find examples of Ecore models and generated documentation on this site. ContentProvider For the purposes of mapping the source structures are abstracted by the ContentProvider interface, whith the following methods: Collection&lt;? extends S&gt; getChildren(S element /*, Predicate&lt;S&gt; predicate */) - returns element children. URI getBaseURI(S element) - URI for resolving resources such as documentation. Object getProperty(S element, String property) - returns property used to perform mapping. Marked asMarked(S element) - for reporting locations of errors. S getConnectionSource(S element) - If the element is a connection/association - returns its source. Otherwise returns null. S getConnectionTarget(S element) - If the argument is a connection/association - returns its target. Otherwise returns null. String getName(S element) - Element name, e.g. Drawio element label text without HTML markup. String getDescription(S element) - Element description, e.g. Drawio element tooltip. Object getIdentity(S obj) - Object identity such as a unique ID or a URI. DrawioContentProvider DrawioContentProvider is an implementation of the ContentProvider for working with Drawio diagrams. It loads mapping properties from YAML in config property or a YAML resource specified in config-ref property. It also takes element and page links into account in parent/child relationships - linked elements are considered children of linking elements. DrawioContentProvider uses base-uri property for resolving the element base URI. If this property is not set, then the base URI is the URI of the drawio file plus a fragment, which is not significant for resolving relative URI&rsquo;s. If base-uri property is set, then it is resolved relative to the parent&rsquo;s base URI or the Drawio resource URI if there is no parent. Loading Drawio resources While you can use DrawioContentProvider directly and customize it to your needs, the primary usage scenario is to load Drawio diagrams as Ecore resources - mapping is performed behind the scenes: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nRequirement&lt;ResourceSetRequirement, ResourceSet&gt; requirement = ServiceCapabilityFactory.createRequirement(ResourceSet.class);\t\t\nResourceSet resourceSet = capabilityLoader.loadOne(requirement, progressMonitor);\nFile diagramFile = new File(&quot;diagram.drawio&quot;).getCanonicalFile();\nResource resource = resourceSet.getResource(URI.createFileURI(diagramFile.getAbsolutePath()), true);\t\t\nEObject root = resource.getContents().get(0);\t\n In the above code snippet a resource set is loaded from a CapabilityLoader and contains all resource factories and EPackages provided as capabilities. It includes ConfigurationLoadingDrawioResourceFactory which is registered to load .drawio and .png files. This factory customizes mapping properties: mapping - if this property is set, its value is parsed as YAML which is used as property source. mapping-ref - if mapping property is not set and this property is set, then this property value treated as a location of a YAML resource containing mapping configuration. The location (URI) is resolved relative to the base URI of the element. Phases &amp; properties Mapping is a non-trivial process. In the case of diagrams the order in which diagram elements are mapped is not under control of the user - it depends on the order of creation of the diagram elements. Therefore, the mapping process consists of several phases and some of them may involve multiple passes. This section describes the mapping process in the order of phases. A phase section explains element configuration properties (keys) used for that phase. In some phases only one property is used. In this case the phase name is the same as the property name. In the mapping reference pages properties are ordered alphabetically. Initialization In this first phase source elements are associated with (mapped to) target elements. For example, a person image can be associated with a person object from the family model. The phase is called &ldquo;Initialization&rdquo; because the mapping process is similar to assigning a value to a variable in languages like Java and virtually identical to what happens in JavaScript where objects are essentially maps. The following sections explain the configuration properties used in the initialization phase. initializer initializer property value shall be an Invocable URI resolved relative to the base URI. The invocable is bound to the following arguments by name: registry - Consumer&lt;BiConsumer&lt;Map&lt;EObject, EObject&gt;,ProgressMonitor&gt;&gt; callback to obtain a map of source elements to target elements once all target elements are initialized (created), but not necessarily fully configured. contentProvider - content provider progressMonitor - progress monitor resourceSet - can be used to load target model elements capabilityLoader - can be used to load capabilities, including invocable URIs Then it is invoked with the source object as a single positional argument. It may return null - in this case type would be used to create a target element, if specified. This property can be used, for example, to look-up target elements defined elsewhere. Say, a list of family members can be defined in an MS Excel workbook, but family relationships in a diagram. Another example is &ldquo;progressive enrichment&rdquo;. For example, high-level architecture is defined in some model and a diagram uses initializers for already defined architecture elements and type for their sub-elements. This approach can be applied multiple times similar to how Docker images are assembled from layers and base images - you can layer fine-grained models/diagrams over coarse-grained ones. If you are old enough to remember JPEG images being loaded over a slow dial-up connection - something like that. In order to implement lookup initializers, override configureInitializer(), configureInvocable() or getVariables() in sub-classes of AbstractMappingFactory or getVariables() in a subclass of ConfigurationLoadingDrawioResourceFactory. Groovy initializer Mapping initializer: initializer.groovy\n Script import org.nasdanika.models.architecture.ArchitectureFactory\n\nArchitectureFactory.eINSTANCE.createDomain();\n Java intitializer Mapping initializer: data:java/org.nasdanika.demos.diagrams.mapping.Services::nodeInitializer\n Initializer method public static ArchitectureDescriptionElement nodeInitializer(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor loadingProgressMonitor, \n\t\tbyte[] binding,\n\t\tString fragment,\n\t\t@Parameter(name = &quot;contentProvider&quot;) ContentProvider&lt;Element&gt; contentProvider,\n\t\t@Parameter(name = &quot;registry&quot;) Consumer&lt;BiConsumer&lt;Map&lt;EObject, EObject&gt;,ProgressMonitor&gt;&gt; registry,\n\t\t@Parameter(name = &quot;progressMonitor&quot;) ProgressMonitor mappingProgressMonitor,\n\t\t@Parameter(name = &quot;resourceSet&quot;) ResourceSet resourceSet,\n\t\t@Parameter(name = &quot;capabilityLoader&quot;) CapabilityLoader capabilityLoader,\n\t\tElement source) {\n\tArchitectureDescriptionElement architectureDescriptionElement = ArchitectureFactory.eINSTANCE.createArchitectureDescriptionElement();\n\tarchitectureDescriptionElement.setDescription(&quot;I was created by a Java initializer&quot;);\n\treturn architectureDescriptionElement;\t\t\t\t\n}\n Note the use of positional and named parameters: The first 4 parameters are bound positionally when invocable URI is loaded The 5 named parameters a bound by name by the mapper The last parameter is used for invocation (also positional) type type property is used if there is no initializer or if it returned null. The value of property is the type of the target element. Types are looked up in the factory packages in the following way: If the value contains a hash (#) then it is treated as a type URI. For example ecore://nasdanika.org/models/family#//Man. If the value contains a dot (.) then it is treated as a qualified EClass name with EPackage prefix before the dot. For example family.Man. There may be more than one dot if EClass is defined in a sub-package. For example, exec.content.Markdown. Otherwise, the value is treated as an unqualified EClass name - registered EPackages (and sub-packages recursively) are sorted by Namespace URI, iterated, and the first found EClass with matching name is used to create a target element. A combination of initializer and type can be used for mapping in different contexts. For example, when loading a stand-alone model initializer would evaluate to null and then type would be used. When the same diagram loaded in the context of a larger model, initializer may evaluate to a target element looked up in that larger model. Example: type: architecture.c4.System\n A Java analogy for type: Object isaDiagramElement = getClassLoader().loadClass(type).newInstance();\n ref-id ref-id is some identifier to resolve to a target element. If there is already a target element created/resolved with initializer or type and isRefIProxydURI() returns true, then ref-id is treated as EObject proxy URI resolved relative to the base URI (see below). You may need to use this approach in case of circular references between resources or if the target element type and URI are known, but the element itself is not available during the load time. If there is no target element yet, then ref-id is used to look it up in the resource set. You may use a &ldquo;physical&rdquo; URI to load objects on demand, or &ldquo;logical&rdquo;/&ldquo;semantic&rdquo; URI for already loaded objects. Say, ssn:123-45-6789 to lookup a person by their SSN. Contributor.initialize() Initialization can be customized by creating a service capability of type AbstractMappingFactory.Contriutor and overriding its initialize() method. page-element If there is no target element for a diagram element yet and the diagram element&rsquo;s page-element property is set to true then its target element is set to the first found target element of diagram elements linking to the page. For example, on the System Context Diagram the &ldquo;Internet Banking System&rdquo; element links to the Container diagram page where the &ldquo;Internet Banking System&rdquo; container is the page element. As a result, both of these diagram elements map to the same target element. There should be one page element per page. Having more than one may lead to an unpredictable behavior. Using page-element you can define a high-level structure on one diagram page, link other pages to the diagram elements and refine their definitions. This process can be repeated to build a hierarchy of pages as demonstrated in the &ldquo;Internet Banking System Architecture&rdquo; demo mentioned above. If the target element of a page element extends NamedElement then the page name is used as element&rsquo;s name if hasn&rsquo;t been already set by other means. prototype prototype is a Spring Expression Language (SpEL) expression evaluating to a diagram element. The target element of that diagram element is copied and the copy is used as the target element of this diagram element. Also, the prototype configuration (properties) is applied to this target element. Example: getPage().getDocument().getModelElementById('web-server-prototype') Prototypes allow to define common configuration in one element and then reuse it in other elements. For example, a web server prototype may define an icon and then all web server elements would inherit that configuration. Prototypes can be chained - you may create an inheritance hierarchy of diagram elements. Drawio classes provide convenience methods for finding diagram elements: Element.getModelElementById(String id) Element.getModelElementByProperty(String name, String value) Element.getModelElementsByProperty(String name, String value) Document.getPageById(String id) Document.getPageByName(String name) If you want to inherit just configuration, but not the target element, then use config-prototype property instead of prototype. selector selector is a Spring Expression Language (SpEL) expression evaluating to a diagram element. The target element of that diagram element is used as the target element of this diagram element. Selectors allow to use the same target element on multiple diagrams. For example, in the Internet Banking System E-Mail System is defined on the System Context Diagram and selected (referenced) on the Container Diagram with getModel().getPage().getDocument().getModelElementByProperty('semantic-id', 'microsoft-exchange') expression. The expression is evaluated in the context of the diagram element with access to the following variables: registry pass progressMonitor resourceSet capabilityLoader Please note that you may also use the extended link syntax to associate more than one diagram element with a single target element. If you are selecting by diagram element id or label, then the extended link syntax is preferable to using selector expression. In the &ldquo;Internet Banking System&rdquo; C4 Model demo Single-Page Application is defined on the Container Diagram and linked from the API Application Component Diagram with data:element/id,name,Container+Diagram/single-page-application) link. target-selector Spring Expression Language (SpEL) expression evaluating to a target element. Target selectors are similar to initializers with the following differences: Target selectors are evaluated after initializers An initializer is evaluated once, but a target selector might be evaluated multiple times until it returns a non-null value or the maximum number of passes is exceeded A target selector is only evaluated if there isn&rsquo;t a target element already Target selectors can be used to evaluate target elements using target elements of other elements. For example, a target selector of a child node may need a target element of its parent to resolve its own target element. The expression is evaluated in the context of the diagram element with access to the following variables: * registry * pass * progressMonitor * resourceSet * capabilityLoader reference Diagram elements can be associated with target elements&rsquo; references. A Java analogy would be: List&lt;Person&gt; isaChildrenDiagramElement = familyWorkBook.findById(&quot;isa&quot;).getChildren();\n reference property associates a diagram element with a reference of the target element of the first matched ancestor for mapping purposes. If the element has mapped descendants, their matching targets elements are added to the reference. Reference value can be a string or a map. The string form is equivalent to the map form with just the name entry. The map form supports the following keys: comparator - used to sort reference elements, see the Comparators section. condition - a SpEL boolean expression evaluated in the context of the ancestor target element. If not provided, matches the first mapped ancestor. Has access to the following variables: sourcePath - a list of ancestors starting with the parent registry expression - a SpEL EObject expression evaluated in the context of the ancestor target element. If not provided, the ancestor itself is used. Has access to the following variables: sourcePath - a list of ancestors starting with the parent registry name - reference name element-condition - a SpEL boolean expression evaluated in the context of the descendant (contents) target element. If not provided, elements are matched by type compatibility with the reference type. Has access to the following variables: sourcePath - source containment path registry element-expression - a SpEL EObject expression evaluated in the context of the descendant (contents) target element. If not provided, the descendant itself is used. Has access to the following variables: sourcePath - source containment path registry See References demo for examples of using reference mapping. features features property defines mapping of target element structural features - references and attributes. Feature mapping demo provides a few examples of reference mapping. The value of the property shall be a map with the following supported keys: end container contents self source start target end For connections - mapping specification, as explained in the Feature Mapping section, for the connection end feature to map the connection target semantic element3 to a feature of the connection semantic element. end: father\n The above specification means &ldquo;set father reference of the connection semantic element to the semantic element of its end (Joe)&rdquo;. container Mapping specification for the container element in container/contents permutation. Contains one or more of the following sub-keys with each containing a map of feature names to a mapping specification or a list of feature names. self - this element is a container other - the other element is a container Example type: family.Polity\nfeatures:\n  container:\n    self: \n      residents:\n        argument-type: family.Person\n        path: 1\n    other: constituents\n The above example shows Texas feature mapping: self means Texas itself. The mapping specifies that immediate children of this element (path: 1) shall be added to this (Texas) semantic element residents collection if they are instances of family.Person. Joe diagram element is an immediate child of the Texas diagram element. other means USA because USA contains Texas. This mapping specifies that this (Texas&rsquo;) target element shall be added to the constituents feature of its container (USA) regardless of the containment path length. In the example the containment path length is 1. Please note that when a diagram element is linked to a page, then the page&rsquo;s page element is logically merged with that element. In the Internet Banking System Architecture GetBalanceRequest is contained by Internet Banking System with path=3 - they appear on different diagrams (pages), but these diagrams are connected with page links. contents Mapping specification for the contents element in container/contents permutation. Contains one or more of the following sub-keys with each containing a map of feature names to a mapping specification or a list of feature names. self - this element is contained by the other other - the other element is contained by this element Examples USA contents:\n  other: \n    country:\n      path: 2\n The above feature map for USA means that other is either Florida, Texas, Jane or Joe - they are all contained in USA directly or indirectly. Path 2 means that only Jane and Joe match this mapping. And country means that their country reference shall be set to USA. Joe contents:\n  self: \n    country:\n      path: 2\n The above feature map for Joe means that other is either Texas or USA - they both contain Joe, Texas directly and USA transitively. Path 2 means that only USA matches this mapping. And country means that Joe&rsquo;s country reference shall be set to USA. self A map of feature names to Spring Expression Language (SpEL) expressions or a list of expressions evaluating to the feature value or feature element value. The expression is evaluated in the context of the source diagram element and has access to the following variables: value - semantic element registry - a map of diagram element to semantic elements source For connections - mapping specification for the connection source feature to map the connection semantic element to a feature of the connection source semantic element. If there are no connection semantic elements, then the connection target semantic element is used instead (pass-through connection). source: father\n The above specification at the Jane -&gt; Joe connection means to set connection source (Jane) father feature to connection target semantic element (Joe) because the connection itself doesn&rsquo;t have semantic elements. In pseudo-code: connection.getSource().setFather(connection.getTarget());\n start For connections - mapping specification for the connection start feature to map the connection source semantic element to a feature of the connection semantic element. start: child\n The above specification means &ldquo;set child reference of the connection semantic element to the semantic element of its start (Jane)&rdquo;. target For connections - mapping specification for the connection target feature to map the connection semantic element to a feature of the connection target semantic element. If the connection doesn&rsquo;t have semantic elements (pass-through connection), then the connection source semantic element is used instead. target: children\n The above specification at the Jane -&gt; Joe connection means to set connection target (Joe) children feature to the connection source semantic element (Jane) because the connection itself doesn&rsquo;t have semantic elements. In pseudo-code: connection.getTarget().getChildren().add(connection.getSource());\n features-ref features-ref property value shall be a string which is treated as a URI resolved relative to the base URI. Resource at the URI is parsed as YAML. Representations For semantic elements which extend ModelElement the loading process injects representations which can be used in Markdown documentation and as icons in generated HTML documentation. The loading process injects two representations: drawio - a Drawio diagram containing pages where the page element maps to this target element. image - loaded from diagram element style image. Representation reduce documentation effort and drive consistency. Filtering Representations can be customized (filtered) by creating a service capability of type AbstractMappingFactory.Contributor implementing AbstractDrawioFactory.RepresentationElementFilter and implementing its filterRepresentation() method. This functionality can be used, for example to style elements based on information retrieved from external systems. For example: Development status - Planned/Backlog, In Progress, Blocked, Done Runtime status - Operational, Overloaded, Failed, Planned maintenance Quality/technical debt status - OK, Warning, Danger Configuration After diagram elements are mapped to target elements (initialized) and their features are mapped, they are configured using their diagram element properties as explained below. config-prototype With config-prototype property you can inherit configuration from another diagram element. Property value shall be a Spring Expression Language (SpEL) expression evaluating to a diagram element. Diagram element configuration (properties) is applied to this semantic element. Example: getDocument().getModelElementById('web-server-prototype') Config prototypes allow to define common configuration in one element and then reuse it in other elements. For example, a web server prototype may define an icon and then all web server element would inherit that configuration. Config prototypes can be chained - you may create an inheritance hierarchy of diagram elements. Documentation Documentation properties can be used to add documentation to target elements which implement Documented interface. Documentation can be provided in documentation property in Markdown, plain text, or HTML. Markdown is the default documentation format. You can modify it by setting doc-format property. Supported values are markdown, text, and html. It might be more convenient to maintain documentation in an external resource. In this case specify the documentation resource URI in doc-ref property. The resource URI is resolved relative to the base URI of the diagram element. If doc-format is not set, it is inferred from the resource extension - HTML for .htm and .html, text for .txt, Markdown otherwise. Documentation may also be configured via configuration or configuration-ref. Label If the target element extends NamedElement and its name is not set, then diagram element label converted to plain text is used as semantic element name. Markers If the target element implements Marked then the loading process adds diagram element markers to the semantic element. It allows to track provenance of data elements which might important in scenarios where model elements are loaded from diverse sources and even a single element may be loaded from several sources. For example, attributes are loaded from an Excel workbook and relationships from a Drawio diagram. The loading process is aware of Git repositories - if it detects that the diagram file is under source control it would store Git-specific information in markers - repository path, branch, commit hash, remotes, and head references. identity If the target element extends StringIdentity, identity property can be used to specify the id attribute. If this property is not provided, then Drawio model element ID is used as identity. Drawio element id&rsquo;s are editable, but duplicate id&rsquo;s are not allowed on the same page. You may have duplicate semantic id&rsquo;s in different containers on the same page. In this case you may use identity. Identity can also be set using the configuration and configuration-ref YAML, this property is a shortcut way. configuration Target elements may be configured by providing a YAML configuration map in the configuration property or a URI of a configuration resource in the configuration-ref property. The URI is resolved relative to the base URI of the diagram element. Configuration YAML maps target element features (attributes and references) to their values as shown in the below example: location: %id%/index.html\nicon: /images/mapping.svg\nchildren:\n  - Action:\n      location: mapping-reference.html\n      text: Mapping Reference\n      content:\n        Interpolator:\n          source:\n            Markdown:\n              style: true\n              source:\n                exec.content.Resource: mapping-reference.md\n Note singleton maps specifying child elements. The key of of such maps is a type as explained in the &ldquo;Initialization&rdquo; &gt; &ldquo;type&rdquo; section: Action - a short type name, there is only one Action class available during loading Interpolator - also a short type name exec.content.Resource - a fully qualified type name because there are two Resource classes - in the content package and in the resources package &ldquo;Load specification&rdquo; model documentation pages provide information about configuration keys supported by a specific type. Examples: Action class Load Specification Woman class Load Specification Tooltip If the target element extends NamedElement and its description is not set, then diagram element tooltip is used as semantic element description. Contributor.configure() Configuration can be customized by creating a service capability of type AbstractMappingFactory.Contributor and overriding its configure() method. Operations Using operations and operations-ref properties you may specify target element operations to be invoked. operations value shall be a YAML map of invocation target to operation names and then to invocation specifications explained below, operations-ref shall be a URI of a resource containing a YAML map. The URI is resolved relative to the diagram element base URI. The invocation target is either self, source or target`.sourceandtarget`` are applicable only to connections. The invocation specification is either a map or a list of maps. The sections below describe the keys supported by the maps. Examples: type: Fox\noperations:\n  self:\n    eats: \n      arguments:\n        food: &quot;#registry.get(outgoingConnections[0].target)&quot;\n      pass: 2\n operations:\n  source:\n    eats: \n      arguments:\n        food: &quot;#registry.get(target)&quot;\n arguments A map of parameter names to SpEL expression evaluating their values in the context of the iterator element (see below). Argument names are used for operation selection/matching - a candidate operation must have parameters with matching names. The map does not have to contain entries for all operation parameters. Nulls are used as arguments for parameters which are not present in the map. iterator An optional SpEL expression which returns a value to iterate over and invoke the operation for every element. If the result is java.util.Iterator then it is used AS-IS. If the result is Iterable, Stream, or array, an iterator is created to iterate over the elements. If the result is null, then an empty iterator is created. Otherwise, a singleton iterator is created wrapping the result. It allows to invoke the operation zero or more times. If not defined, the iterator contains the source diagram element. pass An optional integer specifying the pass in which this operation shall be invoked. Use for ordering operation invocations. In the above example, because we want the Fox to eat the Hare after the Hare eats the Grass, we need so set pass to 1 for the Fox. selector An optional SpEL boolean expression evaluated in the context of the operation to disambiguate overloaded operations. invoke The last phase of mapping is invoking Invocable URIs specified in invoke property. URIs are resolved relative to the base URI. Invocables are bound to the following arguments by name: target - target (semantic) element, can be null pass registry - a map of source elements to target elements contentProvider progressMonitor resourceSet capabilityLoader Then it is invoked with the source element as a single positional argument. If the invokable return false it means that it could not complete its job in this pass and it will in invoked again in subsequent passes until it returns anything other than false. This functionlity can be used for procedural/imperative mapping in configuration/declarative mapping is not enough or you just prefer to do things procedurally. Groovy mapper Mapping invoke: mapper.groovy\n Script import org.nasdanika.models.nature.Color\n\nSystem.out.println(&quot;---&quot;);\nSystem.out.println(&quot;Source: &quot; + args);\nSystem.out.println(&quot;Target: &quot; + target);\nSystem.out.println(&quot;Pass: &quot; + pass);\n\ntarget.setColor(Color.BROWN);\n\nreturn pass &gt; 2; // Just to test multiple invocations\n Java mapper Mapping invoke: data:java/org.nasdanika.demos.diagrams.mapping.Services::connectionMapper\n Mapping method \npublic static void connectionMapper(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor loadingProgressMonitor, \n\t\tbyte[] binding,\n\t\tString fragment,\n\t\t@Parameter(name = &quot;target&quot;) Object target,\n\t\t@Parameter(name = &quot;pass&quot;) int pass,\n\t\t@Parameter(name = &quot;contentProvider&quot;) ContentProvider&lt;Element&gt; contentProvider,\n\t\t@Parameter(name = &quot;registry&quot;) Map&lt;EObject, EObject&gt; registry,\n\t\t@Parameter(name = &quot;progressMonitor&quot;) ProgressMonitor mappingProgressMonitor,\n\t\t@Parameter(name = &quot;resourceSet&quot;) ResourceSet resourceSet,\n\t\t@Parameter(name = &quot;capabilityLoader&quot;) CapabilityLoader capabilityLoader,\n\t\tConnection source) {\n\n\tSystem.out.println(&quot;--- Java mapper ---&quot;);\t\t\t\t\n\tSystem.out.println(&quot;Connection: &quot; + source);\t\t\n\tSystem.out.println(&quot;Pass: &quot; + pass);\t\t\n}\t\n Note the use of positional and named parameters: The first 4 parameters are bound positionally when invocable URI is loaded The 5 named parameters a bound by name by the mapper The last parameter is used for invocation (also positional) Mapping Selector Mapping selector can be used to select zero or more target elements for feature mapping. If it is not provided, then the diagram element&rsquo;s target element is used for feature mapping, if it is present. Mapping selector shall be a YAML document containing either a single string or a list of strings. The strings are treated as Spring Expression Language (SpEL)] expression evaluating to a target element or a collection of target elements to use for feature mapping. Expressions are evaluated in the context of the diagram element and have access to the following variables: registry progressMonitor resourceSet capabilityLoader Mapping selectors may be used to associate multiple semantic elements with a diagram element for feature mapping purposes. Mapping selector can be defined in mapping-selector property or in an external resource with URI specified in mapping-selector-ref property. The resource URI is resolved relative to the base URI of the diagram element. Feature Mapping This section explains the structure of feature map values. The mapping value can be either a string or a map. If it is a string it is treated as a singleton map to true (unconditional mapping). The below two snippets are equivalent: container:\n  other: elements\n container:\n  other: \n    elements: true\n The map value supports the following keys: argument-type Specifies the type of feature elements to be set/added. String or a list of strings. Each string is a type name as defined above Optionally prefixed with ! for negation. In the case of a list of strings the result is a logical OR - if any of elements matches. Only instances of matching types will be set/added. If absent, the feature type is used. Argument type can be used to restrict elements to a specific subtype of the feature type. Examples: In the below snippet elements of type Transition and its sub-types are excluded from the elements. container:\n  self: \n    elements:\n      argument-type: &quot;!Transition&quot;\n      path: 2\n In this example only elements of type Person (and its sub-types) are added to the members feature. container:\n  self: \n    members:\n    argument-type: Person\n This example is equivalent to the previous one, but lists Person sub-types Man and Woman explicitly. container:\n  self: \n    members:\n    argument-type:\n      - Man\n      - Woman\n comparator Comparator is used for sorting elements of &ldquo;many&rdquo; features. See the Comparators section below for a list of available comparators and their configurations. condition A SpEL boolean expression evaluated in the context of the candidate diagram element with the following variables: value - semantic element of the candidate diagram element path - containment path registry - a map of diagram element to semantic elements progressMonitor resourceSet capabilityLoader expression A SpEL expression evaluating to a feature value in the context of the diagram element with with the following variables: value - semantic element of the diagram element path - containment path registry - a map of diagram element to semantic elements progressMonitor resourceSet capabilityLoader greedy Greedy is used with containment features and specifies what to do if a candidate object is already contained by another object: no-children - grab the object if it is contained by an ancestor of this semantic element. This is the default behavior. false - do not grab true - always grab invoke Invocable URI resolved relative to the base URI. The invocable is bound to the following arguments by name: argumentValue - feature value or value evaluated by expression. baseURI context progressMonitor registry sourcePath type resourceSet capabilityLoader It is invoked with argument as positional argument and shall return feature value. path Either an integer number or a list of boolean SpEL expressions to match the path. If an integer, then it is used to match path length as shown in the example below, which matches only immediate children container:\n  self: \n    elements:\n      path: 1\n If a list, then it matches if the list size is equal to the path length and each element evaluates to true in the context of a given path element. Expressions have access to registry variable - a map of diagram elements to semantic (target) elements. nop If true then no mapping is performed and the chain mapper is not invoked. It can be used in scenarios with a default (chained) mapper to prevent the default behavior. position A number specifying the position of the element in the feature collection. Please note that while this key is supported using it may lead to loading errors if the feature collection is smaller than the position. Because the loading order is generally not controlled by the diagram author, only 0 position is guaranteed to work all the time. type Type of the feature object to match. String as defined in the Initialization / type section. Can be used in other mappings. Comparators Comparators are used for &ldquo;many&rdquo; features to order elements. A comparator instance is created by AbstractDrawioFactory.createMapperComparator() method which can be overridden in subclasses to provide support for additional comparators. The following comparators are provided &ldquo;out of the box&rdquo;: Geometric Diagram element position convey semantics. However, most diagramming tools ignore it. I.e. they lose information or force diagrammers to keep geometry and semantics in sync. Geometric comparators allow to order semantic elements according to the positions of their diagram elements - to semantize geometry. There are two classes of geometric comparators - Angular and Cartesian. Angular Angular comparators use angles to order elements. There are two flavors - clockwise and counterclockwise. clockwise Compares elements by their angle relative to the node of the semantic element which holds the many reference. For example, in the Living Beings demo &ldquo;Bird&rdquo;, &ldquo;Fish&rdquo;, and &ldquo;Bacteria&rdquo; are compared by their angle to the &ldquo;Living Beings&rdquo; with the angle counted from &ldquo;12 o&rsquo;clock&rdquo; - 90 degrees (default). Feature mapping with comparators of &ldquo;Bird&rdquo;, &ldquo;Fish&rdquo;, and &ldquo;Bacteria&rdquo; are defined at the connections from &ldquo;Living Beings&rdquo; as: source: \nelements:\n comparator: clockwise\n To specify the base angle other than 90 degree use the map version of comparator definition where clockwise is the key mapping to a number or string value. The number value is used as the angle value in degrees. The string value is treated as a Spring Expression Language (SpEL) expression evaluated in the context of the &ldquo;parent&rdquo; node. The expression may evaluate to a number or to a node. In the latter case the result is used to compute the angle between the context node and the result node. In the Living Beings example &ldquo;Streptococcus&rdquo;, &hellip;, &ldquo;Staphyllococcus&rdquo; are compared relative to the &ldquo;Bacteria&rdquo; node with the base angle being the angle between the &ldquo;Bacteria&rdquo; node and &ldquo;Living Beings&rdquo; node. As such, &ldquo;Streptococcus&rdquo; is the smallest node and &ldquo;Staphyllococcus&rdquo; is the largest. With the default angle of 90 degrees &ldquo;Lactobacyllus&rdquo; would be the smallest and &ldquo;Streptococcus&rdquo; would be the largest. Feature mapping with comparators of &ldquo;Streptococcus&rdquo;, &hellip;, &ldquo;Staphyllococcus&rdquo; is defined at connections from &ldquo;Bacteria&rdquo; to the respective genus nodes as: source: \nelements:\n comparator: \nclockwise: incoming[0].source\n incoming[0] evaluates to the connection from &ldquo;Living Beings&rdquo; to &ldquo;Bacteria&rdquo; and source evaluates to &ldquo;Living Beings&rdquo;. counterclockwise Reverse of clockwise. Cartesian Cartesian comparators use horizontal and vertical positions to compare/order elements with 2 coordinates and 2 directions in each it gives us 8 permutations. down-left Compares nodes by their vertical order first with higher nodes being smaller and then by horizontal order with nodes on the right being smaller. Nodes are considered vertically equal if they vertically overlap. down-right Compares nodes by their vertical order first with higher nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. This comparator can be used for org. charts. left-down Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. left-up Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-down Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-up Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. up-left Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the right being smaller. Nodes are considered vertically equal if they vertically overlap. up-right Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. Dependency flow and reverse-flow order elements based on how they are connected to each other. flow If one element is reachable from the other by traversing connections, then the reachable element is larger than the source element. In case of circular references the element with the smaller number of traversals to the other element is considered smaller. If elements are not connected they are compared by the fall-back comparator. Flow comparator can be used for workflows and PERT charts. If this comparator&rsquo;s value is a String, then it is used as a name of the fallback comparator. In the below example children in the Sample Family will be smaller than their parents and siblings will be compared using labels. container:\n  self: \n    members:\n      argument-type: Person\n      comparator: \n        flow: label\n If the value is a map, then it may have the following keys: condition - A boolean SpEL expression evaluated in the context of a connection being traversed. It may be used to traverse only connections which match the condition. fallback - Fallback comparator. The below snippet shows the Internet Banking System Container diagram comparator: container:\n  self: \n    elements:\n      path: 1\n      comparator: \n        flow: \n          fallback: label\n          condition: id != 'send-email'\n The condition specifies that a connection with sent-mail ID shall not be traversed. reverse-flow Same as flow but with target nodes being smaller than source nodes. enumerate Sorts model elements using enumerate value. Elements without enumerate value are considered equal to any other elements including those with enumerate value. This is done to allow chaining with, say, flow comparator. As a result, this comparator will violate the transitivity requirement if some elements don&rsquo;t have enumerate value. Therefore, it shall be chained with other comparators. For example, flow and then position or label. Enumerate value is treated as path of dot-separated values and two enumerate values are compared element-by-element with elements containing only digits parsed and compared as integers. For example, 20 would be greater than 3, 1.1.1 would be greater than 1.1 and smaller than 2.5.6 or 3. Numbers are considered smaller than strings 1.12 is smaller than 1.a Practical use - ordering connections emanating from the same node. Say, excursions from the same location. If those excursions have multiple segments, then this comparator can be chained with the flow comparator and possibly terminated by the position or label comparator just in case. Example: container:\n  self: \n    elements:\n      path: 1\n      comparator: \n        enumerate:\n          fallback:          \n            flow: \n              fallback: label\n              condition: id != 'send-email'\n reverse-enumerate Reversed position comparator. expression A SpEL expression evaluated in the context of the feature element with other variable referencing the element to compare with. The expression has access to the following variables: registry progressMonitor resourceSet capabilityLoader key A SpEL expression evaluated in the context of the feature element. The expression must return a value which would be used for comparison using the natural comparator. label Uses the diagram element label converted to plain text as a sorting key. In the Family mapping demo family members are sorted by label using the following feature map definition: container:\n self: \nmembers:\n argument-type: Person\n comparator: label\n label-descending Uses the diagram element label converted to plain text as a sorting key to compare in reverse alphabetical order. natural Uses the feature element&rsquo;s compareTo() method for comparable elements. Otherwise compares using the hash code. Nulls are greater than non-nulls. position Uses the diagram element position in the parent element for sorting. Example: container:\n self: \nmembers:\n comparator: position\n reverse-position Reversed position comparator. property Uses diagram element property as a sorting key. A singleton map. For example: property: label\n property-descending The same as property, but compares in reverse alphabetical order. Contributors In addition to loading Contributors via the capability framework they can get added to the contributors list programmatically. This scenario can be useful for contributors which are specific for a given digaram or piece of functionality. Reflective contributors ReflectiveContributor provides two method annotations - @Initalizer and @Configurator which allow to contribute to the mapping process using annotated methods. This can be used for fine-grained contributions. For example, you may have a UI wireframe diagram with high-level structure and configuration defined in the diagram and some details (e.g. values retrieved from external systems) injected by annotated methods. Both annotations have the following attributes: value - If not blank (default), the value shall be a Spring boolean expression which is evaluated in the context of the source with target as target variable. sourceType - source type matching is done by the first parameter type. This attribute can be used to narrow the match. targetType - target type matching is done by the second parameter type. This attribute can be used to narrow the match. priority - methods with higher priority value are invoked before methods with lower priority value Annotated methods for both annotations must have at least two parameters to accept source and target arguments. Initializer methods can have up to 5 parameters with additional parameters listed below: BiConsumer&lt;EObject, BiConsumer&lt;EObject, ProgressMonitor&gt;&gt; elementProvider Consumer&lt;BiConsumer&lt;Map&lt;EObject, EObject&gt;, ProgressMonitor&gt;&gt; registry ProgressMonitor progressMonitor Configurator methods can have up to 6 parameters with additional parameters listed below: Collection&lt;EObject&gt; documentation Map&lt;S, T&gt; registry boolean isPrototype ProgressMonitor progressMonitor Example Configurator public class Configurators {\n    \n    @Configurator(&quot;id == 'body-root-container'&quot;)\n    public void configure(Node source, Container target) {       \n        Appearance appearance = BootstrapFactory.eINSTANCE.createAppearance();      \n        target.setAppearance(appearance);\n        appearance.setBackground(Color.PRIMARY);\n    }\n\n}\n In the above snippet configure method matches a source node with id body-root-containter which is mapped to Container. The method sets the container background color. Client code ReflectiveContributor&lt;Element, EObject&gt; rc = new ReflectiveContributor&lt;&gt;(List.of(new Configurators()));  \nDocument document = Document.load(new File(&quot;bootstrap.drawio&quot;));        \n\nConnectionBase connectionBase = ConnectionBase.SOURCE;\nContentProvider&lt;Element&gt; contentProvider = new DrawioContentProvider(\n        document, \n        Context.BASE_URI_PROPERTY, \n        MAPPING_PROPERTY, \n        MAPPING_REF_PROPERTY, \n        connectionBase);\n\nCapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nRequirement&lt;ResourceSetRequirement, ResourceSet&gt; requirement = ServiceCapabilityFactory.createRequirement(ResourceSet.class);       \nResourceSet resourceSet = capabilityLoader.loadOne(requirement, progressMonitor);\n        \nConfigurationLoadingDrawioFactory&lt;EObject&gt; drawioFactory = new ConfigurationLoadingDrawioFactory&lt;EObject&gt;(\n        contentProvider, \n        capabilityLoader, \n        resourceSet, \n        progressMonitor) {\n\n            @Override\n            protected EObject getByRefId(Element obj, String refId, int pass, Map&lt;Element, EObject&gt; registry) {\n                return null;\n            }\n    \n};\n\ndrawioFactory.getContributors().add(rc);\n\nTransformer&lt;Element,EObject&gt; modelFactory = new Transformer&lt;&gt;(drawioFactory);\nList&lt;Element&gt; documentElements = new ArrayList&lt;&gt;();\nConsumer&lt;Element&gt; visitor = documentElements::add;\n@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })\nConsumer&lt;org.nasdanika.graph.Element&gt; traverser = (Consumer) org.nasdanika.drawio.Util.traverser(visitor, connectionBase);\ndocument.accept(traverser);\n\nMap&lt;Element, EObject&gt; modelElements = modelFactory.transform(documentElements, false, progressMonitor);\n\nList&lt;EObject&gt; cnt = new ArrayList&lt;&gt;();\nmodelElements.values()\n    .stream()\n    .distinct()\n    .filter(modelElement -&gt; modelElement != null &amp;&amp; modelElement.eContainer() == null)\n    .forEach(cnt::add);\n\n// Saving for manual inspection\nURI xmiURI = URI.createFileURI(new File(&quot;target/bootstrap.xml&quot;).getAbsolutePath());\nResource xmiResource = resourceSet.createResource(xmiURI);\nxmiResource.getContents().addAll(cnt);\nxmiResource.save(null);\n\nHtmlGenerator htmlGenerator = HtmlGenerator.load(\n        Context.EMPTY_CONTEXT, \n        null, \n        progressMonitor);\n        \nProducer&lt;Object&gt; processor = htmlGenerator.createProducer(cnt.get(0), progressMonitor);\nObject result = processor.produce(0);\n\nFiles.writeString(Path.of(&quot;target&quot;, &quot;bootstrap.html&quot;), (String) result);\n In the above snippet: Configurator class is instantiated and added at the reflective contributor at line 1. Document is loaded from a file at line 2 and then a content provider is created from it. ResourceSet is obtained from CapabilityLoader ConfigurationLoadingDrawioFactory is instantiated with the content provider, capability loader, and resource set passed to its constructor. Reflective contributor is added to the loading factory contributors. Transformer is created from the factory and all diagram elements are added to its list of sources. Diagram elements are transformed (mapped) to Bootstrap model elements. configure method is invoked as part of this process. The model is saved to an XML file. HTML is generated from the model using HtmlGenerator and saved to a file. https://martinfowler.com/bliki/UbiquitousLanguage.html â†© https://en.wikipedia.org/wiki/Eclipse_Modeling_Framework â†© Here and below the term &ldquo;semantic element&rdquo; is used interchangeably with the term &ldquo;target element&rdquo; to avoid confusion with connection target element. â†© Module Package Classifier Class Data type Enum Structural Feature Attribute Reference * * * Literal * * Operation * Parameter * * Metamodel Resource Set Resource Model Element * * Resource Factory URI Handler Adapter Factory Model registry Page-1",
    "timestamp": 1769516720536
  },
  "nsd-cli/nsd/model/catalog-diagram/html-app/save/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/html-app/save",
    "link-uuid": "3e1b9e17-56ed-4400-8c8d-1ffecf2223f5",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720824
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/html-app/crew-ai",
    "link-uuid": "62c81232-d864-489e-b686-267e4bb73dca",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model catalog-diagram to-model html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720845
  },
  "nsd-cli/nsd/java/junit/index.html": {
    "path": "CLI/nsd/java/junit",
    "link-uuid": "e8512b6a-47b3-470c-a789-3dc4bc30c1dd",
    "title": "junit",
    "content": "Version: org.nasdanika.models.java.cli@2025.12.0 Usage: nsd java junit [-fhVw] [--[no-]ai] [--[no-]comment-response] [--disabled] [--progress-console] [--progress-data] [--progress-json] [--api-endpoint=&lt;apiEndpoint&gt;] [--class-suffix=&lt;classSuffix&gt;] [-k=&lt;apiKey&gt;] [-l=&lt;limit&gt;] [-m=&lt;deploymentOrModelName&gt;] [--package-suffix=&lt;packageSuffix&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;prompt&gt;] [-s=&lt;sources&gt;] [-t=&lt;coverageType&gt;] [-v=&lt;apiKeyEnvironmentVariable&gt;] [-e[=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;projectURI&gt; &lt;coverageThreshold&gt; &lt;output&gt; [COMMAND] Generates JUnit tests &lt;projectURI&gt; Project URI &lt;coverageThreshold&gt; Coverage threshold &lt;output&gt; Output URI relative to the project URI --[no-]ai Use AI, defaults to true --api-endpoint=&lt;apiEndpoint&gt; OpenAPI endpoint, defaults to https://api.openai.com/v1/chat/completions --class-suffix=&lt;classSuffix&gt; Test class suffix defaults to Tests --[no-]comment-response Comment AI responses defaults to true --disabled Generate disabled tests -e, --exclude[=&lt;excludes&gt;...] Source excludes Ant pattern -f Project URI is a file path -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Source includes Ant pattern -k, --api-key=&lt;apiKey&gt; OpenAPI key -l, --limit=&lt;limit&gt; Maximum number of test classes to generate -m, --model=&lt;deploymentOrModelName&gt; OpenAPI deployment or model defaults to gpt-4 --package-suffix=&lt;packageSuffix&gt; Test package suffix defaults to .tests --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --prompt=&lt;prompt&gt; Propmt defaults to 'Generate a JUnit 5 test method leveraging Mockito for the following Java method' -s, --sources=&lt;sources&gt; Sources URI path relative to the project URIy, defaults to src/main/java -t, --coverage-type=&lt;coverageType&gt; Coverage type Valid values: complexity, instruction, branch, line defaults to line -v, --api-key-variable=&lt;apiKeyEnvironmentVariable&gt; OpenAPI key environment variable defaults to OPENAI_API_KEY -V, --version Print version information and exit. -w, --overwrite Overwrite existing tests Commands: jacoco - Loads coverage from jacoco.exec and classes directory",
    "timestamp": 1769516720806
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model",
    "link-uuid": "a93829a1-4fc8-4e85-870b-e00e5eaf5bb2",
    "title": "to-model",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram to-model [-hV] [COMMAND] Converts diagram to diagram model -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720858
  },
  "nsd-cli/nsd/drawio/html-app/index.html": {
    "path": "CLI/nsd/drawio/html-app",
    "link-uuid": "da612ddd-acf4-403c-913b-24424e89bf4e",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd drawio html-app [-fhRV] [--[no-]tooltip] [-b=&lt;base&gt;] [-P=&lt;insertionIndex&gt;] [--page=Page name] [--predicate=&lt;predicate&gt;] [-r=&lt;rootLabel&gt;] [--ref-base-uri=&lt;refBase&gt;] [-x=&lt;indexName&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-F=Invocable URI]... [--predicate-property=Predicate property]... [--protocol-resource-factory=&lt;String=Class&gt;]... [--representation-filter-property=Predicate property]... [--tag=&lt;tag&gt;]... [COMMAND] Generates html application model from a drawio document -b, --base-uri=&lt;base&gt; Base URI. E.g. 'pages/' --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -F, --representation-element-filter=Invocable URI Invocable URI of a representation element filter URIs are resolved relative to the current directory -h, --help Show this help message and exit. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --page=Page name If provided, actions are generated for the page with matching name --predicate=&lt;predicate&gt; SpEL expression for filtering diagram elements --predicate-property=Predicate property Mapping of a script language name to the property name containing predicate script in this language 'spel' is reserved for SpEL --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present --ref-base-uri=&lt;refBase&gt; Base URI for resolving documentation and prototype references. Resolved relative to the document URI --representation-filter-property=Predicate property Mapping of a script language name to the property name containing representation filter script in this language --tag=&lt;tag&gt; Tag(s) to filter diagram elements --[no-]tooltip Use tooltip as documentation if documentation is empty. Default: true -V, --version Print version information and exit. -x, --index=&lt;indexName&gt; Index file name, defaults to index.html Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Parent drawio command loads diagram.drawio diagram resource This command: Generates an html application model from the diagram elements Loads a root action from root-action.yml resource Adds the generated labels to the root action Passes the resulting model to the site sub-command to generate a documentation site Diagram element configuration Diagram elements can be configured with the following properties: child-comparator - a YAML specification for sorting child elements as explained below documentation - documentation text in documentation format doc-format - explicitly specified documentation format for documentation and doc-ref. Out of the box: markdown (default), html text doc-ref - URI of a documentation resource resolved relative to the URI of the diagram file. Documentation format is derived from the URI extension, defaulting to markdown. Use doc-format to override. icon - diagram element icon URL resolved relative to the diagram file. If there is no slash (/) in the icon name then it is treated as a CSS style, e.g. fas fa-user. For image diagram elements icons are derived from element images. It is recommended to use SVG 20x20 OR 18x18 pixels for icons because they are also used in page titles and PNG images get blurry when scaled up. parent - Connection property with values source or target. Use to generate documentation from mind maps where parent/child relationship is defined by connections, not by containment. prototype &amp; proto-ref &ndash; YAML specification of html application action, link or label. See load specifications of respective model elements for supported configuration keys. If both properties are specified, prototype takes precedence over proto-ref. With prototypes you can: Generate complex site pages (actions) with children, navigation, sections, &hellip; Reuse action models. For example, generate an action model from one diagram and use it as a prototype for an element of another diagram. Or generate an action model for CLI or Ecore documentation. role - action/page role: anonymous (default for connections) child (default for nodes) navigation section sort-key - By default generated pages (actions) are sorted alphabetically by title. This property can be used to customize sorting. If it is set then pages are sorted first by the property value and then by page title. title - By default the element label is used as page title (action text). Use this property to explicitly set the page title. For example, for elements with long labels. Site pages are generated only for elements with: Documentation (documentation or doc-ref), prototypes (prototype or prototype-ref), or both. Labels or title property. If you don&rsquo;t want an element label to be visible (e.g. on connections) uncheck &ldquo;Font color&rdquo; checkbox on the &ldquo;Text&rdquo; tab. child-comparator The specification can be a list, a string, or a map. Lists are treated as maps with null values and strings are treated as singleton maps with null values. Map entry keys are comparator names and values are configurations. The following comparators are supported: enumerate and reverse-enumerate order model elements using enumerate value. Elements without enumerate value are considered equal to any other elements including those with enumerate value. This is done to allow chaining with, say, flow comparator. As a result, this comparator will violate the transitivity requirement if some elements don&rsquo;t have enumerate value. Therefore, it shall be chained with other comparators. For example, flow and then position or label. Enumerate value is treated as path of dot-separated values and two enumerate values are compared element-by-element with elements containing only digits parsed and compared as integers. For example, 20 would be greater than 3, 1.1.1 would be greater than 1.1 and smaller than 2.5.6 or 3. Numbers are considered smaller than strings 1.12 is smaller than 1.a Practical use - ordering connections emanating from the same node. Say, excursions from the same location. If those excursions have multiple segments, then this comparator can be chained with the flow comparator and possibly terminated by the position or label comparator just in case. flow and reverse-flow order elements based on how they are connected to each other. These comparators configuration is either null, string or a list of strings. Strings are evaluated as Spring Expression Language (SpEL) boolean expressions in the context of connections. If the expression evaluates to false, then the given connection is not included in the flow traversal. It can be used if there are loops. For example, you plan a trip and want the destinations to be sorted in the visit order. There is a loop - the returning flight home. You can provide an expression which evaluates to false for that flight. position and reverse-position order elements by their position in the container&rsquo;s children list (z-order). down-right - Compares nodes by their vertical order first with higher nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. This comparator can be used for org. charts. left-down - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. left-up - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-down - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-up - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. up-left - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the right being smaller. Nodes are considered vertically equal if they vertically overlap. up-right - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. icon Drawio has more than two thousand built-in icons. You can find more icons on the below sites: Font Awesome 5 icons FlatIcons - 16.8 million icons. Free with attribution, a paid plan is available - no attribution. In-browser editor. PNG and SVG (premium) formats. IconFinder - the world&rsquo;s largest marketplace for icons, &hellip; 6 million icons at your fingertips including free icons. Multiple subscription levels. Iconduck - more than 250 000 free open source icons Techicons - SVG and PNG tech icons, sourced from https://github.com/devicons/devicon. 473 icons. Cloud providers: Azure AWS prototype If your top-level diagram page is generated as a principal action and the root action or link references some external site, e.g. your company site, then you need to use the following prototype for proper generation: Action:\n  location: ${base-uri}index.html\n Below is an example of a prototype which defines a navigation action: Action:\n    navigation:\n      - Action:\n          location: about-wendy.html\n          icon: fas fa-help\n          text: About\n          content:\n            Interpolator:\n              source:\n                exec.content.Text: |    \n                  This is an example of a page from an action prototype.\n proto-ref Property value is a URI of the prototype action or label resolved relative to the element base URI. For example bob-prototype.yml#/. Element ID Element IDs are used to construct element page URLs. Element IDs are generated as long random strings. They are editable - double-click on the ID at the top of the data dialog. So, if you&rsquo;d like to have semantic URLs - customize the IDs. Page and element links You may link elements to pages and other element using the extended link syntax. When an element links to a page, the page root1 is logically merged with the linking element and page elements (except elements liking to other elements) become logical children of the linking element. If an element links to another element, then that element is not considered a logical child of the page/root/page linking element. The link chain is traversed and the diagram element on the generated site is linked to the page of the link target element if that element has a page (i.e. it is documented). Otherwise there is no link. Multiple top-level pages A top-level diagram page is a page that is not linked from any diagram element. If there is more than one top-level page, add a principal action to the root-action.yml and link pages to the principal action. Examples: Beyond Diagrams Illustrations Declarative Command Pipelines See Drawio API â†© Options -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx. -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.   You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.",
    "timestamp": 1769516720729
  },
  "core/capability/index.html": {
    "path": "Core/Capability",
    "link-uuid": "a88fe016-f9a5-405c-8882-113501b62fce",
    "title": "Capability",
    "content": "Nasdanika Capability framework allows to discover/load capabilities which meet a requirement. Capabilities are provided by CapabilityFactory create() method. Capability factories may request other capabilities they need. As such, capabilities can be chained. Factories create CapabilityLoaders which provide Flux reactive streams of capabilities. It allows to have an infinite stream of capabilities which are consumed (and produced) as needed. Capability providers may furnish additional information about capabilities. This information can be used for filtering or sorting providers. Capability providers may also provide functionality such as: Implement Autocloseable and release resources associated with capabilities upon closing. Implement Lock or ReadWriteLock to guard access to provided capabilities. Extending on the above, a capability provider may implement Domain/Realm with a command stack - obtain, execute commands with locking, close. A non-technical example of requirement/capability chain graph is a food chain/graph. Food is a requirement. Or &ldquo;I want to eat&rdquo; is a requirement. Bread and, say fried eggs are two capabilities meeting/addressing the requirement. Bread requires &ldquo;wheat&rdquo;, &ldquo;water&rdquo;, and &ldquo;bake&rdquo; capabilities. Fried eggs require &ldquo;egg&rdquo;, &ldquo;oil&rdquo;, and &ldquo;fry&rdquo; capabilities. &ldquo;bake&rdquo; capability is provided by an oven which may have a command stack or a lock because only one thing can be baked at a time. Bread capability provider may implement Vegan marker interface which can be used for filtering. All food capabilities may implement NutritionalInformation interface - it can be used for filtering or sorting. A more technical example is Java ServiceLoader with service type being a requirement and an instance of the service class being a capability. Nasdanika capability framework can operate on top of ServiceLoader and may be thought of as a generalization of service loading. In essence, the capability framework is a backward chaining engine as shown in one of the examples below. Sources Javadoc Client code - requesting a capability Service capabilities Providing a capability Loading Invocables from URIs Examples String value URL encoded URL and Base64 encoded Java Constructor Static method @Parameter annotation Script Spec JSON YAML Drawio diagram Specification URI Data value/ java/ spel/ application//invocable Hierarchical YAML/JSON specification EMF Requesting a ResourceSet With all packages and factories Selecting contributors Providing ResourceSet instance Contributing EPackages Resource factories URI handlers Loading configuration Examples Untyped default configuration for the caller module Untyped default configuration for a specific module Global typed configuration Named typed requirement Named untyped requirement Applications Services Solutions for architectures Backward chaining Stream processing AI model training/fine-tuning Client code - requesting a capability Capabilities are loaded by CapabilityLoader. Capability loader can take an iterable of capability factories in its constructor, or it can load them using ServiceLoader as shown in the below code snippet: CapabilityLoader capabilityLoader = new CapabilityLoader();\ncapabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\t\t\nfor (CapabilityProvider&lt;?&gt; cp: capabilityLoader.load(new TestCapabilityFactory.Requirement(&quot;Hello World&quot;), progressMonitor)) {\n\tSystem.out.println(cp);\n\tFlux&lt;?&gt; publisher = cp.getPublisher();\n\t\t\t\n\tpublisher.subscribe(System.out::println);\n}\n Factories can also be added post-construction with getFactories().add(factory). Service capabilities Service requirements and capabilities provide functionality similar to ServiceLoader - requesting instances of specific type, but extend it with ability to provide additional service requirement. This functionality is provided by ServiceCapabilityFactory and ServiceCapabilityFactory.Requirement. CapabilityLoader capabilityLoader = new CapabilityLoader();\ncapabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\t\t\n@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })\nServiceCapabilityFactory.Requirement&lt;List&lt;Double&gt;, Double&gt; requirement = (ServiceCapabilityFactory.Requirement) ServiceCapabilityFactory.createRequirement(List.class, null,  33.0);\nfor (CapabilityProvider&lt;?&gt; cp: capabilityLoader.load(requirement, progressMonitor)) {\n\tSystem.out.println(cp);\n\tFlux&lt;?&gt; publisher = cp.getPublisher();\n\t\t\t\n\tpublisher.subscribe(System.out::println);\n}\n It is also possible to load services from ServiceLoader using subclasses of Service. You&rsquo;d need to subclass ServiceFactory in a module which uses a particular service and override stream(Class&lt;S&gt; service) method as shown below: @Override\nprotected Stream&lt;Provider&lt;S&gt;&gt; stream(Class&lt;S&gt; service) {\n\treturn ServiceLoader.load(service).stream();\n}\n Then you&rsquo;d need to add the factory to the loader: capabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\n Providing a capability As it was mentioned above, capability factories can be explicitly added to CapabilityLoader or loaded using ServiceLoader. Below is an example of a capability factory: public class TestCapabilityFactory implements CapabilityFactory&lt;TestCapabilityFactory.Requirement, Integer&gt; {\n\t\n\tpublic record Requirement(String value){};\n\t\n\t@Override\n\tpublic boolean canHandle(Object requirement) {\n\t\treturn requirement instanceof Requirement;\n\t}\n\n\t@Override\n\tpublic CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Integer&gt;&gt;&gt; create(\n\t\t\tRequirement requirement,\n\t\t\tBiFunction&lt;Object, ProgressMonitor, CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Object&gt;&gt;&gt;&gt; resolver,\n\t\t\tProgressMonitor progressMonitor) {\n\t\t\n\t\treturn resolver.apply(MyService.class, progressMonitor).thenApply(cp -&gt; {;\n\t\t\t@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })\n\t\t\tFlux&lt;MyService&gt; myServiceCapabilityPublisher = (Flux) cp.iterator().next().getPublisher();\n\t\t\t\n\t\t\treturn Collections.singleton(new CapabilityProvider&lt;Integer&gt;() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic Flux&lt;Integer&gt; getPublisher() {\n\t\t\t\t\tFunction&lt;MyService, Integer&gt; mapper = ms -&gt; ms.count(((Requirement) requirement).value());\n\t\t\t\t\treturn myServiceCapabilityPublisher.map(mapper);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t});\n\t}\n\n}\n There is a number of implementations of CapabilityFactory is different Nasdanika modules, most of them extending ServiceCapability. In Eclipse or other IDE open CapabilityFactory type hierarchy to discover available implementations. Loading Invocables from URIs The capability framework allows to create/load implementations of Invocable from URIs: In conjunction with the Maven module implementations can be loaded from Maven repositories. Invocables can be implemented in scripting languages, e.g. Groovy. Scripts may use dependencies loaded from Maven repositories. Script engine themselves can be loaded from Maven repositories. Drawio diagrams can be made executable by adding invocable URI properties to diagram elements. They can then be wrapped into a dynamic proxy and invocable URI&rsquo;s. Examples String value URL encoded data:value/String,Hello+World data URL is converted to an Invocable which takes zero arguments and returns URL-decoded data part of the URL (after comma). CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:value/String,Hello+World&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n URL and Base64 encoded data:value/String;base64,SGVsbG8= is converted to an Invocable which takes zero arguments and returns URL-decoded and then Base64 decoded data part converted to String. CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:value/String;base64,SGVsbG8=&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n Java Constructor data:java/org.nasdanika.capability.tests.MyTestClass;base64,SGVsbG8= is converted to an Invocable which invokes MyTestClass constructor. CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:java/org.nasdanika.capability.tests.MyTestClass;base64,SGVsbG8=&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n In the above code snippet invocable is invoked with no arguments, which matches the below constructor passing the decoded data part of the URL in binding argument: public MyTestClass(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor progressMonitor, \n\t\tbyte[] binding,\n\t\tString fragment) {\n\t...\n}\t\n The below snippet passes 33 argument to invoke(): CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:java/org.nasdanika.capability.tests.MyTestClass;base64,SGVsbG8=&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke(33);\nSystem.out.println(result);\n Which matches the below constructor: public MyTestClass(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor progressMonitor, \n\t\tbyte[] binding, \n\t\tint arg) {\n\t...\n}\n 33 is passed via the arg argument. Static method Static methods can be addresed by adding :: and method name after the class name as in this URL: data:java/org.nasdanika.capability.tests.MyTestClass::factory;base64,SGVsbG8=. The resulting Invocable will select the best matching factory method. CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:java/org.nasdanika.capability.tests.MyTestClass::factory;base64,SGVsbG8=&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n In the above code snippet invoke() has no arguments and therefore the below method matches: public static MyTestClass factory(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor progressMonitor, \n\t\tbyte[] binding) {\n\t...\n}\n As with constructors, the decoded data part is passed to the method as binding argument. In the below snippet invoke() takes 55 argument: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createURI(&quot;data:java/org.nasdanika.capability.tests.MyTestClass::factory;base64,SGVsbG8=&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke(55);\nSystem.out.println(result);\n Which matches the below method: public static MyTestClass factory(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor progressMonitor, \n\t\tbyte[] binding,\n\t\tint arg) {\n\t...\n}\n @Parameter annotation Parameter annotation can be used on method and constructor parameters to provide parameter name and optionally narrow parameter type. Script The below snippet exectutes test.groovy script in the current directory. ScriptEngineManger is used to get a ScriptEngine by extension. Therefore, the engine factory shall be registered with the script engine manager. CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createFileURI(new File(&quot;test.groovy&quot;).getCanonicalPath());\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n This is the test script: import org.nasdanika.capability.CapabilityFactory.Loader\nimport org.nasdanika.common.ProgressMonitor\n\n// Script arguments for reference\nLoader loader = args[0];\nProgressMonitor loaderProgressMonitor = args[1];\nObject data = args[2];\n\nSystem.out.println(args);\n&quot;I've got &quot; + args.length + &quot; arguments!&quot;\n Similar to Java constructors and static methods, it takes the following arguments: CapabilityFactory.Loader to request additional capabilities if needed ProgressMonitor to report progress and pass to the loader methods URI&rsquo;s fragment value or null Invocable arguments In the below code the script receives Hello as its third argument (binding) and Universe as its fourth argument: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI requirement = URI.createFileURI(new File(&quot;test.groovy&quot;).getCanonicalPath()).appendFragment(&quot;Hello&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, requirement),\n\t\tprogressMonitor);\nObject result = invocable.invoke(&quot;Universe&quot;);\nSystem.out.println(result);\n Spec Spec URI&rsquo;s allow to specify Maven dependencies to construct a ClassLoader for loading Java classes including script engine factories. It is also to specify a module path to construct a module layer. JSON CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI specUri = URI.createFileURI(new File(&quot;test-specs/java.json&quot;).getCanonicalPath()).appendFragment(&quot;Hello+World&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, new URIInvocableRequirement(specUri)),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n The above snippet uses the below spec to create an instance of MyTestClass: {\n\t&quot;type&quot;: &quot;org.nasdanika.capability.tests.MyTestClass&quot;,\n\t&quot;bind&quot;: [\n\t\t&quot;data:value/String,Some+other+value&quot;\n\t]\n}\t\n Similar to data URL&rsquo;s a matching constructor is found for the following arguments: CapabilityFactory.Loader ProgressMonitor String - URL decoded URI fragment, may be null Bindings loaded from the bind array of URI&rsquo;s Below is the matching constructor: public MyTestClass(\n\t\tCapabilityFactory.Loader loader, \n\t\tProgressMonitor progressMonitor, \n\t\tString fragment,\n\t\tString bind) {\n\t...;\n}\t\n YAML CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor(true);\nURI specUri = URI.createFileURI(new File(&quot;test-specs/groovy.yml&quot;).getCanonicalPath()).appendFragment(&quot;Hello+World&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, new URIInvocableRequirement(specUri)),\n\t\tprogressMonitor);\nObject result = invocable.invoke();\nSystem.out.println(result);\n The above snippet executes Groovy script specified inline in the below YAML: script:\n  engineFactory: org.codehaus.groovy.jsr223.GroovyScriptEngineFactory\n  source: |\n    &quot;Hello, world! &quot; + myBinding + &quot; &quot; + args[2]\n  bindings:\n    myBinding: data:value/String,Some+value\ndependencies: org.apache.groovy:groovy-all:pom:4.0.23\nlocalRepository: target/groovy-test-repo\n In this case org.apache.groovy:groovy-all:pom:4.0.23 Maven coordinates are used to load Groovy with all dependencies and construct a ClassLoader. Because the engine was loaded at runtime, it is not known to the ScriptEngineManager and has to be explicitly specified. The script gets an args array with loader, progress monitor, decoded fragment and arguments passed to invoke(). It also gets named bindings loaded from the bindings map entries. Drawio diagram Below is a YAML spec with an embedded diagram: diagram:\n  source: |\n    &lt;mxfile ...abridged... &lt;/mxfile&gt;\n  processor: processor\n  bind: bind\n  interfaces: java.util.function.Function\n And this is a YAML specification which references a diagram: diagram:\n  location: diagram.drawio\n  processor: processor\n  bind: bind\n  interfaces: java.util.function.Function\n The below code loads the spec, passes the fragment to the diagram as properties in addition to the properties from the spec, creates a dynamic proxy which invokes diagram element processors, and uses the proxy to execute the diagram logic: CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nURI specUri = URI.createFileURI(new File(&quot;diagram-function.yml&quot;).getCanonicalPath()).appendFragment(&quot;my-property=Hello&quot;);\nInvocable invocable = capabilityLoader.loadOne(\n\t\tServiceCapabilityFactory.createRequirement(Invocable.class, null, new URIInvocableRequirement(specUri)),\n\t\tprogressMonitor);\nFunction&lt;String,Object&gt; result = invocable.invoke();\nSystem.out.println(result);\nSystem.out.println(result.apply(&quot;YAML&quot;));\n See Capability tests and Executable Diagrams Dynamic Proxy demo for more examples. Specification URI This section explains supported URI formats. Please note that using a custom URIHandler you may: Normalize &ldquo;logical&rdquo; URI&rsquo;s to supported &ldquo;physical&rdquo; URI&rsquo;s. Implement openStream() For example normalized my-building-blocks://gen-ai/chat-completions to a specification of a chat completions component, say, gitlab://my-shared-components/open-ai/chat-completions.yml and then implement openStream() which supports gitlab scheme[^gitlab_urihandler] Data Data URI has the following format: data:[&lt;mediatype&gt;][;base64],&lt;data&gt;[#fragment]. The following sections describe supported media types. value/ an instance of the class is constructed from the data part bytes, fragment is ignored. if the class name does not contain dots then java.lang. prefix is added to the class name. Examples: * data:value/String,Hello+World * data:value/String;base64,SGVsbG8= java/ Class constructors or static methods are wrapped into an Invocable and the matching constructor/method is invoked from the resulting Invocable.invoke(). Constructors/methods shall have the following signature: CapabilityFactory.Loader to request additional capabilities if needed ProgressMonitor to report progress and pass to the loader methods byte[] - the data part String - fragment Optional additional parameters for arguments passed to the result Invocable Examples: data:java/org.nasdanika.capability.tests.MyTestClass;base64,SGVsbG8=#World data:java/org.nasdanika.capability.tests.MyTestClass::factory;base64,SGVsbG8= spel/ Evaluates a Spring Expression Langauge (SpEL) expression. Binding by name sets variables. Arguments array is passed to the expression as the root object. It the array is of size 1 then its single element is used as the root object. Example: data:spel/%23myVar+%2B+%23this This online URL Decoder/Encoder can be used to encode expressions. application//invocable With format being either yaml or json. YAML or JSON specification (see below) encoded into the data part. Example: data:application/yaml/invocable;base64,c2Nya...abridged...1yZXBv Hierarchical If the hierarchical URI&rsquo;s last segment ends with .yml or .yaml (case insensitive) it is treated as a YAML specification (see below). If the last segment ends with .json (also case insensitive) it is treated as a JSON specification. Otherwise a script engine is looked up by extension (the part of the last segments after the last dot). E.g. groovy. Scripts receive args binding (variable) of type Object[] with the following elements: CapabilityFactory.Loader to request additional capabilities if needed ProgressMonitor to report progress and pass to the loader methods String - fragment Arguments passed to the result Invocable YAML/JSON specification YAML/JSON specification is pre-processed and then loaded into InvocableRequirement. The specification supports the following configuration entries: diagram - Map, loaded into DiagramRecord: location - String, URI of the diagram location relative to the specification location. source - String, diagram source. Either location or source shall be used. base - String, base URI if source is used properties - Map, properties to pass to the diagram. Nested properties can be addressed using &ldquo;.&rdquo; (dot) separator. For arrays index is used as key. E.g. people.3.name. If URI fragment is present it is parsed into name/value pairs in the same way as query strings are parsed. Fragment properties overwrite spec properties. processor - optional String, property to load processor specifications from. One diagram element may have multiple processor specifications in different properties. Also, property expansion can be used to customize processor specification. E.g. %env%/storage.yaml would point to different specifications depending on the value of %env% property. bind - optional String, property for a dynamic proxy method name or signature interfaces - optional String or List, dynamic proxy interfaces type - String, class name or method reference is ends with ::&lt;static method name&gt; script - Map, loaded into ScriptRecord: location - String, URI of script sources source - String, script source. Either location or source shall be used language - String, script language (mime type) for source. For location if language is not specified it is derived from extension. engineFactory - String, fully qualified name of a script engine factory implementation. Use if the engine is loaded from dependencies and therefore is not visible to the script engine manager. If engineFactory is specified language and location extension are ignored. bindings - Map, values are treated as Invocable URIs providing binding values. Loader, progress monitor, fragment and invocable arguments are available to the script via the args binding of type Object[]. bind - String or List, Invocable URIs to bind to the type Invocable. Not supported by diagram and script. modulePath - optional String or List, module path. If null, derived from root modules if they are present rootModules - optional String or List, root modules. The first root module is used to obtain the class loader oneLayerClassLoader - optional boolean indicating whether a single class loader shall be used for all modules in in the layer dependencies - optional String or List of dependencies in &lt;groupId&gt;:&lt;artifactId&gt;[:&lt;extension&gt;[:&lt;classifier&gt;]]:&lt;version&gt;} format. E.g. org.apache.groovy:groovy-all:pom:4.0.23 managedDependencies - optional String or List of dependencies in &lt;groupId&gt;:&lt;artifactId&gt;[:&lt;extension&gt;[:&lt;classifier&gt;]]:&lt;version&gt;} format remoteRepositories - Map (single remote repository) or List of Maps of remote repository definitions loaded into RemoteRepoRecord: id - String, repo ID type - String, optional repo type url - String, repository URL proxy - optional Map: type - String, http or https host - String port - integer auth - authentication (see below) auth - Map: username - String password - String mirroredRepositories - Map or List, mirrored repositories localRepository - optional String, path to the local repository to download dependencies to. Defaults to repository. Maven dependency resolution uses default values as explained in the Maven module documentation. diagram, type and script are mutually exclusive. Note: extends key is reserved for future releases to support spec inheritance. Configuration is pre-pThe by interpolating system properties and environment variables. E.g. ${my-property} will be expanded to the value of my-property system property if it is set. Respectively, ${env.MY_ENV_VAR} will be expanded to the value of MY_ENV_VAR environment variable if it is set. Property expansion can be escaped with additional {} e.g. ${my-property} will be expanded to ${my-property} regardless of whether my-properety system property is set or not. EMF Many of Nasdanika capabilities are based on Eclipse Modeling Framework (EMF)1, Ecore2 models in particular. One of key objects in EMF Ecore is a ResourceSet. Resource set has a package registry, resource factory registry, and URI converter. org.nasdanika.capability.emf packages provides capability factories for contributing to resource set. It allows to request resource set from a capability loader and the returned resource set would be configured with registered EPackages, resource factories, adapter factories and URIHandlers. Requesting a ResourceSet With all packages and factories CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\nRequirement&lt;ResourceSetRequirement, ResourceSet&gt; requirement = ServiceCapabilityFactory.createRequirement(ResourceSet.class);\t\t\nfor (CapabilityProvider&lt;?&gt; capabilityProvider: capabilityLoader.load(requirement, progressMonitor)) {\n\tResourceSet resourceSet = (ResourceSet) capabilityProvider.getPublisher().blockFirst();\n}\n Selecting contributors CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\nPredicate&lt;ResourceSetContributor&gt; contributorPredicate = ...;\nResourceSetRequirement serviceRequirement = new ResourceSetRequirement(null, contributorPredicate);\n\t\t\nRequirement&lt;ResourceSetRequirement, ResourceSet&gt; requirement = ServiceCapabilityFactory.createRequirement(ResourceSet.class, null, serviceRequirement);\t\t\n\nfor (CapabilityProvider&lt;?&gt; capabilityProvider: capabilityLoader.load(requirement, progressMonitor)) {\n\tResourceSet resourceSet = (ResourceSet) capabilityProvider.getPublisher().blockFirst();\n}\n Providing ResourceSet instance You may provide an instance of ResourceSet to configure in the requirement. Contributing EPackages Create a class extending EPackageCapabilityFactory: public class NcoreEPackageResourceSetCapabilityFactory extends EPackageCapabilityFactory {\n\n\t@Override\n\tprotected EPackage getEPackage() {\n\t\treturn NcorePackage.eINSTANCE;\n\t}\n\n\t@Override\n\tprotected URI getDocumentationURI() {\n\t\treturn URI.createURI(&quot;https://ncore.models.nasdanika.org/&quot;);\n\t}\n\n}\n and add it to module-info.java provides: provides CapabilityFactory with NcoreEPackageResourceSetCapabilityFactory;\n Resource factories Create a class extending ResourceFactoryCapabilityFactory: public class XMIResourceFactoryCapabilityFactory extends ResourceFactoryCapabilityFactory {\n\n\t@Override\n\tprotected Factory getResourceFactory() {\n\t\treturn new XMIResourceFactoryImpl();\n\t}\n\t\n\t@Override\n\tprotected String getExtension() {\n\t\treturn Resource.Factory.Registry.DEFAULT_EXTENSION;\n\t}\n\n}\n and add it to module-info.java provides CapabilityFactory. URI handlers Create a class extending URIConverterContributorCapabilityFactory: public class ClassPathURIHandlerResourceSetCapabilityFactory extends URIConverterContributorCapabilityFactory {\n\n\t@Override\n\tprotected void contribute(URIConverter uriConverter, ProgressMonitor progressMonitor) {\t\n\t\turiConverter.getURIHandlers().add(0, new URIHandlerImpl() {\n\n\t\t\t@Override\n\t\t\tpublic boolean canHandle(URI uri) {\n\t\t\t\treturn uri != null &amp;&amp; Util.CLASSPATH_SCHEME.equals(uri.scheme());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic InputStream createInputStream(URI uri, Map&lt;?, ?&gt; options) throws IOException {\n\t\t\t\treturn DefaultConverter.INSTANCE.toInputStream(uri);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\t\n}\n and add it to module-info.java provides CapabilityFactory. Loading configuration org.nasdanika.capability.ConfigurationRequirement can be used to load configuration resources/files. Its canonical constructor takes: Module name Configuration name Configuration type All the above elements can be null. There is also a number of &ldquo;shortcut&rdquo; constructors. The base configuration name is config it can be changed by setting org.nasdanika.config.base system property. If the module name is not null or blank then it is appended to the base configuration name separated with a slash (/). If the configuration name is not null or blank then it is also appended to the base configuration name separated with a slash. After that .yml, .yaml, .json extensions are appended in order to the configuration name is used to create a URL which is then resolved relative to the current directory. Then an attempt is made to load YAML or JSON (depending on the extension) from the resulting URL. If there is a configuration resource and configuration type is null, then Function&lt;String,Object&gt; is returned. If there is no configuration resource, then an &ldquo;empty&rdquo; function is returned - it always returns ``null`. If configuration type is not null, then it is instantiated by wrapping the configuration class into [Invocable]((https://javadoc.io/doc/org.nasdanika.core/common/latest/org.nasdanika.common/org/nasdanika/common/Invocable.html) with Invocable.of(Class) method and then invoking its call(Map) method with loaded YAML or JSON converted to map or with an empty map if there are no configuration resources3. Examples Untyped default configuration for the caller module CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n    \nConfigurationRequirement req = new ConfigurationRequirement();\nFunction&lt;String,Object&gt; config = capabilityLoader.loadOne(req, progressMonitor);\n For org.myorg.mymodule module configuration would be loaded from the first available resource in the below list: config/org/myorg/mymodule.yml config/org/myorg/mymodule.yaml config/org/myorg/mymodule.json Untyped default configuration for a specific module CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n    \nConfigurationRequirement req = new ConfigurationRequirement(getClass().getModule());\nFunction&lt;String,Object&gt; config = capabilityLoader.loadOne(req, progressMonitor);\n Global typed configuration CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n    \nConfigurationRequirement req = new ConfigurationRequirement((String) null, &quot;global&quot;, ConfigRecord.class);\nConfigRecord config = capabilityLoader.loadOne(req, progressMonitor);\n In the above snippet configuration is loaded from config/global.&lt;extension&gt; resource where extension is yml, yaml or json. If the second requirement constructor parameter was null, then resource name would be config.&lt;extension&gt;. Named typed requirement CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n    \nConfigurationRequirement req = new ConfigurationRequirement(ConfigRecord.class);\nConfigRecord config = capabilityLoader.loadOne(req, progressMonitor);\n Named untyped requirement CapabilityLoader capabilityLoader = new CapabilityLoader();\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n    \nConfigurationRequirement req = new ConfigurationRequirement(&quot;my-app&quot;);\nFunction&lt;String,Object&gt; config = capabilityLoader.loadOne(req, progressMonitor);\n Applications Services Service capabilities explained above a used by Graph and Function Flow for loading node processors and connection processors for a specific requirement using NodeProcessorFactory and ConnectionProcessorFactory respectively. For example, code generation, execution, simulation. Solutions for architectures One of future application of the capability framework is creation a list of solution alternatives for an architecture/pattern. For example, there might be multiple RAG embodiments with different key types, key extractors, stores, &hellip; Some of &ldquo;design dimensions&rdquo; are listed below: Key type: Bag of words. Multiple options - just words, words with frequency, tokenized words, word stems. Embedding vector - different embedding models, different dimensions. Store - multiple stores for multiple key types. Multiple indexing and retrieval methods. Chunk size, chunk overlap, chunking algorithm. Generator - multiple models and prompts As you can see a number of potential combinations can easily go into thousands or even be infinite. Reactive approach with filtering and sorting may be helpful in selecting a solution which is a good fit for a particular use case - number and type of data sources etc. For example, if the total size of data is under a few gigabytes an in-memory store may be a better choice than, say, an external (vector) database. Also an old good bag of words might be better than embeddings. E.g. it might be cheaper. Solution alternatives may include temporal aspect or monetary aspects. For example, version X of Y is available at time Z. Z might be absolute or relative. Say, Z days after project kick-off or license fee payment. Identified solutions meeting requirements can have different quality attributes - costs (to build, to run), timeline, etc. These quality attributes can be used for solution analysis. E.g. one solution can be selected as a transition architecture and another as the target architecture. Backward chaining Family reasoning demonstrates application of the capability framework as a backward chaining engine. Family relationships such as grandfather and cousin are constructed by requiring and combining relationships such as child and sibling. Stream processing This possible application is similar to backward reasoning. Imagine an algorithmic trading strategy which uses several technical indicators, such as moving averages, to make trading decisions. Such a strategy would submit requirements for technical indicators which would include symbol, indicator configuration, time frame size. Technical indicators in turn would submit a requirement for raw trading data. A technical indicator such as moving average would start publishing its events once it receives enough trading data frames to compute its average. A trading engine would submit a requirement for strategies. A strategy factory may produce multiple strategies with different configurations. The trading engine would perform &ldquo;paper&rdquo; trades, select well-performing strategies and discard ones which perform poorly. This can be an ongoing process - if a strategy deteriorates then it is discarded and a new strategy is requested from strategy publishers - this process can be infinite. AI model training/fine-tuning This application is similar to stream processing and may be combined with backward reasoning. Let&rsquo;s say we want to train a model to answer questions about family relationships for a specific family. For example, &ldquo;Who is Alan&rsquo;s great grandmother?&rdquo; A single relationship in the model can be expressed in multiple ways in natural language. And multiple relationships can be expressed in a single sentence. For example: Elias is a person Elias is a man Elias is a male Elias is a parent of Fiona Fiona is a child of Elias Elias is a father of Fiona Fiona is a daughter of Elias Paul and Isa are parents of Lea and Elias &hellip; So, on top of a model there might be a collection of text generators. Output of those generators can be fed to a model: Supervised - question and answer &ldquo;How many sisters does Bryan have?&rdquo; - &ldquo;Two&rdquo; &ldquo;Who are Bryan&rsquo;s sisters?&rdquo; - &ldquo;Clara and Fiona&rdquo; Unsupervised - factual statements A similar approach can be applied to other models - customer/accounts, organization or architecture model, etc. For example, from the Internet Banking System we can generate something like &ldquo;Accounts Summary Controller uses Mainframe Banking System Facade to make API calls to the Mainframe Banking System over XML/HTTPS&rdquo;. &ldquo;make API calls&rdquo; may also be generated as &ldquo;connect&rdquo; or &ldquo;make requests&rdquo;. In a similar fashion a number of questions/answers can be generated. See Eclipse Modeling Framework (EMF) - Tutorial and EMF Eclipse Modeling Framework book for more details. â†© See EMF Ecore chapter in Beyond Diagrams book for a high-level overview of EMF Ecore. â†© See Loading Java records from Map, YAML, JSON, &hellip; Medium story for additional information about loading records from YAML and JSON. â†©",
    "timestamp": 1769516720184
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/html-app/crew-ai",
    "link-uuid": "678679a6-69c4-4c23-9f9c-feed95c824b6",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720913
  },
  "nsd-cli/nsd/drawio/to-model/html-app/site/index.html": {
    "path": "CLI/nsd/drawio/to-model/html-app/site",
    "link-uuid": "57548142-6711-4b0c-98cd-f9d2a2aa43fb",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd drawio to-model html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720759
  },
  "core/graph/index.html": {
    "path": "Core/Graph",
    "link-uuid": "140ab739-f448-4409-a5f3-751c21659416",
    "title": "Graph",
    "content": "Nasdanika Graph module provides classes for visiting and processing graphs with two types of relationships between graph elements: Containment - one element is contained by another Connection - one element (node) connecting to another node via a connection. On the diagram below containment relationships are shown in bold black and connections in blue Examples of such graphs: A file system with directories containing files and other directories. Connections may take multiple forms such as symbolic links or files, e.g. HTML files, referencing other files. Organizational structure with a hierarchy of organizational units and connections between them. For example, one unit may pass work product to another unit, or a unit may provide services to other units. Country, state, county, city, street, house, people living in that house; family relationships between people and ownership relationships between people and houses. Diagrams, such as Drawio diagrams with a diagram file (resource) containing a Document which contains pages, pages containing layers, and layers containing nodes and connections. Nodes may be nested. Nasdanika Drawio is a module for working with Drawio diagrams. It is built on top of this module. Processes/(work)flows - processes consist of activities and nested processes. Activities are connected by transitions. Distributed systems, such as cloud solutions - availability zones, data centers, clusters, nodes, pods, containers, processes inside containers. All of them communicating to each other via network connections. Work hierarchy and dependencies - in issue trackers issues may be organized into a hierarchy (e.g. Initiative, Epic, Story, Sub-Task in Jira) and have different types of dependencies. In Java a jar contains packages containing sub-packages and classes. Classes contain fields and methods. Fields reference their types, methods call methods of other classes, &hellip; EMF Ecore models contain packages. Packages contain sub-packages and classifiers including classes. Classes contain references to other classes. References may be configured as containment (composition) or non-containment. Resources Graph API Processing Dispatching Processors and processor factories Reflection ReflectiveProcessorFactoryProvider Capability Wiring Resources Sources Javadoc Medium stories: General purpose executable graphs and diagrams Concurrent Executable Diagrams Executable (computational) graphs &amp; diagrams Graph API The graph API has 3 interfaces: Element is a super-interface for Connection and Node below. Elements may contain other elements. Containment is implemented with &lt;T&gt; T accept(BiFunction&lt;? super Element, Map&lt;? extends Element, T&gt;, T&gt; visitor), which can be thought of as a hierarchical bottom-up reduce - the visitor function is invoked with an element being visited as its first argument and a map of element&rsquo;s children to results returned by the visitor as the second argument. For leaf elements the second argument may be either an empty map or null. Depending on the map type used by implementations they may also need to implement equals() and hashCode(). Node extends Element and may have incoming and outgoing connections. Connection extends Element and has source and target nodes. Processing Graph processing means associating some behavior with graph elements. That behavior (code execution) may modify the graph or perform other actions. Examples of graph processing: Generate code (HTML site) from a diagram. Demos: Internet Banking System Sample Family Living beings Update a diagram with information from external source. For example, there might be a diagram of a (software) system. Diagram elements can be updated as follows: During development - colors may reflect completion status. Say, in progress elements in blue, completed elements in green, elements with issues in red or amber. In production - color elements based on their monitoring status. Offline - grey, good - green, overloaded - amber, broken - red. The above two examples may be combined - a documentation site might be generated from a system diagram. The diagram may be updated with statuses as part of the generation process and embedded to the home page. A click on a diagram element would navigate to an element documentation page, which may contain detailed status information pulled from tracking/monitoring systems during generation. Dispatching One form of graph processing is dispatching of graph elements to Java methods annotated with Handler annotation. The annotation takes a Spring boolean expression. Graph elements are passed to methods for which the expression is blank or evaluates to true. Below is a code snippet from AliceBobHandlers class: @Handler(&quot;getProperty('my-property') == 'xyz'&quot;)\npublic String bob(Node bob) {\n\tSystem.out.println(bob.getLabel());\n\treturn bob.getLabel();\n}\n Below is a test method from TestDrawio.testDispatch() test method which dispatches to the above handler method: Document document = Document.load(getClass().getResource(&quot;alice-bob.drawio&quot;));\n\t\t\nAliceBobHandlers aliceBobHandlers = new AliceBobHandlers();\t\t\nObject result = document.dispatch(aliceBobHandlers);\nSystem.out.println(result);\n Dispatching is suitable for processing where processing logic for different graph elements does not need to access processing logic of other elements. An example of such logic would be updating diagram elements based on statuses retrieved from tracking/monitoring systems - each element is updated individually. Processors and processor factories Processor package provides means for creating graph element processors and wiring them together so they can interact. One area of where such functionality would be needed is executable diagrams. For example, a flow processor/simulator. Activity processors would need to pass control to connected activities via connection processors. Activity processors may also need to access facilities of their parent processors. The below diagram shows interaction of two nodes via a connection. Connections are bi-directional - source processor may interact with the target processor and vice versa. Some connections may be &ldquo;pass-through&rdquo; - just passing interactions without doing any processing. A pass-through connection is depicted below. Graph element processors are wired together with Synapses which accept a handler and provide an endpoint completion stage: A handler is a java object provided by calling Synapse.setHandler() method receiving interactions via endpoints. An endpoint is a java object provided by Synapse.getEndpoint() for interacting with a handler. An endpoint may be of the same type as a handler or a handler may be used as an endpoint. This might be the case if processing is performed sequentially in a single JVM. Alternatively, an endpoint may be of different type than the handler it passes interactions to. For example: Endpoint methods may return Futures or CompletionStages of counterpart handler methods - when an endpoint method is invoked it would invoke handler&rsquo;s method asynchronously. Endpoint methods may take different parameters. E.g. an endpoint method can take InputStream, save it to some storage and pass a URL to the handler method. Processors can also interact by looking up other processors in the processor registry. Endpoints are created by implementations Processors are created in two steps: Processor configs are created by subclasses of ProcessorConfigFactory, e.g. NopEndpointProcessorConfigFactory Processors are created from configs by subclasses of ProcessorFactory overriding createProcessor() method. Client code creates processors by calling createProcessors() method. This method return a registry - Map&lt;Element,ProcessorInfo&lt;P&gt;&gt;. The registry allows the client code to interact with the handler/endpoint/processor wiring created from the graph. TestDrawio.testProcessor() method provides an example of using an anonymous implementation of NopEndpointProcessorFactory for graph processing. Reflection A good deal of processor creation logic is selection of a processor to create for a given graph element in a given situation/context and then &ldquo;wiring&rdquo; configuration to the processor. There are two processor factory classes and ReflectiveProcessorWirer class which make the selection/matching/wiring process easier. ReflectiveProcessorFactoryProvider ReflectiveProcessorFactoryProvider invokes methods annotated with Processor annotation to create processors. SyncProcessorFactory is an example of reflective processor factory. Below is one of factory methods: @Processor(\n\ttype = NodeAdapter.class,\n\tvalue = &quot;get() instanceof T(org.nasdanika.models.functionflow.FunctionFlow)&quot;)\npublic Object createFunctionFlowProcessor(\n\tNodeProcessorConfig&lt;?,?&gt; config, \n\tboolean parallel, \n\tBiConsumer&lt;Element,BiConsumer&lt;ProcessorInfo&lt;Object&gt;,ProgressMonitor&gt;&gt; infoProvider,\n\tFunction&lt;ProgressMonitor, Object&gt; next,\t\t\n\tProgressMonitor progressMonitor) {\t\n\treturn new FunctionFlowProcessor();\n}\n Capability CapabilityProcessorFactory uses the Nasdanika Capability Framework to delegate processor creation to capability factories. ReflectiveProcessorServiceFactory provides such a capability by collecting reflective targets from capability providers and then using ReflectiveProcessorFactoryProvider mentioned above. This approach provides high level of decoupling between code which executes the graph and code which creates processors. FunctionFlowTests executes a graph loaded from a Drawio diagram. It constructs a processor factory as shown below: CapabilityLoader capabilityLoader = new CapabilityLoader();\t\t\nCapabilityProcessorFactory&lt;Object, BiFunction&lt;Object, ProgressMonitor, Object&gt;&gt; processorFactory = new CapabilityProcessorFactory&lt;Object, BiFunction&lt;Object, ProgressMonitor, Object&gt;&gt;(\n\t\tBiFunction.class, \n\t\tBiFunction.class, \n\t\tBiFunction.class, \n\t\tnull, \n\t\tcapabilityLoader); \n SyncProcessorFactory mentioned above is contributed by SyncCapabilityFactory: @Override\npublic boolean canHandle(Object requirement) {\n\tif (requirement instanceof ReflectiveProcessorFactoryProviderTargetRequirement) {\n\t\tReflectiveProcessorFactoryProviderTargetRequirement&lt;?,?&gt; targetRequirement = (ReflectiveProcessorFactoryProviderTargetRequirement&lt;?,?&gt;) requirement;\n\t\tif (targetRequirement.processorType() == BiFunction.class) { // To account for generic parameters create a non-generic sub-interface binding those parameters.\n\t\t\tProcessorRequirement&lt;?, ?&gt; processorRequiremment = targetRequirement.processorRequirement();\n\t\t\tif (processorRequiremment.handlerType() == BiFunction.class &amp;&amp; processorRequiremment.endpointType() == BiFunction.class) {\n\t\t\t\treturn processorRequiremment.requirement() == null; // Customize if needed\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\n@Override\npublic CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Object&gt;&gt;&gt; create(\n\tReflectiveProcessorFactoryProviderTargetRequirement&lt;Object, BiFunction&lt;Object, ProgressMonitor, Object&gt;&gt; requirement,\n\tBiFunction&lt;Object, ProgressMonitor, CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Object&gt;&gt;&gt;&gt; resolver,\n\tProgressMonitor progressMonitor) {\t\t\n\treturn CompletableFuture.completedStage(Collections.singleton(CapabilityProvider.of(new SyncProcessorFactory())));\t\n}\n canHandle() returns true if the factory can handle the requriement passed to it. create() creates a new instance of SyncProcessorFactory. Note, that create() may request other capabilities. Say, an instsance of OpenAIClient to generate code using chat completions. SyncCapabilityFactory is registered in module-info.java: exports org.nasdanika.models.functionflow.processors.targets.java.sync;\nopens org.nasdanika.models.functionflow.processors.targets.java.sync to org.nasdanika.common; // For loading resources\n\nprovides CapabilityFactory with SyncCapabilityFactory;\n Note that a package containing reflective factories and processors shall be opened to org.nasdanika.common for reflection to work. Wiring Processors created by the above factories are introspected for the following annotations: All processors: ChildEndpoint - field or method to inject a matching child endpoint wired to the child&rsquo;s parent handler. ChildEndpoints - field or method to inject a map of children to their endpoints completion stages. ChildHandler - field or method to obtain a handler for a child wired to child&rsquo;s parent endpoint. ChildHandlerConsumers - field or method to inject a map of children to java.util.function.Consumers of handlers. ChildProcessor - field a method to inject processor or config of element&rsquo;s child matching the selector expression. ChildProcessors - field or method to inject a map of children elements to their processor info. ClientEndpoint - field or method to inject a matching client endpoint. ClientHandler - field or method to obtain a handler for a client. ParentEndpoint - field or method into which a parent endpoint is injected. Parent endpoint allows the child processor to interact with the parent&rsquo;s processor child handler. ParentHandler - field or method from which the parent handler is obtained. ParentProcessor - field or method to inject processor or config of element&rsquo;s parent. ProcessorElement - field or method to inject the graph element. Registry - field or method to inject the registry - a map of graph elements to their info. RegistryEntry - field or method to inject a matching registry entry&rsquo;s processor, info or synapse. Node processors: IncomingEndpoint - field or method to inject a matching incoming endpoint. IncomingEndpoints - field or method to inject a map of incoming connections to their endpoints completion stages. IncomingHandler - field or method to obtain a handler for an incoming connection. IncomingHandlerConsumers - field or method to inject a map of incoming connections to java.util.function.Consumers of handlers. OutgoingEndpoint - field or method to inject a matching outgoing endpoint. OutgoingEndpoints - field or method to inject a map of outgoing connections to their endpoints completion stages. OutgoingHandler - field or method to obtain a handler for an outgoing connection. OutgoingHandlerConsumers - field or method to inject a map of outgoing connections to consumers of handlers. Connection processors: SourceEndpoint - field or method into which a connection source endpoint is injected. Source endpoint allows the connection processor to interact with the connection source handler. SourceHandler - field or method from which the connection source handler is obtained. TargetEndpoint - field or method into which a connection target endpoint is injected. Target endpoint allows the connection processor to interact with the connection target handler. TargetHandler - Field or method from which the connection target handler is obtained. Element/Node/Connection configuration is declaratively &ldquo;wired&rdquo; to processors&rsquo; fields and methods. Configuration can also be wired imperatively. Declarative and imperative styles can be used together. Below is an example of using @OutgoingEndpoint annotation by StartProcessor: public class StartProcessor implements BiFunction&lt;Object, ProgressMonitor, Object&gt; {\n\n\tprotected Collection&lt;BiFunction&lt;Object, ProgressMonitor, Object&gt;&gt; outgoingEndpoints = Collections.synchronizedCollection(new ArrayList&lt;&gt;());\t\n\t\n\t@Override\n\tpublic Object apply(Object arg, ProgressMonitor progressMonitor) {\n\t\tMap&lt;BiFunction&lt;Object, ProgressMonitor, Object&gt;, Object&gt; outgoingEndpointsResults = new LinkedHashMap&lt;&gt;();\n\t\tfor (BiFunction&lt;Object, ProgressMonitor, Object&gt; e: outgoingEndpoints) {\n\t\t\toutgoingEndpointsResults.put(e, e.apply(arg, progressMonitor));\n\t\t}\n\t\treturn outgoingEndpointsResults;\n\t}\n\t\n\t@OutgoingEndpoint\n\tpublic void addOutgoingEndpoint(BiFunction&lt;Object, ProgressMonitor, Object&gt; endpoint) {\n\t\toutgoingEndpoints.add(endpoint);\n\t}\n\n}``` Root A B A1 A2 B1 Page-1 Children Element Node A node can be connected to other nodes with connections. A node may contain other nodes and connections. Connection A connection between two nodes source 0..1 outgoingConnections * target 0..1 incomingConnections * Containment is implemented with accept() method Page-1 Node Processor Node Processor source -&gt; target processor target -&gt; source processor Page-1 Node Processor Node Processor Page-1",
    "timestamp": 1769516720286
  },
  "nsd-cli/nsd/drawio/html-app/site/index.html": {
    "path": "CLI/nsd/drawio/html-app/site",
    "link-uuid": "d8462133-87ba-4b72-b2ff-8d2f5adaf9c0",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd drawio html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720736
  },
  "html/3d-force-graph/index.html": {
    "path": "HTML/3D Force Graph",
    "link-uuid": "250fad98-25cb-43c2-a9c3-4e8ab898f164",
    "title": "3D Force Graph",
    "content": "Java bindings for 3d-force-graph. Sources Javadoc Maven dependency &lt;dependency&gt;            \n    &lt;groupId&gt;org.nasdanika.html&lt;/groupId&gt;\n    &lt;version&gt;2025.6.0&lt;/version&gt;\n    &lt;artifactId&gt;3d-force-graph&lt;/artifactId&gt;\n&lt;/dependency&gt;               \n Java code ForceGraph3DFactory forceGraph3DFactory = ForceGraph3DFactory.INSTANCE;\nForceGraph3D forceGraph3D = forceGraph3DFactory.create();\nforceGraph3D.name(&quot;graph&quot;);\nString forceGraphContainerId = &quot;force-graph&quot;;\nforceGraph3D\n    .elementId(forceGraphContainerId)\n    .nodeAutoColorBy(&quot;'group'&quot;)\n    .nodeVal(&quot;'size'&quot;)\n    .linkDirectionalArrowLength(3.5)\n    .linkDirectionalArrowRelPos(1);\n\n// Add nodes and links here \n\nHTMLPage page = HTMLFactory.INSTANCE.page();\nforceGraph3DFactory.cdn(page);\npage.body(HTMLFactory.INSTANCE.div().id(forceGraphContainerId));                \npage.body(TagName.script.create(System.lineSeparator(), forceGraph3D));\nFiles.writeString(new File(&quot;docs/force-graph-3d.html&quot;).toPath(), page.toString());  \n Examples Maven dependencies graph Maven dependencies graph with text Ecore documentation (generated from ECharts Graph Model): A2A GitLab Ecore ECharts",
    "timestamp": 1769516720596
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/html-app/site/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/html-app/site",
    "link-uuid": "97bc05f8-f06d-441c-939d-499c218d0c26",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd model catalog-diagram to-model html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720855
  },
  "ai/mcp/index.html": {
    "path": "AI/MCP",
    "link-uuid": "7a3069c5-6081-4c20-996f-1b4cdb6f7e66",
    "title": "MCP",
    "content": "MCP modules provides building blocks to create MCP servers and clients on top of Nasdanika capabilities with built-in telemetry. There are three modules: mcp - core MCP-related functionality Source Maven Central Javadoc mcp-sse - SSE/HTTP related functionality Source Maven Central Javadoc mcp-help - Help contributor generating capabilities tables Source Maven Central Javadoc Server Nasdanika MCP servers will have three dimensions: Capabilities (prompts, resources, tools) Transports (STDIO, SSE) Telemetry instrumentation scope name McpServerCommandBase class is a base class for MCP server CLI commands. Subclasses shall override one or more getXXXSpecificaion() methods to provide capabilities. The command implements McpAsyncServerProvider and there are two sub-commands binding to implementations of this interface - SSE and STDIO transport commands. McpServerCommand is a concrete command which binds as a sub-command of the root command. It collects specification capabilities and binds to the root command if there is at least one capability. Help generator for the command generates documentation for provided capabilities. MCP Server CLI assembly demonstrates how to contribute MCP server capabilities. Contributing a capability Capability factory import java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.CompletionStage;\n\nimport org.nasdanika.capability.CapabilityProvider;\nimport org.nasdanika.capability.ServiceCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\n\nimport io.modelcontextprotocol.server.McpServerFeatures;\nimport io.modelcontextprotocol.server.McpServerFeatures.SyncToolSpecification;\nimport io.modelcontextprotocol.spec.McpSchema.CallToolResult;\nimport io.modelcontextprotocol.spec.McpSchema.Content;\nimport io.modelcontextprotocol.spec.McpSchema.TextContent;\nimport io.modelcontextprotocol.spec.McpSchema.Tool;\n\npublic class SyncCalculatorCapabilityFactory extends ServiceCapabilityFactory&lt;Void, SyncToolSpecification&gt; {\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        return SyncToolSpecification.class == type &amp;&amp; requirement == null;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;SyncToolSpecification&gt;&gt;&gt; createService(\n            Class&lt;SyncToolSpecification&gt; serviceType, \n            Void serviceRequirement, \n            Loader loader,\n            ProgressMonitor progressMonitor) {\n\n        \n        String schema = &quot;&quot;&quot;\n                {\n                  &quot;type&quot; : &quot;object&quot;,\n                  &quot;id&quot; : &quot;urn:jsonschema:Operation&quot;,\n                  &quot;properties&quot; : {\n                    &quot;operation&quot; : {\n                      &quot;type&quot; : &quot;string&quot;\n                    },\n                    &quot;a&quot; : {\n                      &quot;type&quot; : &quot;number&quot;\n                    },\n                    &quot;b&quot; : {\n                      &quot;type&quot; : &quot;number&quot;\n                    }\n                  }\n                }\n                &quot;&quot;&quot;;\n            \n            SyncToolSpecification syncToolSpecification = new McpServerFeatures.SyncToolSpecification(\n                new Tool(&quot;calculator&quot;, &quot;Nasdanika calculator of all great things&quot;, schema), \n                (exchange, arguments) -&gt; {\n                    List&lt;Content&gt; result = new ArrayList&lt;&gt;();\n                    result.add(new TextContent(&quot;Result: &quot; + arguments));\n                    \n                    return new CallToolResult(result, false);\n                }\n            );\n\n        return wrap(syncToolSpecification);         \n    }\n    \n}\n module-info.java import org.nasdanika.capability.CapabilityFactory;\nimport org.nasdanika.demos.mcp.server.capabilities.SyncCalculatorCapabilityFactory;\n\nmodule org.nasdanika.demos.mcp.server {\n    \n    exports org.nasdanika.demos.mcp.server;\n    \n    requires transitive org.nasdanika.ai.mcp.sse;\n    \n    provides CapabilityFactory with \n        SyncCalculatorCapabilityFactory;\n                \n}\n Running a server SSE nsd mcp-server sse --http-port=8080\n STDIO nsd mcp-server stdio\n Generating documentation nsd help site --page-template=&quot;page-template.yml#/&quot; --root-action-icon=https://docs.nasdanika.org/images/nasdanika-logo.png --root-action-location=https://github.com/Nasdanika-Demos --root-action-text=&quot;Nasdanika Demos&quot; docs\n Client TelemetryMcpClientTransportFilter is a filter for McpClientTransport implementations adding telemetry. HttpClientTelemetrySseClientTransport propagates the trace to the server side. It can be used if the server supports telemetry, e.g. if it is built using Nasdanika MCP classes. OpenTelemetry openTelemetry = GlobalOpenTelemetry.get();\nMcpClientTransport transport = new HttpClientTelemetrySseClientTransport(\n        &quot;http://localhost:8080&quot;, \n        openTelemetry.getTracer(TestMcp.class.getName() + &quot;.transport&quot;),\n        openTelemetry.getPropagators().getTextMapPropagator(),\n        null);\n\nTracer tracer = openTelemetry.getTracer(TestMcp.class.getName());       \nSpan span = TelemetryUtil.buildSpan(tracer.spanBuilder(&quot;testSseTelemetryClient&quot;)).startSpan();\n        \ntry (Scope scope = span.makeCurrent()) {\n    TelemetryMcpClientTransportFilter transportFilter = new TelemetryMcpClientTransportFilter(\n            transport, \n            openTelemetry.getTracer(TestMcp.class.getName() + &quot;.transportFilter&quot;), \n            Context.current());         \n\n    McpSyncClient client = McpClient.sync(transportFilter)\n            .requestTimeout(Duration.ofSeconds(10))\n            .capabilities(ClientCapabilities.builder()\n                .roots(true)      // Enable roots capability\n                .sampling()       // Enable sampling capability\n                .build())\n            .sampling(request -&gt; {                  \n                CreateMessageResult result = null;\n                return result;\n            })\n            .build();       \n    \n    client.initialize();\n    ListResourcesResult resources = client.listResources();\n    System.out.println(resources);\n    \n    ReadResourceResult resource = client.readResource(new ReadResourceRequest(&quot;nasdanika://drawio&quot;));           \n    System.out.println(resource.contents());\n    \n    // List available tools\n    ListToolsResult tools = client.listTools();\n    System.out.println(tools);\n\n    // Call a tool\n    CallToolResult result = client.callTool(\n        new CallToolRequest(&quot;calculator&quot;, \n            Map.of(&quot;operation&quot;, &quot;add&quot;, &quot;a&quot;, 2, &quot;b&quot;, 3))\n    );\n    System.out.println(result);         \n    \n    client.closeGracefully();\n} finally {\n    span.end();\n}\n Please note that in the above example the current telemetry context is passed to the TelemetryMcpClientTransportFilter constructor. It is needed because the context does not propagate all the way along the reactive chain. You can find more examples of using the above classes to build telemetry-enabled MCP servers and clients in TestMcp class. Roadmap Annotations and a reflective capability factory Create annotations for prompts, resources and tools, infer sync/async from the return type. Description and tool schema is inline with expansion tokens to include content loaded from a URI, including classpath resources. Category and documentation for command documentation generation. Reflective factory using Reflector. If tools need capabilities, they shall be obtained during target construction/initialization - the reflector would deal just with creation of specifications.",
    "timestamp": 1769516720064
  },
  "nsd-cli/nsd/model/index.html": {
    "path": "CLI/nsd/model",
    "link-uuid": "74cc1bbe-4650-445a-be9a-97b515da0f58",
    "title": "model",
    "content": "Version: org.nasdanika.emf@2025.12.0 Usage: nsd model [-fhV] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;uri&gt; [COMMAND] Loads EObject from a URI or file &lt;uri&gt; EObject URI or file path, resolved relative to the current directory --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file URI parameter is a file path -h, --help Show this help message and exit. --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit. Commands: catalog-diagram - Generates a diagram from a Catalog model crew-ai - Generates CrewAI code and configuration from a model ecore - Generates a Ecore model from a database model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720901
  },
  "ai/ai-cli/index.html": {
    "path": "AI/CLI",
    "link-uuid": "c1733a3d-aa63-4fae-8edc-000cdad50db6",
    "title": "CLI",
    "content": "This module provides building blocks for command line AI solutions - argument groups and base commands. Sources Maven Central Javadoc Argument groups ChunkingEmbeddingsArgGroup - configures chunking for embeddings generation. Options: Chunk size Chunk overlap EmbeddingsArgGroup - configures embeddings requirement. Options: Provider Model Version EncodingChunkingEmbeddingsArgGroup - extends ChunkingEmbeddingsArgGroup. Option: Chunk encoding type HnswIndexBuilderArgGroup - abstract base class for argument groups configuring HnswIndex.Builder. Options: Ef Ef-construction M Remove enabled Threads Progress update interval HnswIndexBuilderFloatArgGroup - concrete extension of HnswIndexBuilderArgGroup. Options: Distance function - a choice of 19 distance functions with COSINE being the default Normalize Commands HnswIndexCommandBase - base class for commands generating HNSW indices. It uses the above argument groups. PdfIndexerCommand is a subclass of HnswIndexCommandBase which generated indices for PDF files. See also PDF Indexer Documentation.",
    "timestamp": 1769516719924
  },
  "ai/index.html": {
    "link-uuid": "1ef0d85c-5e36-47ae-9151-bd3024741e69",
    "title": "AI",
    "content": "Nasdanika AI: Provides AI capabilities - embeddings and chat - from OpenAI and Ollama with unified interfaces. Separates concerns of AI functionality such as chat/embeddings, and monitoring/telemetry/observability of, say, token use. Provides building blocks for telemetry-enabled Java MCP clients and servers. Sources Maven Central",
    "timestamp": 1769516720060
  },
  "ai/draw-ai/index.html": {
    "path": "AI/Nasdanika Draw.AI",
    "link-uuid": "ecfface4-2bf0-4fd2-bbff-5c5e8d3da8e2",
    "title": "Nasdanika Draw.AI",
    "content": "Nasdanika Draw.AI is a collection of practices, patterns, and tools intended to move the creation of agentic systems to the left - away from code-first development and toward visual, model-driven expression accessible to subject-matter experts and citizen developers. Instead of requiring people to understand frameworks, APIs, or orchestration runtimes, Nasdanika Draw.AI aims to enable them to draw what they want, and the system interprets, executes, or generates agentic code for a specific runtime from those diagrams. This approach builds on a core insight running through the Nasdanika ecosystem: diagrams, models, and metamodels are executable knowledge structures. They capture intent, context, and semantics in a form that both humans and AI agents can understand and act upon. Nasdanika Draw.AI makes diagrams of Agentic AI systems executable. Not above the glass. Not below the glass. It is the glass. Why This Matters Example: Professional Knowledge Graph (HR as Code) The Bigger Picture Resources Why This Matters Most organizations have deep expertise locked in the heads of SMEs &mdash; HR specialists, operations leads, architects, analysts, planners. These people understand the domain far better than developers, but they are rarely empowered to shape the systems that automate or augment their work. Nasdanika Draw.AI changes that dynamic: SMEs and citizen developers express intent visually, without waiting for developers. Developers/technology focus on wiring diagrams to tools and data sources, securing, scaling, refinement. The result is a shift-left transformation where diagrams become models, models become agent contexts, and agents execute on top of clear semantics. Example: Professional Knowledge Graph (HR as Code) An illustration of Nasdanika Draw.AI&rsquo;s value is the Professional Knowledge Graph &mdash; a digital twin of a person&rsquo;s professional experience. In the HR as Code framing, the challenge is clear: decades of nuanced experience, niche skills, and contextual knowledge cannot be compressed into a r&eacute;sum&eacute; without losing meaning. The real source of truth is the CV in your head &mdash; rich, interconnected, and impossible to flatten. With Nasdanika Draw.AI, a person can draw their professional universe: Roles, projects, and responsibilities Skills, certifications, and tools People they collaborated with Systems they touched Artifacts they produced Outcomes they influenced Each node becomes part of a structured model. Each connection encodes meaning. And once the model exists, agents can operate on top of it: Generate tailored r&eacute;sum&eacute;s for specific job posts Analyze skill gaps Recommend career paths Match candidates to roles Evaluate experience against job requirements Produce interview preparation materials Summarize past projects or generate portfolio narratives This is the essence of shifting left: the job seeker (or HR specialist) doesn&rsquo;t need to understand JSON schemas, Ecore, or agentic runtimes. They simply draw their experience, and Nasdanika Draw.AI turns that into a living, executable knowledge graph that agents can reason over. The Bigger Picture Nasdanika Draw.AI sits at the intersection of diagrams, semantic mapping, and agentic execution. It leverages the full Nasdanika stack &mdash; models, capabilities, processors, semantic mapping, and agentic runtimes &mdash; to make agentic systems designable by anyone who can think visually. Draw first, formalize later. Let diagrams become models. Let models become agent contexts. Let agents operate on bounded contexts with clear semantics. Let SMEs and citizen developers shape the system long before code enters the picture. In other words: Draw what you want to happen, and agents will do it. Resources The Pillars of Nasdanika Nasdanika 2025+ Model-based HR&hellip; as code",
    "timestamp": 1769516720056
  },
  "ai/open-ai/index.html": {
    "path": "AI/OpenAI",
    "link-uuid": "4435cab2-5a30-4057-96fa-da96fc06634e",
    "title": "OpenAI",
    "content": "This module provides implementations of core capabilities on top of Azure OpenAI client library for Java with integrated telemetry. However, it doesn&rsquo;t register capability factories - it has to be done in (CLI) assemblies. Sources Maven Central JavaDoc Below are examples of how to register capabilities1. Embeddings Capability factory import java.util.concurrent.CompletionStage;\nimport java.util.function.BiFunction;\n\nimport org.nasdanika.ai.Embeddings;\nimport org.nasdanika.ai.openai.OpenAIEmbeddings;\nimport org.nasdanika.capability.CapabilityProvider;\nimport org.nasdanika.capability.ServiceCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Util;\n\nimport com.azure.ai.openai.OpenAIClientBuilder;\nimport com.knuddels.jtokkit.api.EncodingType;\n\nimport io.opentelemetry.api.OpenTelemetry;\n\npublic class OpenAIAdaEmbeddingsCapabilityFactory extends ServiceCapabilityFactory&lt;Embeddings.Requirement, Embeddings&gt; {\n\n    private static final String MODEL = &quot;text-embedding-ada-002&quot;;\n    private static final String PROVIDER = &quot;OpenAI&quot;;\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        if (Embeddings.class == type) {\n            if (requirement == null) {\n                return true;\n            }\n            if (requirement instanceof Embeddings.Requirement) {            \n                Embeddings.Requirement eReq = (Embeddings.Requirement) requirement;\n                if (!Util.isBlank(eReq.provider()) &amp;&amp; !PROVIDER.equals(eReq.provider())) {\n                    return false;\n                }\n                return Util.isBlank(eReq.model()) || MODEL.equals(eReq.model());\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Embeddings&gt;&gt;&gt; createService(\n            Class&lt;Embeddings&gt; serviceType,\n            Embeddings.Requirement serviceRequirement, \n            Loader loader, \n            ProgressMonitor progressMonitor) {\n                \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);\n        \n        Requirement&lt;String, OpenAIClientBuilder&gt; openAIClientBuilderRequirement = ServiceCapabilityFactory.createRequirement(\n                OpenAIClientBuilder.class,\n                null,\n                &quot;https://api.openai.com/v1/&quot;);\n        \n        CompletionStage&lt;OpenAIClientBuilder&gt; openAIClientBuilderCS = loader.loadOne(openAIClientBuilderRequirement, progressMonitor);\n        \n        int chunkSize = serviceRequirement == null ? 0 : serviceRequirement.chunkSize();\n        int overlap = serviceRequirement == null ? 0 : serviceRequirement.overlap();\n        \n        BiFunction&lt;OpenAIClientBuilder, OpenTelemetry, Embeddings&gt; combiner = (openAIClientBuilder, openTelemetry) -&gt; createEmbeddings(openAIClientBuilder, openTelemetry, chunkSize, overlap);\n        return wrapCompletionStage(openAIClientBuilderCS.thenCombine(openTelemetryCS, combiner));\n    }\n        \n    protected Embeddings createEmbeddings(\n            OpenAIClientBuilder openAIClientBuilder, \n            OpenTelemetry openTelemetry,\n            int chunkSize,\n            int overlap) {\n        return new OpenAIEmbeddings(\n                openAIClientBuilder.buildClient(),\n                openAIClientBuilder.buildAsyncClient(),\n                PROVIDER,\n                MODEL,\n                null,\n                1536,\n                EncodingType.CL100K_BASE,\n                8191,\n                chunkSize,\n                overlap,\n                openTelemetry);\n    }\n    \n}\n module-info.java module &lt;module name&gt; {\n    \n    ...\n    \n    provides CapabilityFactory with OpenAIAdaEmbeddingsCapabilityFactory;\n    \n}\n Chat Capability factory \nimport java.util.concurrent.CompletionStage;\n\nimport org.nasdanika.ai.Chat;\nimport org.nasdanika.ai.openai.OpenAIChat;\nimport org.nasdanika.capability.CapabilityProvider;\nimport org.nasdanika.capability.ServiceCapabilityFactory;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Util;\n\nimport com.azure.ai.openai.OpenAIClientBuilder;\n\nimport io.opentelemetry.api.OpenTelemetry;\n\npublic class OpenAIGpt35TurboChatCapabilityFactory extends ServiceCapabilityFactory&lt;Chat.Requirement, Chat&gt; {\n\n    private static final String MODEL = &quot;gpt-3.5-turbo&quot;;\n    private static final String PROVIDER = &quot;OpenAI&quot;;\n\n    @Override\n    public boolean isFor(Class&lt;?&gt; type, Object requirement) {\n        if (Chat.class == type) {\n            if (requirement == null) {\n                return true;\n            }\n            if (requirement instanceof Chat.Requirement) {          \n                Chat.Requirement cReq = (Chat.Requirement) requirement;\n                if (!Util.isBlank(cReq.provider()) &amp;&amp; !PROVIDER.equals(cReq.provider())) {\n                    return false;\n                }\n                return Util.isBlank(cReq.model()) || MODEL.equals(cReq.model());\n            }\n        }\n        return false;\n    }\n\n    @Override\n    protected CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Chat&gt;&gt;&gt; createService(\n            Class&lt;Chat&gt; serviceType,\n            Chat.Requirement serviceRequirement, \n            Loader loader, \n            ProgressMonitor progressMonitor) {\n        \n        Requirement&lt;Object, OpenTelemetry&gt; openTelemetryRequirement = ServiceCapabilityFactory.createRequirement(OpenTelemetry.class);\n        CompletionStage&lt;OpenTelemetry&gt; openTelemetryCS = loader.loadOne(openTelemetryRequirement, progressMonitor);\n        \n        Requirement&lt;String, OpenAIClientBuilder&gt; openAIClientBuilderRequirement = ServiceCapabilityFactory.createRequirement(\n                OpenAIClientBuilder.class,\n                null,\n                &quot;https://api.openai.com/v1/&quot;);\n        \n        CompletionStage&lt;OpenAIClientBuilder&gt; openAIClientBuilderCS = loader.loadOne(openAIClientBuilderRequirement, progressMonitor);\n        \n        return wrapCompletionStage(openAIClientBuilderCS.thenCombine(openTelemetryCS, this::createChat));\n    }\n        \n    protected Chat createChat(OpenAIClientBuilder openAIClientBuilder, OpenTelemetry openTelemetry) {\n        return new OpenAIChat(\n            openAIClientBuilder.buildClient(),\n            openAIClientBuilder.buildAsyncClient(),\n            PROVIDER,\n            MODEL,\n            null,\n            16385,\n            4096,\n            openTelemetry);\n    }   \n\n}\n module-info.java module &lt;module name&gt; {\n    \n    ...\n    \n    provides CapabilityFactory with OpenAIGpt35TurboChatCapabilityFactory;\n    \n}\n Sources â†©",
    "timestamp": 1769516720074
  },
  "nsd-cli/nsd/model/ecore/save/index.html": {
    "path": "CLI/nsd/model/ecore/save",
    "link-uuid": "41032585-3486-4842-bacb-f02c2aaad4e8",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model ecore save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720885
  },
  "html/alpine-js/index.html": {
    "path": "HTML/AlpineJS",
    "link-uuid": "75bb9c07-e7cc-4596-babe-3b065db95dc0",
    "title": "AlpineJS",
    "content": "Java bindings for Alpine.js. Sources Javadoc Example - chat application This section explains how to build a simple chat application. Source code - ChatServerCommand: home() method builds the application - 80 lines of code chat() method serves chat requests, not specific to the Alpine.js functionality home() BootstrapFactory bootstrapFactory = BootstrapFactory.INSTANCE;\nAlpineJsFactory alpineJsFactory = AlpineJsFactory.INSTANCE;\n\nHTMLPage page = bootstrapFactory.bootstrapCdnHTMLPage();        \nalpineJsFactory.cdn(page);\nContainer chatApp = bootstrapFactory.container();\nJSONObject appData = alpineJsFactory.from(chatApp.toHTMLElement()).data();\nJSONArray messagesArray = new JSONArray();\nappData\n    .put(&quot;messages&quot;, messagesArray)\n    .put(&quot;text&quot;, &quot;&quot;);\n\npage.body(chatApp);\n\n// Chat message cards\nCard messageCard = bootstrapFactory.card();\nmessageCard.margin().bottom(Breakpoint.DEFAULT, Size.S1);\nTag messageCardHtmlElement = messageCard.toHTMLElement();\nalpineJsFactory\n    .from(messageCardHtmlElement)\n    .bind(&quot;class&quot;, &quot;'border-' + message.style&quot;);\nmessageCard.border(Color.DEFAULT);      \nTag messageCardBody = messageCard.getBody().toHTMLElement();\nmessageCardBody.content(&quot;Loading...&quot;);\nalpineJsFactory\n    .from(messageCardBody)\n    .html(&quot;message.content&quot;);               \nTag messagesFor = alpineJsFactory._for(&quot;message in messages&quot;, messageCardHtmlElement);      \nchatApp.row().col().content(messagesFor);\n\n// Text area\nTextArea textArea = bootstrapFactory.getHTMLFactory().textArea();\ntextArea\n    .name(&quot;userInput&quot;)\n    .placeholder(&quot;Ask me anything about TOGAF 10&quot;);\nInputGroup textAreaInputGroup = bootstrapFactory\n    .inputGroup()\n    .input(textArea)\n    .prepend(&quot;Chat&quot;);\nalpineJsFactory.from(textArea).model(&quot;text&quot;);\nButton submitButton = bootstrapFactory.getHTMLFactory().button(&quot;Submit&quot;);\n\nString submitHandler = &quot;&quot;&quot;\n    messages.push({\n        content: text,\n        style: 'primary'\n    });\n    \n    var responseMessage = Alpine.reactive({\n        content: 'Processing...',\n        style: 'muted'\n    });\n    messages.push(responseMessage);                     \n    \n    fetch(&quot;chat&quot;, {\n        method: 'POST',\n        body: text\n    }).then(response =&gt; {\n        if (response.ok) {\n            response.json().then(responseJson =&gt; {\n                responseMessage.content = responseJson.content;\n                responseMessage.style = responseJson.style;\n            });\n        } else {\n            responseMessage.content = response.status + &quot;: &quot; + response.statusText;\n            responseMessage.style = 'danger';\n        }\n    });\n    text = '';\n    &quot;&quot;&quot;;\n\nalpineJsFactory\n    .from(submitButton)\n    .on(&quot;click&quot;, submitHandler)\n    .bind(&quot;disabled&quot;, &quot;!text&quot;);\norg.nasdanika.html.bootstrap.Button&lt;Button&gt; bootstrapSubmitButton = bootstrapFactory.button(submitButton, Color.PRIMARY, false);\ntextAreaInputGroup.append(bootstrapSubmitButton);\nchatApp.row().col().content(textAreaInputGroup);\nreturn page.toString();\n First, two factories are created - BootstrapFactory and AlpineJsFactory. Then a bootstrap HTML page is created with bootstrap initialization script and stylesheet and Alpine.js script is added to the page. After that UI elements are built using the Bootstrap factory and dynamic behavior is added to them by wrapping them into AlpineJs and then calling one of AlpineJs instance methods. The for loop for messages is created by calling AlpineJsFactory._for - template methods _for, _if and teleport are defined in the factory because they wrap HTML element instance into a &lt;template&gt; tag. Application Javascript code is just 26 lines and is defined in the code. Larger Javascript sources can be loaded from classloader resources.",
    "timestamp": 1769516720600
  },
  "core/persistence/index.html": {
    "path": "Core/Persistence",
    "link-uuid": "89928f57-f919-42c4-a3e0-65bd784dfcd9",
    "title": "Persistence",
    "content": "Sources Javadoc",
    "timestamp": 1769516720542
  },
  "ai/ai-emf/index.html": {
    "path": "AI/EMF",
    "link-uuid": "03a3ae13-f584-4d5f-aaf7-a8440b1cc833",
    "title": "EMF",
    "content": "This module provides building blocks for AI solutions on top of EMF Ecore models. Sources Maven Central Javadoc Similarity Similarities Connections Connection factories Graph similarity Performance Applications Graph RAG &amp; fine tuning Decision analysis Product recommender Nature model Similarity org.nasdanika.ai.emf.similarity package provides a number of interfaces and classes for computing similarity between EObjects as connections between EObjectNodes. Similarities Similarity can be of any type. The similarity package provides concrete classes for the below similarity types: java.lang.Double java.lang.Float EStructuralFeatureSimilarity - similarity which has an aggregated similarity value and similarity values for individual features. DoubleEStructuralFeatureSimilarity - binding to Double. FloatEStructuralFeatureSimilarity - binding to Float. Connections EStructuralFeatureConnection - a connection with a value and a structural feature (attribute or reference) indicating similarity of a feature of the target to the source DoubleEStructuralFeatureConnection - binding to Double. FloatEStructuralFeatureConnection - binding to Float. SimilarityConnection - a connection which indicates how much its target is similar to the source. Similarity does not have to be symmetrical. DoubleSimilarityConnection - binding of SimilarityConnection to Double. EStructuralFeatureVectorSimilarityConnection - binding to EStructuralFeatureSimilarity DoubleEStructuralFeatureVectorSimilarityConnection - binding to Double. FloatEStructuralFeatureVectorSimilarityConnection - binding to Float. FloatSimilarityConnection - binding of SimilarityConnection to Float. Connection factories SimilarityConnectionFactory - abstract base class for creating similarity connections. EStructuralFeatureVectorSimilarityConnectionFactory - abstract base class for EStructuralFeatureVectorSimilarityConnection factories with EStructuralFeatureSimilarity value. Computes value from the outgoing EStructuralFeatureConnections. DoubleEStructuralFeatureVectorSimilarityConnectionFactory - binding to Double. Computes value as a weighted sum of feature values. The default feature weight is 1.0, override getFeatureWeight() to customize. FloatEStructuralFeatureVectorSimilarityConnectionFactory - binding to Float. Computes value as a weighted sum of feature values. The default feature weight is 1.0, override getFeatureWeight() to customize. DoubleEStructuralFeatureSimilarityConnectionFactory - creates DoubleSimilarityConnection by computing its value from outgoing DoubleEStructuralFeatureConnections using a weighted sum. The default feature weight is 1.0, override getFeatureWeight() to customize. FloatEStructuralFeatureSimilarityConnectionFactory - creates FloatSimilarityConnection by computing its value from outgoing FloatEStructuralFeatureConnections using a weighted sum. The default feature weight is 1.0, override getFeatureWeight() to customize. MessageCollectorSimilarityConnectionFactory - abstract base class for connections factories which collect messages to compute similarity (see graph similarity below) DoubleMessageCollectorSimilarityConnectionFactory - binding to DoubleSimilarityConnection. EStructuralFeatureVectorMessageCollectorSimilarityConnectionFactory - computes EStructuralFeatureSimilarity from message EReferenceConnections in the message path. DoubleEStructuralFeatureVectorMessageCollectorSimilarityConnectionFactory - binding to Double Graph similarity EObjectGraphMessageProcessor and its subclass DoubleEObjectGraphMessageProcessor can be used to compute similarity between model objects by constructing a graph on top of model objects and their relationships and then sending messages between graph nodes. Similarity may be computed from message values and message paths. The below code snippet shows how to use the above classes: DoubleEObjectGraphMessageProcessor&lt;Void&gt; messageProcessor = new DoubleEObjectGraphMessageProcessor&lt;&gt;(false, familyResource.getContents(), progressMonitor) {\n    \n    /**\n     * Override this method to filter messages:\n     * - Drop long messages\n     * - Pass messages only through certain types of connections\n     *   or from/to certain types of nodes\n     */\n    @Override\n    protected boolean test(Message&lt;Double&gt; message, ProgressMonitor tpm) {\n        if (message.depth() &gt; 20 || message.value() &lt; 0.000001) {\n            return false;\n        }\n        Element recipient = message.recipient();                \n        if (recipient instanceof EObjectNode) {\n            EObject eObject = ((EObjectNode) recipient).get();\n            return eObject instanceof Person || eObject instanceof EClass;\n        }\n        return true; \n    }\n    \n    /*\n     *  Customize connection weights and message values,\n     *  return null for connections which shall not be traversed\n     */  \n    \n    @Override\n    protected Double getOutgoingConnectionWeight(Connection connection) {\n        return connection instanceof EClassConnection ? 1.0 : null;\n    }\n    \n    @Override\n    protected Double getIncomingConnectionWeight(Connection connection) {\n        return connection instanceof EClassConnection ? 1.0 : null;\n    }\n    \n    @Override\n    protected Double getIncomingEReferenceWeight(EReference eReference) {\n        return eReference == EcorePackage.Literals.ECLASS__ESUPER_TYPES ? 1.0 : null;\n    }\n    \n    @Override\n    protected Double getOutgoingEReferenceWeight(EReference eReference) {\n        return eReference == EcorePackage.Literals.ECLASS__ESUPER_TYPES ? 1.0 : null;\n    }\n    \n    @Override\n    protected Double getConnectionMessageValue(\n            BiFunction&lt;Connection, Boolean, Double&gt; state,\n            Connection activator, \n            boolean incomingActivator, \n            Node sender, \n            Connection recipient,\n            boolean incomingRrecipient, \n            Message&lt;Double&gt; parent, \n            ProgressMonitor progressMonitor) {\n        \n        Double connectionMessageValue = super.getConnectionMessageValue(\n                state, \n                activator, \n                incomingActivator, \n                sender, \n                recipient, \n                incomingRrecipient,\n                parent, \n                progressMonitor);\n        \n        if (connectionMessageValue != null) {\n            return 0.8 * connectionMessageValue;\n        }\n        \n        return connectionMessageValue;\n    }\n    \n};\n\nDoubleEStructuralFeatureVectorMessageCollectorSimilarityConnectionFactory similarityConnectionFactory = \n    new DoubleEStructuralFeatureVectorMessageCollectorSimilarityConnectionFactory();\n\n// Optional selector to send messages only from some graph nodes\nFunction&lt;Map&lt;Element, ProcessorInfo&lt;BiFunction&lt;Message&lt;Double&gt;, ProgressMonitor, Void&gt;&gt;&gt;, Stream&lt;BiFunction&lt;Message&lt;Double&gt;, ProgressMonitor, Void&gt;&gt;&gt; selector = processors -&gt; {\n    ...\n};\n\n// Optional message filter - can be used instead of overriding the test() method\n// or in combination with the test() method.\nBiFunction&lt;Message&lt;Double&gt;, ProgressMonitor, Message&lt;Double&gt;&gt; messageFilter = (m,p) -&gt; {\n    ...\n};\n\nmessageProcessor.processes(\n        1.0, \n        selector, \n        messageTransformer,\n        similarityConnectionFactory, \n        progressMonitor);\n\nCollection&lt;DoubleEStructuralFeatureVectorSimilarityConnection&gt; similarityConnections = similarityConnectionFactory.createSimilarityConnections();\n TestFamilySimilarity provides several examples of computing similarity of family members: Relatives - messages are sent through the &ldquo;parents&rdquo; reference Gender - messages are sent through the EClassConnection and then through the supertypes reference Performance On a Windows 11 desktop with Intel i7-14700 2.1 GHz CPU: Single thread - 500K messages/second Cached thread pool (5-20) - 600k message/second Applications Graph RAG &amp; fine tuning Find objects similar to a given (context) object Generate descriptions for the context objects and similar objects Use generated descriptions in a chat prompt or to fine-tune a model. In the latter case similar objects can be used to generate questions/answers. In case of the family model it might be important that Paul is a Man and a father of Lea who is a Woman. In the case of an architecture model, Internet Banking System for example, it might be important that API Application is a Container. It might be especially important for proprietary architecture models. Let&rsquo;s say that API Application is a container image to be deployed to Kubernetes following organization&rsquo;s guidelines. It may also be important that the Internet Banking System belongs to a specific line of business or product portfolio. Decision analysis In Multi-criteria Decision Analysis message sending can be used to compute alternatives&rsquo; weights by sending a message from the goal. Messages would pass through the criteria (flat, hierarchy, network) and be collected by the alternative nodes. Message paths can be used to explain reasoning and to detect inconsistencies. See also Task and design spaces with Visual Collaborative Multi-Criteria Decision Analysis Product recommender In banking and other businesses message passing can be used to compute similarity between customers and products. Customer to customer similarity can be computed using customer location (country/state/city), income, net worth, demographics. If products are organized into product groups/categories, product-to-products similarity can be computed by traversing the category hierarchy. A checking account product might be more similar to a saving account product (both deposits) than to a credit card. Or vice versa - both checking and credit card accounts are used for payments. Then customer-product similarity can be computed by sending messages from a customer node to similar customers and then from those customer nodes to the products they use. Nature model This scenario is to demonstrate different types of similarity. In the Nature model as shown here we may compute: Food similarity. For example, Fox it more similar to Hare than to Grass because Fox eats Hare, but doesn&rsquo;t eat Grass. Computing this similarity would require the following traversal: Object -&gt; class (type) Class -&gt; operation (method) Operation -&gt; parameters Parameter -&gt; parameter type Parameter type -&gt; object (instance) Reproduction - a female fox would have greater similarity with a male fox than to a female fox or other living beings. Computing this similarity would require traversal from an object to its class and then to other instances of the class. Using the above similarities we can solve a &ldquo;life optimization problem&rdquo;: given a distribution of nutrients on 2D surface compute distribution of living beings - grass, hares and foxes. Living beings shall be close to their food so they don&rsquo;t starve to death. They should be far enough from each other so they don&rsquo;t exhaust their food supply. Living beings of the same species shall be close enough to beings of the opposite sex to reproduce. From the above similarities distances/forces can be computed to use in a force layout graph to compute distributions.",
    "timestamp": 1769516720030
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/crew-ai/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/crew-ai",
    "link-uuid": "bd68a661-a024-45aa-a0f5-e7dd8ba1796f",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model catalog-diagram to-model crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720841
  },
  "nsd-cli/nsd/model/catalog-diagram/html-app/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/html-app",
    "link-uuid": "aafda751-a32c-44c6-ad79-09a0751fda73",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd model catalog-diagram html-app [-fhRV] [--[no-]tooltip] [-b=&lt;base&gt;] [-P=&lt;insertionIndex&gt;] [--page=Page name] [--predicate=&lt;predicate&gt;] [-r=&lt;rootLabel&gt;] [--ref-base-uri=&lt;refBase&gt;] [-x=&lt;indexName&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [-F=Invocable URI]... [--predicate-property=Predicate property]... [--protocol-resource-factory=&lt;String=Class&gt;]... [--representation-filter-property=Predicate property]... [--tag=&lt;tag&gt;]... [COMMAND] Generates html application model from a drawio document -b, --base-uri=&lt;base&gt; Base URI. E.g. 'pages/' --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -F, --representation-element-filter=Invocable URI Invocable URI of a representation element filter URIs are resolved relative to the current directory -h, --help Show this help message and exit. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --page=Page name If provided, actions are generated for the page with matching name --predicate=&lt;predicate&gt; SpEL expression for filtering diagram elements --predicate-property=Predicate property Mapping of a script language name to the property name containing predicate script in this language 'spel' is reserved for SpEL --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present --ref-base-uri=&lt;refBase&gt; Base URI for resolving documentation and prototype references. Resolved relative to the document URI --representation-filter-property=Predicate property Mapping of a script language name to the property name containing representation filter script in this language --tag=&lt;tag&gt; Tag(s) to filter diagram elements --[no-]tooltip Use tooltip as documentation if documentation is empty. Default: true -V, --version Print version information and exit. -x, --index=&lt;indexName&gt; Index file name, defaults to index.html Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Parent drawio command loads diagram.drawio diagram resource This command: Generates an html application model from the diagram elements Loads a root action from root-action.yml resource Adds the generated labels to the root action Passes the resulting model to the site sub-command to generate a documentation site Diagram element configuration Diagram elements can be configured with the following properties: child-comparator - a YAML specification for sorting child elements as explained below documentation - documentation text in documentation format doc-format - explicitly specified documentation format for documentation and doc-ref. Out of the box: markdown (default), html text doc-ref - URI of a documentation resource resolved relative to the URI of the diagram file. Documentation format is derived from the URI extension, defaulting to markdown. Use doc-format to override. icon - diagram element icon URL resolved relative to the diagram file. If there is no slash (/) in the icon name then it is treated as a CSS style, e.g. fas fa-user. For image diagram elements icons are derived from element images. It is recommended to use SVG 20x20 OR 18x18 pixels for icons because they are also used in page titles and PNG images get blurry when scaled up. parent - Connection property with values source or target. Use to generate documentation from mind maps where parent/child relationship is defined by connections, not by containment. prototype &amp; proto-ref &ndash; YAML specification of html application action, link or label. See load specifications of respective model elements for supported configuration keys. If both properties are specified, prototype takes precedence over proto-ref. With prototypes you can: Generate complex site pages (actions) with children, navigation, sections, &hellip; Reuse action models. For example, generate an action model from one diagram and use it as a prototype for an element of another diagram. Or generate an action model for CLI or Ecore documentation. role - action/page role: anonymous (default for connections) child (default for nodes) navigation section sort-key - By default generated pages (actions) are sorted alphabetically by title. This property can be used to customize sorting. If it is set then pages are sorted first by the property value and then by page title. title - By default the element label is used as page title (action text). Use this property to explicitly set the page title. For example, for elements with long labels. Site pages are generated only for elements with: Documentation (documentation or doc-ref), prototypes (prototype or prototype-ref), or both. Labels or title property. If you don&rsquo;t want an element label to be visible (e.g. on connections) uncheck &ldquo;Font color&rdquo; checkbox on the &ldquo;Text&rdquo; tab. child-comparator The specification can be a list, a string, or a map. Lists are treated as maps with null values and strings are treated as singleton maps with null values. Map entry keys are comparator names and values are configurations. The following comparators are supported: enumerate and reverse-enumerate order model elements using enumerate value. Elements without enumerate value are considered equal to any other elements including those with enumerate value. This is done to allow chaining with, say, flow comparator. As a result, this comparator will violate the transitivity requirement if some elements don&rsquo;t have enumerate value. Therefore, it shall be chained with other comparators. For example, flow and then position or label. Enumerate value is treated as path of dot-separated values and two enumerate values are compared element-by-element with elements containing only digits parsed and compared as integers. For example, 20 would be greater than 3, 1.1.1 would be greater than 1.1 and smaller than 2.5.6 or 3. Numbers are considered smaller than strings 1.12 is smaller than 1.a Practical use - ordering connections emanating from the same node. Say, excursions from the same location. If those excursions have multiple segments, then this comparator can be chained with the flow comparator and possibly terminated by the position or label comparator just in case. flow and reverse-flow order elements based on how they are connected to each other. These comparators configuration is either null, string or a list of strings. Strings are evaluated as Spring Expression Language (SpEL) boolean expressions in the context of connections. If the expression evaluates to false, then the given connection is not included in the flow traversal. It can be used if there are loops. For example, you plan a trip and want the destinations to be sorted in the visit order. There is a loop - the returning flight home. You can provide an expression which evaluates to false for that flight. position and reverse-position order elements by their position in the container&rsquo;s children list (z-order). down-right - Compares nodes by their vertical order first with higher nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. This comparator can be used for org. charts. left-down - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. left-up - Compares nodes by their horizontal order first with nodes on the right being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-down - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with higher nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. right-up - Compares nodes by their horizontal order first with nodes on the left being smaller and then by vertical order with lower nodes being smaller. Nodes are considered horizontally equal if they horizontally overlap. up-left - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the right being smaller. Nodes are considered vertically equal if they vertically overlap. up-right - Compares nodes by their vertical order first with lower nodes being smaller and then by horizontal order with nodes on the left being smaller. Nodes are considered vertically equal if they vertically overlap. icon Drawio has more than two thousand built-in icons. You can find more icons on the below sites: Font Awesome 5 icons FlatIcons - 16.8 million icons. Free with attribution, a paid plan is available - no attribution. In-browser editor. PNG and SVG (premium) formats. IconFinder - the world&rsquo;s largest marketplace for icons, &hellip; 6 million icons at your fingertips including free icons. Multiple subscription levels. Iconduck - more than 250 000 free open source icons Techicons - SVG and PNG tech icons, sourced from https://github.com/devicons/devicon. 473 icons. Cloud providers: Azure AWS prototype If your top-level diagram page is generated as a principal action and the root action or link references some external site, e.g. your company site, then you need to use the following prototype for proper generation: Action:\n  location: ${base-uri}index.html\n Below is an example of a prototype which defines a navigation action: Action:\n    navigation:\n      - Action:\n          location: about-wendy.html\n          icon: fas fa-help\n          text: About\n          content:\n            Interpolator:\n              source:\n                exec.content.Text: |    \n                  This is an example of a page from an action prototype.\n proto-ref Property value is a URI of the prototype action or label resolved relative to the element base URI. For example bob-prototype.yml#/. Element ID Element IDs are used to construct element page URLs. Element IDs are generated as long random strings. They are editable - double-click on the ID at the top of the data dialog. So, if you&rsquo;d like to have semantic URLs - customize the IDs. Page and element links You may link elements to pages and other element using the extended link syntax. When an element links to a page, the page root1 is logically merged with the linking element and page elements (except elements liking to other elements) become logical children of the linking element. If an element links to another element, then that element is not considered a logical child of the page/root/page linking element. The link chain is traversed and the diagram element on the generated site is linked to the page of the link target element if that element has a page (i.e. it is documented). Otherwise there is no link. Multiple top-level pages A top-level diagram page is a page that is not linked from any diagram element. If there is more than one top-level page, add a principal action to the root-action.yml and link pages to the principal action. Examples: Beyond Diagrams Illustrations Declarative Command Pipelines See Drawio API â†© Options -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx. -F, --representation-element-filter -r, --root-label -x, --index You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.   You may change the file extension if you need to generate server pages (PHP, JSP, ASPX) with additional functionality such as authentication. For example, you may change the extension to php to add authentication and other dynamic behavior with -x index.php option. Internet Banking System PHP demo shows how do so. If you use generated search, also add -x &lt;extension&gt; option to the site command so the generated pages are included into the search index, e.g. -x php. To add contents before the &lt;html&gt; opening tag use prolog configuration key in page template. E.g.:   prolog:\n    content.Text: |\n      &lt;?php\n        ... php code here ...\n      ?&gt;\n You can also use epilog to add content after the &lt;/html&gt; closing tag. If you use search and glossary, change their extensions too. This technique can be used to publish generated sites to SharePoint - change the extension to aspx.",
    "timestamp": 1769516720821
  },
  "nsd-cli/nsd/model/catalog-diagram/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/html-app/crew-ai",
    "link-uuid": "8e204e8c-fa02-46ad-a68c-fa3436ccc8f9",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd model catalog-diagram html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720815
  },
  "nsd-cli/nsd/drawio/to-model/crew-ai/index.html": {
    "path": "CLI/nsd/drawio/to-model/crew-ai",
    "link-uuid": "4b124108-2fd3-4db9-bc0c-63d6edc20570",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd drawio to-model crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Clas s&gt;]... [--extension-resource-factory=&lt;String=Class&gt;] ... [--protocol-resource-factory=&lt;String=Class&gt;]. .. &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720748
  },
  "core/resources/index.html": {
    "path": "Core/Resources",
    "link-uuid": "e8d2c30d-5ce1-41ee-81ad-de14f1cc2407",
    "title": "Resources",
    "content": "Sources Javadoc",
    "timestamp": 1769516720545
  },
  "practices/index.html": {
    "link-uuid": "15e0ef19-1ada-4c00-8690-6fe038a4b868",
    "title": "Practices",
    "content": "Practices explain how to use Nasdanika products to achieve specific goals and explain why particular design choices wer made. The enterprise model provides deeper insight on the WHY in general. The practices are organized into an enterprise continuum from the most generic on the left to the most specific on the right. However, the most specific on the right is still generic and needs to be specialized for a particular application (embodiment): Analysis, Visualization &amp; Generation - describes a general approach on using Nasdanika products. Java Analysis, Visualization &amp; Generation - application of the above to the Java model1 Loading and analyzing Java sources and bytecode, generation of non-Java artifacts such as HTML reports Generation of Java sources. JUnit test generation for low coverage methods - further specialization of the Java practice to identify methods with low test coverage using the Coverage Model and then generate JUnit tests for those methods using the Java model and OpenAI. You can think of the three practices above as progressive &ldquo;binding of decision&rdquo; as you move from the left to the right to reach &ldquo;executability&rdquo; - ability to deliver value. A java analogy for progressive specialization would be incremental binding of generic types as exemplified below: Map&lt;K,V&gt; - generic map. MyMap&lt;K extends Comparable&gt; extends Map&lt;&lt;K, MyValue&lt;K&gt;&gt; - the above map bound to a single generic parameter with an upper bound. It is a specialization of the above generic map which is also generic. Some decisions were bound, but there are still decisions to be bound. MyMap&lt;String&gt; theMap = ...; - fully bound map. Decisions are bound at variation point. For example, &ldquo;storage&rdquo; is a variation point, &ldquo;blob storage&rdquo; is one of alternatives, decision to use &ldquo;blob storage&rdquo; binds the variation point to a specific alternative. Decision binding forms a graph. Once you bind, say, &ldquo;storage&rdquo; variation point, some downstream alternatives may become unavailable because they are incompatible with that binding. Some might be available, but make no sense. For example, a decision to send data unencrypted over a public network is compatible with a decision to purchase some additional strong encryption hardware to use on-prem, but does it make business sense? Different alternatives feature different &ldquo;quality attributes&rdquo; - performance, reliability, cost. As the number of variation points and alternatives grows purely human-based decision making becomes inefficient. In this case variation points can be modeled as requirements and alternatives as capability providers or capabilities with quality attributes (seecapability). After this a list of &ldquo;designs&rdquo; (a.k.a. &ldquo;provisioning plans&rdquo;) can be created. A design/provisioning plan is a collection of compatible capabilities. If a list of designs is short enough it can be analyzed by humans directly. In the case of long lists or a large number of very similar designs decision analysis can be employed for making a selection of a design which is best fit for purpose. The page provides a general overview and the book goes into more details. â†©",
    "timestamp": 1769516721004
  },
  "nsd-cli/nsd/invoke/index.html": {
    "path": "CLI/nsd/invoke",
    "link-uuid": "f117fc8d-4bb0-4536-9fbd-53eaecad763b",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd invoke [-fhV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-p=&lt;String=String&gt;]... [-P=URL]... &lt;uri&gt; [&lt;bindings&gt;...] Invokes URI &lt;uri&gt; URI to invoke [&lt;bindings&gt;...] Bindings URIs -f, --file URI parameter is a file path -h, --help Show this help message and exit. -p, --property=&lt;String=String&gt; Property -P, --properties=URL Properties resource URL relative to the current directory. YAML, JSON, or properties. Type is inferred from the content type header, if it is present, or extension. Properties are loaded in the order of definition, later properties replacing the former --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Loads an invocable from a URI as explained in Loading Invocables from URIs and then invokes it with arguments obtained from parameters invocable URIs.",
    "timestamp": 1769516720800
  },
  "core/emf/index.html": {
    "path": "Core/EMF",
    "link-uuid": "716c10b4-61ab-48d2-8658-216be755201b",
    "title": "EMF",
    "content": "Sources Javadoc",
    "timestamp": 1769516720255
  },
  "nsd-cli/nsd/index.html": {
    "path": "CLI/nsd",
    "link-uuid": "c0d40ec6-ce5d-4f78-aa09-2afb92eaf2a6",
    "title": "nsd",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd [-hV] COMMAND Nasdanika Command Line Interface -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: launcher - Generates Java command line from directories of modules/jars app - HTML Application model commands drawio - Loads Drawio document from a URI or file gitlab - Commands for working with GitLab help - Outputs usage for all registred commands http-server - Serves HTTP routes invoke - Invokes URI java - Commands related to Java model - Loads EObject from a URI or file sql - Connects to a SQL database shell - Starts an interactive shell",
    "timestamp": 1769516720798
  },
  "nsd-cli/nsd/gitlab/contribute/retrospect/index.html": {
    "path": "CLI/nsd/gitlab/contribute/retrospect",
    "link-uuid": "5c602351-fd6c-4c94-a18b-51bda1b08449",
    "title": "retrospect",
    "content": "Usage: nsd gitlab contribute retrospect [-hV] [--ref=&lt;ref&gt;] [--since=&lt;since&gt;] [--until=&lt;until&gt;] [--path=&lt;paths&gt;]... &lt;project&gt; [COMMAND] Parent for sub-commands contributing based on history &lt;project&gt; Project ID or path -h, --help Show this help message and exit. --path=&lt;paths&gt; Paths of interest --ref=&lt;ref&gt; Reference - branch, tag, or commit --since=&lt;since&gt; Since date in ISO8601 format yyyy-MM-dd'T'HH:mm:ssZ --until=&lt;until&gt; Since date in ISO8601 format yyyy-MM-dd'T'HH:mm:ssZ -V, --version Print version information and exit. Commands: invoke - Invokes URI",
    "timestamp": 1769516720778
  },
  "nsd-cli/nsd/drawio/html-app/save/index.html": {
    "path": "CLI/nsd/drawio/html-app/save",
    "link-uuid": "94aed06e-1a90-4fe6-b3ce-15262bfef42d",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;] ... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720732
  },
  "nsd-cli/nsd/sql/metadata/ecore/html-app/save/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/html-app/save",
    "link-uuid": "4b1d5c70-48bb-4b35-a2a9-52a4129d40d0",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata ecore html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720967
  },
  "nsd-cli/nsd/sql/metadata/html-app/site/index.html": {
    "path": "CLI/nsd/sql/metadata/html-app/site",
    "link-uuid": "a4c8af95-d47f-4c3b-b69f-1e6340dd5850",
    "title": "site",
    "content": "Version: org.nasdanika.models.app.cli@2025.12.0 Usage: nsd sql metadata html-app site [-hlV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;baseDir&gt;] [-F=&lt;pageTemplateFile&gt;] [-m=&lt;domian&gt;] [-P=&lt;parallelism&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;pageErrors&gt;] [-t=&lt;timeout&gt;] [-T=&lt;pageTemplate&gt;] [-w=&lt;workDir&gt;] [-x=&lt;extension&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [-M=&lt;String=String&gt;]... [-e [=&lt;excludes&gt;...]]... [-i [=&lt;includes&gt;...]]... &lt;output&gt; Generates HTML site &lt;output&gt; Output directory relative to the base directory -b, --base-dir=&lt;baseDir&gt; Base directory -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former -e, --exclude[=&lt;excludes&gt;...] Output directory clean excludes Ant pattern -F, --page-template-file=&lt;pageTemplateFile&gt; Page template file relative to the current directory -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Output directory clean includes Ant pattern -l, --[no-]clean Clean working directory defaults to true -m, --domain=&lt;domian&gt; Sitemap domain -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --parallelism=&lt;parallelism&gt; If the value greater than one then an executor service is created and injected into the context to allow concurrent execution. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --errors=&lt;pageErrors&gt; Expected number of page errors -1 for any (not fail on errors) default is 0 -t, --timeout=&lt;timeout&gt; If parallelism is greater than one this option specifies timout in seconds awaiting completion of execution. Default value is 60. -T, --page-template=&lt;pageTemplate&gt; Page template URI relative to the current directory -V, --version Print version information and exit. -w, --work-dir=&lt;workDir&gt; Working directory -x, --extension=&lt;extension&gt; Extension of files to include in search and site map. Defaults to html Exit codes: Non-negative number Delegate result -1 Unhandled exception during execution -2 Invalid input -3 Diagnostic failed -4 Execution failed or was cancelled, successful rollback -5 Execution failed or was cancelled, rollback failed -6 Executor service termination timed out Example drawio diagram.drawio html-app -r root-action.yml --add-to-root site -r=-1 -F page-template.yml docs Grandparent drawio command loads diagram.drawio diagram resource Parent html-app command generates an html application model from the diagram elements This command: Loads a page template from page-template.yml Generates a documentation site ignoring page errors (-r=-1) Outputs the generated site to the docs directory Options -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r, --errors -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. -T, --page-template -r=-1 command line option means &ldquo;don&rsquo;t fail on page errors&rdquo; such as: Blank pages Broken internal links Missing resources Missing resources are reported on pages using danger alert blocks. If you want to prevent deployment of a site with page errors, don&rsquo;t use the option or set it to the expected number of errors - there might be &ldquo;known errors&rdquo; which you are OK to live with. ",
    "timestamp": 1769516720985
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/html-app/save/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/html-app/save",
    "link-uuid": "9c180453-d6e1-4e28-8666-b3e789df919a",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram to-model html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720852
  },
  "nsd-cli/nsd/drawio/save/index.html": {
    "path": "CLI/nsd/drawio/save",
    "link-uuid": "0b9c4986-3343-4fa9-bd59-85557980e358",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd drawio save [-hV] [--[no-]compress] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] &lt;output&gt; Saves diagram to a file &lt;output&gt; Output file --[no-]compress Compress output -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit.",
    "timestamp": 1769516720746
  },
  "nsd-cli/nsd/model/ecore/html-app/index.html": {
    "path": "CLI/nsd/model/ecore/html-app",
    "link-uuid": "0e563abd-b06a-4730-86a4-018841653d22",
    "title": "html-app",
    "content": "Version: org.nasdanika.models.ecore.cli@2025.12.0 Usage: nsd model ecore html-app [-fhRV] [-P=&lt;insertionIndex&gt;] [-r=&lt;rootLabel&gt;] [-c=&lt;String=String&gt;]... [-C=URL]... [--content-type-resource-factory=&lt;String=Class&gt;] ... [--extension-resource-factory=&lt;String=Class&gt;]... [-M=&lt;String=String&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... [COMMAND] Generates html application model from a model with links to type documentation -c, --context-entry=&lt;String=String&gt; Context entries. Shadow entries in contexts and mounts. -C, --context=URL Context resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Contexts are composed in the order of definition, later context entries shadowing the former --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -f, --file Root label option is a file path -h, --help Show this help message and exit. -M, --context-mount=&lt;String=String&gt; MappingContext resource URL relative to the current directory. YAML, JSON, or properties. In properties dots are treated as key path separators. Type is inferred from the content type header, if it is present, or extension. Mounts shadow context entries. -P, --position=&lt;insertionIndex&gt; Insertion position Defaults to 0 --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -r, --root-label=&lt;rootLabel&gt; Root label URL or file path, resolved relative to the current directory -R, --add-to-root Add labels to the root even if the principal is present -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model save - Saves model to a file site - Generates HTML site Options -r, --root-label -r, --root-label ",
    "timestamp": 1769516720872
  },
  "nsd-cli/nsd/model/catalog-diagram/to-model/save/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/to-model/save",
    "link-uuid": "9aa9d410-00e5-4d22-bb29-7e91e4699eb6",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram to-model save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720862
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/crew-ai",
    "link-uuid": "272b5b60-51d6-4ffe-b5b9-534090a60ac9",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720936
  },
  "core/exec/index.html": {
    "path": "Core/Exec",
    "link-uuid": "39b2ae0e-cc93-472c-a972-fd88cf635b72",
    "title": "Exec",
    "content": "Sources Javadoc Markdown This section demonstrates advanced capabilities of Markdown documentation provided by MarkdownDocumentationFactory. Embedded images You can embed PNG and JPEG using fenced blocks. PNG resource ```png-resource\nisa.png\n```\n Resource location is resolved relative to the diagram file location. JPEG resource ```jpeg-resource\nmy.jpeg\n```\n PNG ```png\nBase 64 encoded png \n```\n JPEG ```jpeg\nBase 64 encoded jpeg\n```\n Embedded diagrams You can also embed PlantUML, Drawio, and Mermaid diagrams using fenced blocks. Drawio ```drawio-resource\naws.drawio\n```\n Resource location is resolved in the same way as for image files as explained above. PlantUML PlantUML diagrams can be defined inline or loaded from resources. Loading from a resource ```uml-resource\nsequence.plantuml\n```\n Inline The following language specifications (dialects) are supported: uml - for the following diagram types: Sequence, Use Case, Class, Activity, Component, State, Object, Deployment, Timing, Network. wireframe - for Wireframe diagrams gantt - for Gantt diagrams mindmap - for Mind Maps wbs - for Work Breakdown Structures UML Sequence Fenced block: ```uml\nAlice -&gt; Bob: Authentication Request\nBob --&gt; Alice: Authentication Response\n```\n Diagram: Alice -&gt; Bob: Authentication Request Bob --&gt; Alice: Authentication Response Component Component diagram with links to component pages. Fenced block: ```uml\npackage Core {\n   component Common [[https://github.com/Nasdanika/core/tree/master/common]]\n}\n\npackage HTML {\n   component HTML as html [[https://github.com/Nasdanika/html/tree/master/html]]\n   [html] ..&gt; [Common]\n}\n```\n Diagram: package Core { component Common [[https://github.com/Nasdanika/core/tree/master/common]] } package HTML { component HTML as html [[https://github.com/Nasdanika/html/tree/master/html]] [html] ..&gt; [Common] } Wireframe Fenced block: ```wireframe\n{\n  Just plain text\n  [This is my button]\n  ()  Unchecked radio\n  (X) Checked radio\n  []  Unchecked box\n  [X] Checked box\n  &quot;Enter text here   &quot;\n  ^This is a droplist^\n}\n```\n Diagram: { Just plain text [This is my button] () Unchecked radio (X) Checked radio [] Unchecked box [X] Checked box &quot;Enter text here &quot; ^This is a droplist^ } Gantt Fenced block: ```gantt\n[Prototype design] lasts 15 days and links to [[https://docs.nasdanika.org/index.html]]\n[Test prototype] lasts 10 days\n-- All example --\n[Task 1 (1 day)] lasts 1 day\n[T2 (5 days)] lasts 5 days\n[T3 (1 week)] lasts 1 week\n[T4 (1 week and 4 days)] lasts 1 week and 4 days\n[T5 (2 weeks)] lasts 2 weeks\n```\n Diagram: [Prototype design] lasts 15 days and links to [[https://docs.nasdanika.org/index.html]] [Test prototype] lasts 10 days -- All example -- [Task 1 (1 day)] lasts 1 day [T2 (5 days)] lasts 5 days [T3 (1 week)] lasts 1 week [T4 (1 week and 4 days)] lasts 1 week and 4 days [T5 (2 weeks)] lasts 2 weeks Mind Map Fenced block: ```mindmap\n* Debian\n** [[https://ubuntu.com/ Ubuntu]]\n*** Linux Mint\n*** Kubuntu\n*** Lubuntu\n*** KDE Neon\n** LMDE\n** SolydXK\n** SteamOS\n** Raspbian with a very long name\n*** &lt;s&gt;Raspmbc&lt;/s&gt; =&gt; OSMC\n*** &lt;s&gt;Raspyfi&lt;/s&gt; =&gt; Volumio\n```\n Diagram: * Debian ** [[https://ubuntu.com/ Ubuntu]] *** Linux Mint *** Kubuntu *** Lubuntu *** KDE Neon ** LMDE ** SolydXK ** SteamOS ** Raspbian with a very long name *** &lt;s&gt;Raspmbc&lt;/s&gt; =&gt; OSMC *** &lt;s&gt;Raspyfi&lt;/s&gt; =&gt; Volumio WBS WBS elements can have links. This type of diagram can also be used to display organization structure. ```wbs\n* [[https://docs.nasdanika.org/index.html Business Process Modelling WBS]]\n** Launch the project\n*** Complete Stakeholder Research\n*** Initial Implementation Plan\n** Design phase\n*** Model of AsIs Processes Completed\n**** Model of AsIs Processes Completed1\n**** Model of AsIs Processes Completed2\n*** Measure AsIs performance metrics\n*** Identify Quick Wins\n** Complete innovate phase\n```\n Fenced block: Diagram: * [[https://docs.nasdanika.org/index.html Business Process Modelling WBS]] ** Launch the project *** Complete Stakeholder Research *** Initial Implementation Plan ** Design phase *** Model of AsIs Processes Completed **** Model of AsIs Processes Completed1 **** Model of AsIs Processes Completed2 *** Measure AsIs performance metrics *** Identify Quick Wins ** Complete innovate phase Mermaid You can define Mermaid diagrams in mermaid fenced blocks: flowchart LR\n   Alice --&gt; Bob &amp; Chuck --&gt; Deb\n results in this diagram: flowchart LR Alice --&gt; Bob &amp; Chuck --&gt; Deb Loading from a resource It is also possible to load a diagram definition from a resource resolved relative to the model resource: ```mermaid-resource\nsequence.mermaid\n```\n Extensions Table of contents - add [TOC] to the document as explained in the documentation. This extension will create a table of contents from markdown headers. Footnotes Strikethrough: ~~strikethrough~~-&gt; strikethrough Subscript: H~2~O -&gt; H20 Superscript: 2^5^ = 32 -&gt; 25 = 32",
    "timestamp": 1769516720262
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model",
    "link-uuid": "0e28be1b-be31-44e2-8486-9fd2eb722e83",
    "title": "to-model",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model [-hV] [COMMAND] Converts diagram to diagram model -h, --help Show this help message and exit. -V, --version Print version information and exit. Commands: crew-ai - Generates CrewAI code and configuration from a model html-app - Generates html application model from a model save - Saves model to a file",
    "timestamp": 1769516720951
  },
  "nsd-cli/nsd/gitlab/contribute/junit/index.html": {
    "path": "CLI/nsd/gitlab/contribute/junit",
    "link-uuid": "731da718-3bf1-49ac-8f8b-5346550505ac",
    "title": "junit",
    "content": "Version: org.nasdanika.models.java.cli@2025.12.0 Usage: nsd gitlab contribute junit [-fhVw] [--[no-]ai] [--[no-] comment-response] [--disabled] [--progress-console] [--progress-data] [--progress-json] [--api-endpoint=&lt;apiEndpoint&gt;] [--class-suffix=&lt;classSuffix&gt;] [-k=&lt;apiKey&gt;] [-l=&lt;limit&gt;] [-m=&lt;deploymentOrModelName&gt;] [--package-suffix=&lt;packageSuffix&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [-r=&lt;prompt&gt;] [-s=&lt;sources&gt;] [-t=&lt;coverageType&gt;] [-v=&lt;apiKeyEnvironmentVariable&gt;] [-e [=&lt;excludes&gt;...]]... [-i[=&lt;includes&gt;...]]... &lt;projectURI&gt; &lt;coverageThreshold&gt; &lt;output&gt; [COMMAND] Generates JUnit tests &lt;projectURI&gt; Project URI &lt;coverageThreshold&gt; Coverage threshold &lt;output&gt; Output URI relative to the project URI --[no-]ai Use AI, defaults to true --api-endpoint=&lt;apiEndpoint&gt; OpenAPI endpoint, defaults to https://api.openai.com/v1/chat/completions --class-suffix=&lt;classSuffix&gt; Test class suffix defaults to Tests --[no-]comment-response Comment AI responses defaults to true --disabled Generate disabled tests -e, --exclude[=&lt;excludes&gt;...] Source excludes Ant pattern -f Project URI is a file path -h, --help Show this help message and exit. -i, --include[=&lt;includes&gt;...] Source includes Ant pattern -k, --api-key=&lt;apiKey&gt; OpenAPI key -l, --limit=&lt;limit&gt; Maximum number of test classes to generate -m, --model=&lt;deploymentOrModelName&gt; OpenAPI deployment or model defaults to gpt-4 --package-suffix=&lt;packageSuffix&gt; Test package suffix defaults to .tests --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -r, --prompt=&lt;prompt&gt; Propmt defaults to 'Generate a JUnit 5 test method leveraging Mockito for the following Java method' -s, --sources=&lt;sources&gt; Sources URI path relative to the project URIy, defaults to src/main/java -t, --coverage-type=&lt;coverageType&gt; Coverage type Valid values: complexity, instruction, branch, line defaults to line -v, --api-key-variable=&lt;apiKeyEnvironmentVariable&gt; OpenAPI key environment variable defaults to OPENAI_API_KEY -V, --version Print version information and exit. -w, --overwrite Overwrite existing tests Commands: jacoco - Loads coverage from jacoco.exec and classes directory",
    "timestamp": 1769516720772
  },
  "nsd-cli/nsd/model/catalog-diagram/invoke/index.html": {
    "path": "CLI/nsd/model/catalog-diagram/invoke",
    "link-uuid": "06b70f9c-189f-4cde-9337-7e9fed08235f",
    "title": "invoke",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model catalog-diagram invoke [-hV] [--progress-console] [--progress-data] [--progress-json] [-b=&lt;bindProperty&gt;] [-c=&lt;connectionBase&gt;] [-p=&lt;processorProperty&gt;] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [&lt;parameters&gt;...] Creates an Invocable dynamic proxy from a diagram calls it with command parameters and returns result [&lt;parameters&gt;...] Invocable parameters -b, --bind-property=&lt;bindProperty&gt; Bind property providing dynamic proxy method name Defaults to bind -c, --connection-base=&lt;connectionBase&gt; Connection base Valid values: PARENT, SOURCE, TARGET -h, --help Show this help message and exit. -p, --processor-property=&lt;processorProperty&gt; Processor property Defaults to processor --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor -V, --version Print version information and exit. Example drawio -p my-property=&quot;My property&quot; invocable.drawio invoke 33 66 The parent drawio command loads invocable.drawio diagram with my-property property set to My property. This property is used for placeholder expansion. This command: Uses default values for --processor-property and --bind-property options to create diagram element processors and bind them to dynamic proxy methods - in this case a single invoke() method. Calls the method with command line arguments - 33 and 66 Options -p, --processor-property -p, --processor-property ",
    "timestamp": 1769516720836
  },
  "nsd-cli/nsd/sql/metadata/ecore/crew-ai/index.html": {
    "path": "CLI/nsd/sql/metadata/ecore/crew-ai",
    "link-uuid": "e4f8dd37-9171-45bb-a300-d00f2ed1305b",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd sql metadata ecore crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=C lass&gt;]... [--extension-resource-factory=&lt;String=Clas s&gt;]... [--protocol-resource-factory=&lt;String=Class &gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720958
  },
  "core/index.html": {
    "link-uuid": "6ea0dac2-aedd-40b5-8767-cb3614862ab2",
    "title": "Core",
    "content": "Sources",
    "timestamp": 1769516720309
  },
  "nsd-cli/nsd/sql/metadata/save/index.html": {
    "path": "CLI/nsd/sql/metadata/save",
    "link-uuid": "a68cbb40-3076-4df5-8ec9-2172d1eae934",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720991
  },
  "practices/generic/index.html": {
    "path": "Practices/Analysis, Visualization &amp; Generation",
    "link-uuid": "6a8fd92a-b05f-4863-b029-26faca0d5c02",
    "title": "Analysis, Visualization &amp; Generation",
    "content": "This practice explains how to use Nasdanika products (specifically models) and related products. The above diagram shows the core idea - load input data into a model, modify the model or create a new model from it, and save the models to native (raw) formats. Loading to a model as opposed to working with raw formats gives the following benefits: Unified API Generated model documentation with visualizations Different models may extend classes from core models and be treated similarly Model classes may be subclassed and mixed Cross-reference model elements URI handlers allows to load models from diverse sources On-demand loading of resources and features of model elements Conversion of models to graphs and making them executable with graph processors E.g. want to read/write Excel files - take a look at the Excel metamodel and then use Ecore API to work with the model. Now want to work with PDF? A different metamodel, the same model API. You have Java sources stored in GitLab and want model elements to reflect both Java and GitLab natures of your sources? Create a GitLabRepositoryCompilationUnit class which extends both Compilation Unit and Repository File. Customize Loader to create this class for repository files with java extension. Want to load a PDF file directly from GitLab without having to clone the entire repository? Use GitLabURIHandler! The below diagram illustrates the above concepts: Models can be visualized using: ECharts using the ECharts model, ECharts-Java or by directly generating JavaScript/JSON. Example. PlantUML using DiagramGenerator, the diagram module or by directly generating PlantUML text and calling Plant UML API&rsquo;s. Example. Holistic model of an organization One use case for the modeling approach outlined above is creation of a holistic model of an organization/corporation as exemplified by the below diagram1 In a corporation different elements of the model are typically stored in different systems and documents like Excel spreadsheets. The modeling approach allows to load those elements in a single resource set and cross-reference them. Elements which are not stored in structured formats can be captured by modeling them in diagrams and mapping those diagrams to models, see Beyond Diagrams. One important reason why a holistic model might be beneficial for an organization is the ability of using it for AI insights. For example, using RAG/Chat on top of the organization model. Such chat can be made context-aware, chatting with the Operations will return result relevant to operations. The above diagram is very simple, a large organization may have many layers, thousands of applications, millions of lines of code. A model for such an organization would take some time to build, but it can be built incrementally - department by department, application by application. The value of building such a model will grow exponentially as more and more elements are added due to the network effect. While the resulting model might be &ldquo;large&rdquo;, &hellip; define large. Experiments show that a model element in a model like the above takes ~ 500 bytes of RAM. As such, 1 GB of RAM would hold about 2 million model elements. Also, model resources are loaded on demand, so only the model elements needed by some task would be loaded to complete that task. With DynamicDelegate it is possible to have model elements loading their data from multiple sources on demand. The organization model can be built on top of existing &ldquo;generic&rdquo; models such as Java, Maven, GitLab, Azure, &hellip; Resources TOGAF Enterprise Metamodel Corporate structure â†© Output Model Transformation Input Model Raw Input Raw Output Transformation Cell Excel Resource Paragraph PDF Resource Resource Set GitLab URI Handler MS Excel Workbook GitLab Excel Resource Factory PDF Resource Factory PDF File File system Transformation Corporation Marketing Finance Uses Operations HR Builds IT Execution environments Binary packages Source Code Application Transformation",
    "timestamp": 1769516721001
  },
  "nsd-cli/nsd/sql/metadata/catalog-diagram/to-model/html-app/save/index.html": {
    "path": "CLI/nsd/sql/metadata/catalog-diagram/to-model/html-app/save",
    "link-uuid": "90aaa7f9-a133-43f7-b105-07092def5ca5",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata catalog-diagram to-model html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720945
  },
  "nsd-cli/nsd/model/ecore/html-app/save/index.html": {
    "path": "CLI/nsd/model/ecore/html-app/save",
    "link-uuid": "2b2fdbdf-c1a4-4e39-852f-1953cddde5a7",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd model ecore html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Cl ass&gt;]... [--extension-resource-factory=&lt;String=Class &gt;]... [--protocol-resource-factory=&lt;String=Class&gt; ]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720875
  },
  "nsd-cli/nsd/sql/metadata/html-app/save/index.html": {
    "path": "CLI/nsd/sql/metadata/html-app/save",
    "link-uuid": "9d69cfae-d2fd-480f-9936-8545406936c8",
    "title": "save",
    "content": "Version: org.nasdanika.cli@2025.12.0 Usage: nsd sql metadata html-app save [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=C lass&gt;]... [--extension-resource-factory=&lt;String=Clas s&gt;]... [--protocol-resource-factory=&lt;String=Class &gt;]... &lt;output&gt; Saves model to a file &lt;output&gt; Output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720983
  },
  "nsd-cli/nsd/drawio/to-model/html-app/crew-ai/index.html": {
    "path": "CLI/nsd/drawio/to-model/html-app/crew-ai",
    "link-uuid": "377cb78c-b6d0-4e3e-ab8e-553c99b3c88d",
    "title": "crew-ai",
    "content": "Version: org.nasdanika.models.crewai.cli@2025.12.0 Usage: nsd drawio to-model html-app crew-ai [-hV] [--progress-console] [--progress-data] [--progress-json] [--progress-logger=&lt;progressLogger&gt;] [--progress-output=&lt;progressOutput&gt;] [--content-type-resource-factory=&lt;String=Class&gt;]... [--extension-resource-factory=&lt;String=Class&gt;]... [--protocol-resource-factory=&lt;String=Class&gt;]... &lt;output&gt; Generates CrewAI code and configuration from a model &lt;output&gt; Crew class output file --content-type-resource-factory=&lt;String=Class&gt; Maps content type to resource factory class --extension-resource-factory=&lt;String=Class&gt; Maps extension to resource factory class -h, --help Show this help message and exit. --progress-console Output progress to console --progress-data Output progress data --progress-json Output progress in JSON --progress-logger=&lt;progressLogger&gt; Output logger for progress monitor --progress-output=&lt;progressOutput&gt; Output file for progress monitor --protocol-resource-factory=&lt;String=Class&gt; Maps protocol to resource factory class -V, --version Print version information and exit.",
    "timestamp": 1769516720751
  },
  "nsd-cli/nsd/help/index.html": {
    "path": "CLI/nsd/help",
    "link-uuid": "d872af75-d749-4fc0-abb7-e9ab42909702",
    "title": "help",
    "content": "Usage: nsd help [-ahHV] [-l=&lt;level&gt;] [-o=&lt;output&gt;] [COMMAND] Outputs usage for all registred commands -a, --action-model Output to action model -h, --help Show this help message and exit. -H, --html Output to HTML -l, --header-level=&lt;level&gt; Starting level for HTML header tags in HTML output, the default value is 1. -o, --output=&lt;output&gt; Output file -V, --version Print version information and exit. Commands: site - Generates help HTML site",
    "timestamp": 1769516720789
  }
}