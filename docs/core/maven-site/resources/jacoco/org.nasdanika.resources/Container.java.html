<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Container.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika Resources</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.resources</a> &gt; <span class="el_source">Container.java</span></div><h1>Container.java</h1><pre class="source lang-java linenums">package org.nasdanika.resources;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;

import org.nasdanika.common.DefaultConverter;
import org.nasdanika.common.ProgressMonitor;

/**
 * Container of entries and other containers provides an abstraction for dealing with hierarchies/trees.
 * While a container does not necessarily have an out-of-JVM representation it extends {@link Resource} for convenience because these two 
 * interfaces share common characteristics.
 * @author Pavel
 *
 * @param &lt;E&gt; Element type.
 */
public interface Container&lt;E&gt; extends Resource&lt;E&gt; {
	
	/**
	 * Finds an existing element or container with a given path.
	 * @param path Child resource path. 
	 * @return Element if it exists or null.
	 */
	Object find(String path, ProgressMonitor monitor);
	
	/**
	 * @param path
	 * @return Element at the path or null if the element does not exist, is not created on access, or it would not be possible to create such an entity, e.g. a container with this path already exists, or one of path elements is not a container.
	 */
	E get(String path, ProgressMonitor monitor);
	
	/**
	 * 
	 * @param path Element path
	 * @param element Element
	 * @throws IllegalArgumentException if it is not possible to put an element at this path. E.g. getContainer(parent path) returns null.
	 */
	void put(String path, E element, ProgressMonitor monitor) throws IllegalArgumentException;
	
	/**
	 * Deletes an element or container at a given path.
	 * @param path
	 * @return Removed element/container or null if it did not exist or the container removed it without retrieving. 
	 */
	Object delete(String path, ProgressMonitor monitor);
	
	/**
	 * Gets an element from the container creating it using a factory if it doesn't already exist.
	 * @param path Path.
	 * @param factory Factory
	 * @throws IllegalArgumentException If it is not possible to put element at the given path.
	 * @return
	 */
	default E get(String path, BiFunction&lt;String,ProgressMonitor,E&gt; factory, ProgressMonitor monitor) throws IllegalArgumentException {
		try {
<span class="nc" id="L67">			E ret = get(path, monitor.split(&quot;Getting existing element&quot;, 1));</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">			if (ret == null &amp;&amp; factory != null) {			</span>
<span class="nc" id="L69">				ret = factory.apply(path, monitor.split(&quot;Creating a new element&quot;, 1, path));</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">				if (ret != null) {</span>
<span class="nc" id="L71">					put(path, ret, monitor.split(&quot;Putting a new element&quot;, 1, path, ret));</span>
				}
			}
<span class="nc" id="L74">			return ret;</span>
		} finally {
<span class="nc" id="L76">			monitor.close();</span>
		}
	}
	
	/**
	 * Returns a container for a given path. It is a logical operation - the container doesn't have to exist.
	 * @param path
	 * @return Container instance or null if it would not be possible to create such a container, e.g. an element with this path already exists or one of path elements is not a container.
	 */
	Container&lt;E&gt; getContainer(String path, ProgressMonitor monitor);
	
	/**
	 * Lists existing children.
	 * @return A list of existing children. May return null for containers where children can't be retrieved, e.g. write-only containers.
	 */
	Map&lt;String, Object&gt; getChildren(ProgressMonitor monitor);
	
	interface Copier&lt;T,R&gt; {
		
		/**
		 * Makes a copy of an element, merges with the existing value.
		 * @param element
		 * @param existingChild Existing child in the target container - element or sub-container.
		 * @param monitor
		 * @return
		 */
		R copy(String path, T source, Object existingElement, ProgressMonitor monitor);	
		
	}
		
	/**
	 * Recursively copies children to another container.
	 * @param &lt;F&gt; Element type of the other container.
	 * @param container Target container.
	 * @param copier Copier of elements, converting type, and merging with the existing element if it is present. The first argument is 
	 * element being copied, the second is an existing element or null if there is no such element.
	 * @param monitor Progress monitor
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default &lt;F&gt; void copy(Container&lt;F&gt; target, Copier&lt;E,F&gt; copier, ProgressMonitor monitor) {
		try {
<span class="nc" id="L117">			Map&lt;String, Object&gt; children = getChildren(monitor.split(&quot;Getting children&quot;, 1, this));		</span>
<span class="nc" id="L118">			try (ProgressMonitor subMonitor = monitor.split(&quot;Copying &quot;+getPath(), children.size(), this)) {</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				if (children != null) {				</span>
<span class="nc" id="L120">					children.forEach((path, child) -&gt; {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">						if (child instanceof Container) {</span>
<span class="nc" id="L122">							Container&lt;F&gt; targetChild = target.getContainer(path, monitor.split(&quot;Getting container &quot;+path, 1));</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">							if (targetChild == null) {</span>
<span class="nc" id="L124">								throw new IllegalArgumentException(&quot;Cannot obtain target container for path &quot;+path);</span>
							}
<span class="nc" id="L126">							((Container&lt;E&gt;) child).copy(targetChild, copier, subMonitor);</span>
<span class="nc" id="L127">						} else {</span>
<span class="nc" id="L128">							F copy = copier.copy(path, (E) child, target.find(path, subMonitor.split(&quot;Finiding&quot;, 1, path)), subMonitor.split(&quot;Copying &quot;+path, 1));</span>
<span class="nc" id="L129">							target.put(path, copy, subMonitor.split(&quot;Putting copied element&quot;, 1, path, copy)); </span>
						}
<span class="nc" id="L131">					});</span>
				}
			}
		} finally {
<span class="nc" id="L135">			monitor.close();</span>
		}
<span class="nc" id="L137">	}</span>
	
	/**
	 * Recursively moves children - copies and then removes.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default &lt;F&gt; void move(Container&lt;F&gt; target, Copier&lt;E,F&gt; copier, ProgressMonitor monitor) {
		try {
<span class="nc" id="L145">			Map&lt;String, Object&gt; children = getChildren(monitor.split(&quot;Getting children&quot;, 1, this));		</span>
<span class="nc" id="L146">			try (ProgressMonitor subMonitor = monitor.split(&quot;Copying &quot;+getPath(), children.size(), this)) {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">				if (children != null) {	</span>
<span class="nc" id="L148">					Collection&lt;String&gt; paths = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L149">					children.forEach((path, child) -&gt; {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">						if (child instanceof Container) {</span>
<span class="nc" id="L151">							Container&lt;F&gt; targetChild = target.getContainer(path, monitor.split(&quot;Getting container &quot;+path, 1));</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">							if (targetChild == null) {</span>
<span class="nc" id="L153">								throw new IllegalArgumentException(&quot;Cannot obtain target container for path &quot;+path);</span>
							}
<span class="nc" id="L155">							((Container&lt;E&gt;) child).move(targetChild, copier, subMonitor);</span>
<span class="nc" id="L156">						} else {</span>
<span class="nc" id="L157">							F copy = copier.copy(path, (E) child, target.find(path, subMonitor.split(&quot;Finiding&quot;, 1, path)), subMonitor.split(&quot;Copying &quot;+path, 1));</span>
<span class="nc" id="L158">							target.put(path, copy, subMonitor.split(&quot;Putting copied element&quot;, 1, path, copy)); </span>
						}
<span class="nc" id="L160">						paths.add(path);</span>
<span class="nc" id="L161">					});</span>
<span class="nc" id="L162">					paths.forEach(path -&gt; delete(path, monitor.split(&quot;Removing&quot;, 1, path)));</span>
				}
			}
		} finally {
<span class="nc" id="L166">			monitor.close();</span>
		}
<span class="nc" id="L168">	}	</span>
	
	/**
	 * Adapts to a different element type.
	 * @param &lt;F&gt; Element type to adapt to
	 * @param adapter Adapts element E to target type F. Takes element path and the element itself.
	 * @param converter Converts element F to E on put and get with a factory. Takes element path and the element itself. 
	 * @return
	 */
	default &lt;F&gt; Container&lt;F&gt; adapt(BiFunction&lt;String,? super E,F&gt; adapter, BiFunction&lt;String,? super F,E&gt; converter) {
<span class="fc" id="L178">		return new Container&lt;F&gt;() {</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Object find(String path, ProgressMonitor monitor) {
<span class="nc" id="L183">				Object ret = Container.this.find(path, monitor);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">				if (ret instanceof Container) {</span>
<span class="nc" id="L185">					return ((Container&lt;E&gt;) ret).adapt(adapter, converter);</span>
				}
<span class="nc" id="L187">				return adapter.apply(path, (E) ret);</span>
			}

			@Override
			public F get(String path, ProgressMonitor monitor) {
<span class="fc" id="L192">				return adapter.apply(path, Container.this.get(path, monitor));</span>
			}

			@Override
			public void put(String path, F element, ProgressMonitor monitor) throws IllegalArgumentException {
<span class="nc" id="L197">				Container.this.put(path, converter.apply(path, element), monitor);				</span>
<span class="nc" id="L198">			}</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Object delete(String path, ProgressMonitor monitor) {
<span class="nc" id="L203">				Object deleted = Container.this.delete(path, monitor);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">				if (deleted instanceof Container) {</span>
<span class="nc" id="L205">					return ((Container&lt;E&gt;) deleted).adapt(adapter, converter);</span>
				}
<span class="nc" id="L207">				return adapter.apply(path, (E) deleted);</span>
			}

			@Override
			public Container&lt;F&gt; getContainer(String path, ProgressMonitor monitor) {
<span class="nc" id="L212">				Container&lt;E&gt; ret = Container.this.getContainer(path, monitor);</span>
<span class="nc" id="L213">				return ret.adapt(adapter, converter);</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Map&lt;String, Object&gt; getChildren(ProgressMonitor monitor) {
<span class="nc" id="L219">				Map&lt;String, Object&gt; ret = new HashMap&lt;&gt;();</span>
<span class="nc" id="L220">				Container.this.getChildren(monitor).forEach((path, child) -&gt; {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">					if (child instanceof Container) {</span>
<span class="nc" id="L222">						ret.put(path, ((Container&lt;E&gt;) ret).adapt(adapter, converter));</span>
					} else {
<span class="nc" id="L224">						ret.put(path, adapter.apply(path, (E) child));</span>
					}					
<span class="nc" id="L226">				}); </span>
<span class="nc" id="L227">				return Collections.unmodifiableMap(ret);</span>
			}

			@Override
			public Container&lt;F&gt; getParent() {
<span class="nc" id="L232">				return Container.this.getParent().adapt(adapter, converter);</span>
			}

			@Override
			public String getName() {
<span class="nc" id="L237">				return Container.this.getName();</span>
			}

			@Override
			public void copy(Container&lt;? super F&gt; container, String path, ProgressMonitor monitor) {
<span class="nc" id="L242">				throw new UnsupportedOperationException(&quot;Implement when this one is thrown&quot;);</span>
			}

			@Override
			public void move(Container&lt;? super F&gt; container, String path, ProgressMonitor monitor) {
<span class="nc" id="L247">				throw new UnsupportedOperationException(&quot;Implement when this one is thrown&quot;);</span>
			}
			
			@Override
			public String toString() {
<span class="nc" id="L252">				return getClass().getName()+&quot;(&quot;+getPath()+&quot;)&quot;;</span>
			}
			
		};
	}
	
	/**
	 * Filters this container to return null for getParent() so this container is considered to be a root container.
	 * @return
	 */
	default Container&lt;E&gt; asRoot() {
<span class="nc" id="L263">		return new ContainerFilter&lt;E&gt;(this) {</span>

			@Override
			public Container&lt;E&gt; getParent() {
<span class="nc" id="L267">				return null;</span>
			}
			
		};
	}
	
	/**
	 * TODO - filter -&gt; read predicate, write predicate
	 * Filters this container. 
	 * @param filter Child path filter. 
	 * @return
	 */
	default Container&lt;E&gt; filter(Predicate&lt;String&gt; filter) {
<span class="nc" id="L280">		return new ContainerFilter&lt;E&gt;(this) {</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Map&lt;String, Object&gt; getChildren(ProgressMonitor monitor) {
<span class="nc" id="L285">				Map&lt;String, Object&gt; ret = new HashMap&lt;&gt;();</span>
<span class="nc" id="L286">				Container.this.getChildren(monitor).forEach((path, child) -&gt; {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">					if (filter.test(path)) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">						if (child instanceof Container) {</span>
<span class="nc" id="L289">							ret.put(path, ((Container&lt;E&gt;) ret).filter(filter));</span>
						} else {
<span class="nc" id="L291">							ret.put(path, child);</span>
						}
					}
<span class="nc" id="L294">				}); </span>
<span class="nc" id="L295">				return Collections.unmodifiableMap(ret);</span>
			}
			
			
			@Override
			public Object find(String path, ProgressMonitor monitor) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">				return filter.test(path) ? super.find(path, monitor) : null;</span>
			}
			
			@Override
			public Container&lt;E&gt; getContainer(String path, ProgressMonitor monitor) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">				return filter.test(path) ? super.getContainer(path, monitor).filter(filter) : null;</span>
			}
			
			@Override
			public E get(String path, ProgressMonitor monitor) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">				return filter.test(path) ? super.get(path, monitor) : null;</span>
			}
			
			@Override
			public void put(String path, E element, ProgressMonitor monitor) throws IllegalArgumentException {
<span class="nc bnc" id="L316" title="All 2 branches missed.">				if (!filter.test(path)) {</span>
<span class="nc" id="L317">					throw new IllegalArgumentException(&quot;Path doesn't match the filter: &quot;+path);</span>
				}
<span class="nc" id="L319">				super.put(path, element, monitor);</span>
<span class="nc" id="L320">			}</span>
			
		};
	}
	
	/**
	 * Loads entries from a {@link ZipInputStream} into this container. This method used getXXX() methods to obtain container children.
	 * If getXXX() method returns null of if {@link Entity} entry is not null and canWrite() returns false then an exception is thrown.
	 * @param zipInputStream ZipInputStream.
	 * @param filter Entry name filter. Can be null.
	 * @param contentLoader Converts input stream to the element type. The first argument is the path.
	 * @param progressMonitor Progress monitor.
	 * @throws IOException
	 */
	default void load(
			ZipInputStream zipInputStream, 
			Predicate&lt;String&gt; filter, 
			Copier&lt;InputStream,E&gt; contentLoader, 
			ProgressMonitor progressMonitor) throws IOException {
		
		try {
			ZipEntry zipEntry;
<span class="nc bnc" id="L342" title="All 2 branches missed.">			while ((zipEntry = zipInputStream.getNextEntry()) != null) {</span>
<span class="nc" id="L343">				try (ProgressMonitor entryMonitor = progressMonitor.split(&quot;Entry &quot;+zipEntry.getName(), 1, zipEntry)) {</span>
<span class="nc" id="L344">					String entryName = zipEntry.getName();</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">					if (filter == null || filter.test(entryName)) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">						if (entryName.endsWith(&quot;/&quot;)) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">							if (getContainer(entryName.substring(0, entryName.length() - 1), entryMonitor.split(&quot;Getting container &quot;+entryName, 1)) == null) {</span>
<span class="nc" id="L348">								throw new IOException(&quot;Container with path &quot;+entryName+&quot; cannot be created&quot;);</span>
							}
						} else {
<span class="nc" id="L351">							E element = contentLoader.copy(entryName, zipInputStream, get(entryName, entryMonitor.split(&quot;Getting existing&quot;, 1, entryName)), entryMonitor.split(&quot;Loading &quot;+entryName, 1));</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">							if (element != null) {</span>
<span class="nc" id="L353">								put(entryName, element, entryMonitor.split(&quot;Putting copied element&quot;, 1, entryName, element));</span>
							}
						}
					}
<span class="nc" id="L357">					zipInputStream.closeEntry();</span>
				}
			}
		} finally {
<span class="nc" id="L361">			progressMonitor.close();</span>
<span class="nc" id="L362">			zipInputStream.close();</span>
		}
<span class="nc" id="L364">	}</span>
	
	/**
	 * Stores children of this container to a {@link ZipOutputStream}. 
	 * @param zipOutputStream Zip output stream. This method does not close the stream.
	 * @param prefix Optional path prefix.
	 * @param contentSerializer Converts entity state to the input stream. If null then {@link DefaultConverter}.INSTANCE is used to convert content to {@link InputStream}
	 * @param progressMonitor Progress monitor.
	 * @throws IOException
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default void store(
		ZipOutputStream zipOutputStream, 
		String prefix,
		Copier&lt;E,InputStream&gt; contentSerializer, 
		ProgressMonitor progressMonitor) throws IOException {
		
		try {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">			if (contentSerializer == null) {</span>
<span class="nc" id="L383">				contentSerializer = (path, source, existingElement, monitor) -&gt; DefaultConverter.INSTANCE.convert(source, InputStream.class);</span>
			}
			
<span class="fc bfc" id="L386" title="All 2 branches covered.">			if (prefix == null) {</span>
<span class="fc" id="L387">				prefix = &quot;&quot;;</span>
			}
			
<span class="fc bfc" id="L390" title="All 2 branches covered.">			for (Entry&lt;String, Object&gt; childEntry: getChildren(progressMonitor.split(&quot;Getting children&quot;, 1, this)).entrySet()) {</span>
<span class="fc" id="L391">				try (ProgressMonitor childMonitor = progressMonitor.split(&quot;Child &quot;+childEntry.getKey(), 1, childEntry.getValue())) {</span>
<span class="fc bfc" id="L392" title="All 2 branches covered.">					if (childEntry.getValue() instanceof Container) {</span>
<span class="fc" id="L393">						zipOutputStream.putNextEntry(new ZipEntry(prefix+&quot;/&quot;+childEntry.getKey()+&quot;/&quot;));</span>
<span class="fc" id="L394">						zipOutputStream.closeEntry();</span>
<span class="fc" id="L395">						((Container&lt;E&gt;) childEntry.getValue()).store(zipOutputStream, prefix+childEntry.getKey()+&quot;/&quot;, contentSerializer, childMonitor);</span>
					} else {
<span class="fc" id="L397">						zipOutputStream.putNextEntry(new ZipEntry(prefix+childEntry.getKey()));</span>
<span class="fc" id="L398">						try (InputStream contents = contentSerializer.copy(childEntry.getKey(), (E) childEntry.getValue(), null, childMonitor)) {</span>
							int b;
<span class="fc bfc" id="L400" title="All 2 branches covered.">							while ((b = contents.read()) != -1) {</span>
<span class="fc" id="L401">								zipOutputStream.write(b);</span>
							}
						}
<span class="fc" id="L404">						zipOutputStream.closeEntry();				</span>
					}
				}
<span class="fc" id="L407">			}</span>
		} finally {
<span class="fc" id="L409">			progressMonitor.close();</span>
		}
<span class="fc" id="L411">	}</span>
	
	/**
	 * Deletes all children and then deletes this container from its parent.
	 * @param monitor
	 */
	default void delete(ProgressMonitor monitor) {
<span class="fc" id="L418">		new HashMap&lt;&gt;(getChildren(monitor.split(&quot;Getting children&quot;, 1))).forEach((path, child) -&gt; delete(path, monitor.split(&quot;Removing child &quot;+path, 1, path, child)));		</span>
<span class="fc" id="L419">		Container&lt;E&gt; parent = getParent();</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">		if (parent != null) {</span>
<span class="fc" id="L421">			parent.delete(getName(), monitor.split(&quot;Removing self from the parent&quot;, 1, this));</span>
		}		
<span class="fc" id="L423">	}</span>
	
	default long size(ProgressMonitor monitor) {
<span class="nc" id="L426">		long[] ret = {0};</span>
<span class="nc" id="L427">		getChildren(monitor.split(&quot;Getting children&quot;, 1, this)).forEach((path, child) -&gt; {;</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">			if (child instanceof Resource &amp;&amp; ((Resource&lt;?&gt;) child).exists(monitor.split(&quot;Checking child existence&quot;, 1, child))) {</span>
<span class="nc" id="L429">				ret[0] += ((Resource&lt;?&gt;) child).size(monitor.split(&quot;Getting child size &quot;+path, 1, child));</span>
			}
<span class="nc" id="L431">		});</span>
<span class="nc" id="L432">		return ret[0];</span>
	}
		
	/**
	 * Returns true if contains any existing resources.
	 */
	default boolean exists(ProgressMonitor monitor) {
<span class="nc" id="L439">		Map&lt;String, Object&gt; children = getChildren(monitor.split(&quot;Getting children&quot;, 1, this));</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">		for (Object child: children.values()) {</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">			if (child instanceof Resource &amp;&amp; ((Resource&lt;?&gt;) child).exists(monitor.split(&quot;Checking child existence&quot;, 1, child))) {</span>
<span class="nc" id="L442">				return true;</span>
			}
<span class="nc" id="L444">		};</span>
<span class="nc" id="L445">		return false;		</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>