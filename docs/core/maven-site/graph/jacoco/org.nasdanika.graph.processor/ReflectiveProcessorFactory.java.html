<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ReflectiveProcessorFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika Graph</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.graph.processor</a> &gt; <span class="el_source">ReflectiveProcessorFactory.java</span></div><h1>ReflectiveProcessorFactory.java</h1><pre class="source lang-java linenums">package org.nasdanika.graph.processor;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletionStage;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.nasdanika.common.NasdanikaException;
import org.nasdanika.common.ProgressMonitor;
import org.nasdanika.common.Util;
import org.nasdanika.graph.Connection;
import org.nasdanika.graph.Element;
import org.nasdanika.graph.Node;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.EvaluationException;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;

/**
 * Creates processor and wires hanlders and endpoints using annotations. 
 * @author Pavel
 *
 * @param &lt;P&gt;
 * @param &lt;T&gt;
 * @param &lt;R&gt;
 * @param &lt;U&gt;
 * @param &lt;S&gt;
 */
public abstract class ReflectiveProcessorFactory&lt;P, H, E&gt; implements ProcessorFactory&lt;P, H, E&gt; {
	
	private Object[] targets;
	private IntrospectionLevel introspectionLevel;

<span class="nc" id="L52">	public ReflectiveProcessorFactory(IntrospectionLevel introspectionLevel, Object... targets) {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">		this.introspectionLevel = introspectionLevel == null ? IntrospectionLevel.NONE : introspectionLevel;</span>
<span class="nc" id="L54">		this.targets = targets;</span>
<span class="nc" id="L55">	}</span>
	
	public Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; createProcessors(Element element, IntrospectionLevel introspectionLevel, ProgressMonitor progressMonitor, Object... registryTargets) {
<span class="nc" id="L58">		Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; registry = ProcessorFactory.super.createProcessors(progressMonitor, element);</span>
<span class="nc bnc" id="L59" title="All 2 branches missed.">		for (Object registryTarget: registryTargets) {</span>
			// TODO  - progress moinitor			
<span class="nc" id="L61">			wireRegistryEntry(registryTarget, introspectionLevel).accept(registry);</span>
<span class="nc" id="L62">			wireRegistry(registryTarget, introspectionLevel).accept(registry);</span>
		}
<span class="nc" id="L64">		return registry;</span>
	}
	
	@Override
	public ProcessorInfo&lt;P&gt; createProcessor(ProcessorConfig&lt;P&gt; config, ProgressMonitor progressMonitor) {
<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (introspectionLevel != IntrospectionLevel.NONE) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">			for (Object target: targets) {</span>
				// TODO - split
<span class="nc" id="L72">				ProcessorInfo&lt;P&gt; elementProcessorInfo = createProcessor(target, config, introspectionLevel, progressMonitor);</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">				if (elementProcessorInfo != null) {</span>
<span class="nc" id="L74">					return elementProcessorInfo;</span>
				}
			}
		}
<span class="nc" id="L78">		return ProcessorFactory.super.createProcessor(config, progressMonitor); 		</span>
	}		
	
	@SuppressWarnings(&quot;unchecked&quot;)
	protected ProcessorInfo&lt;P&gt; createProcessor(Object target, ProcessorConfig&lt;P&gt; config, IntrospectionLevel introspectionLevel, ProgressMonitor progressMonitor) {	
<span class="nc bnc" id="L83" title="All 6 branches missed.">		if (target != null &amp;&amp; (target.getClass().getAnnotation(Factory.class) == null || matchPredicate(config.getElement(), target.getClass().getAnnotation(Factory.class).value()))) {</span>
			// TODO - progress steps.
<span class="nc" id="L85">			Optional&lt;Method&gt; match = getMethods(target.getClass(), introspectionLevel)</span>
<span class="nc" id="L86">				.filter(m -&gt; matchFactoryMethod(config, m))</span>
<span class="nc" id="L87">				.sorted(this::compareProcessorMethods)</span>
<span class="nc" id="L88">				.findFirst();</span>
			
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (match.isPresent()) {</span>
<span class="nc" id="L91">				Method method = match.get();</span>
				Object processor;
<span class="nc bnc" id="L93" title="All 2 branches missed.">				if (method.getParameterCount() == 0) {</span>
<span class="nc" id="L94">					processor = invokeMethod(target, method);</span>
				} else {
<span class="nc" id="L96">					processor = invokeMethod(target, method, config);</span>
				}
<span class="nc bnc" id="L98" title="All 2 branches missed.">				if (processor != null) {</span>
<span class="nc" id="L99">					Processor elementProcessorAnnotation = method.getAnnotation(Processor.class);</span>
<span class="nc" id="L100">					IntrospectionLevel processorIntrospectionLevel = elementProcessorAnnotation.introspect();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">					if (processorIntrospectionLevel == IntrospectionLevel.NONE) {</span>
<span class="nc" id="L102">						return ProcessorFactory.super.createProcessor(config, progressMonitor);</span>
					}
					
<span class="nc" id="L105">					boolean hideWired = elementProcessorAnnotation.hideWired();</span>
<span class="nc" id="L106">					Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; unwiredChildProcessorsInfo = wireChildProcessor(processor, config.getChildProcessorsInfo(), processorIntrospectionLevel);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">					wireChildProcessors(processor, hideWired ? unwiredChildProcessorsInfo : config.getChildProcessorsInfo(), processorIntrospectionLevel);</span>

<span class="nc" id="L109">					Collection&lt;Throwable&gt; failures = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L110">					BiFunction&lt;Void, Throwable, ProcessorInfo&lt;P&gt;&gt; failureHandler  = (result, failure) -&gt; {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">						if (failure != null) {</span>
<span class="nc" id="L112">							failures.add(failure);</span>
						}
<span class="nc" id="L114">						return null;</span>
					};

<span class="nc" id="L117">					Consumer&lt;ProcessorInfo&lt;P&gt;&gt; pc = wireParentProcessor(processor, processorIntrospectionLevel);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">					if (pc != null) {</span>
<span class="nc" id="L119">						config.getParentProcessorInfo().thenAccept(pc).handle(failureHandler);</span>
					}
<span class="nc" id="L121">					wireProcessorElement(processor, config.getElement(), processorIntrospectionLevel);</span>
					
<span class="nc" id="L123">					config.getRegistry().thenAccept(wireRegistryEntry(processor, processorIntrospectionLevel)).handle(failureHandler);</span>
					
<span class="nc" id="L125">					Consumer&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; rc = wireRegistry(processor, processorIntrospectionLevel);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">					if (rc != null) {</span>
<span class="nc" id="L127">						config.getRegistry().thenAccept(rc).handle(failureHandler);</span>
					}
					
					ProcessorConfig&lt;P&gt; unwiredConfig;
					
<span class="nc bnc" id="L132" title="All 2 branches missed.">					if (config instanceof NodeProcessorConfig) {</span>
<span class="nc" id="L133">						NodeProcessorConfig&lt;P, H, E&gt; nodeProcessorConfig = (NodeProcessorConfig&lt;P, H, E&gt;) config;</span>
<span class="nc" id="L134">						Map&lt;Connection, CompletionStage&lt;E&gt;&gt; unwiredIncomingEndpoints = wireIncomingEndpoint(processor, nodeProcessorConfig.getIncomingEndpoints(), processorIntrospectionLevel, failureHandler);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">						wireIncomingEndpoints(processor, hideWired ? unwiredIncomingEndpoints : nodeProcessorConfig.getIncomingEndpoints(), processorIntrospectionLevel);</span>
						
<span class="nc" id="L137">						Map&lt;Connection, Consumer&lt;H&gt;&gt; unwiredIncomingHandlerConsumers = wireIncomingHandler(processor, nodeProcessorConfig.getIncomingHandlerConsumers(), processorIntrospectionLevel);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">						wireIncomingHandlerConsumers(processor, hideWired ? unwiredIncomingHandlerConsumers : nodeProcessorConfig.getIncomingHandlerConsumers(), processorIntrospectionLevel);</span>
						
<span class="nc" id="L140">						Map&lt;Connection, CompletionStage&lt;E&gt;&gt; unwiredOutgoingEndpoints = wireOutgoingEndpoint(processor, nodeProcessorConfig.getOutgoingEndpoints(), processorIntrospectionLevel, failureHandler);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">						wireOutgoingEndpoints(processor, hideWired ? unwiredOutgoingEndpoints : nodeProcessorConfig.getOutgoingEndpoints(), processorIntrospectionLevel);</span>
						
<span class="nc" id="L143">						Map&lt;Connection, Consumer&lt;H&gt;&gt; unwiredOutgoingHandlerConsumers = wireOutgoingHandler(processor, nodeProcessorConfig.getOutgoingHandlerConsumers(), processorIntrospectionLevel);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">						wireOutgoingHandlerConsumers(processor, hideWired ? unwiredOutgoingHandlerConsumers : nodeProcessorConfig.getOutgoingHandlerConsumers(), processorIntrospectionLevel);</span>
						
<span class="nc" id="L146">						unwiredConfig = new NodeProcessorConfig&lt;P, H, E&gt;() {</span>
	
							@Override
							public Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; getChildProcessorsInfo() {
<span class="nc" id="L150">								return unwiredChildProcessorsInfo;</span>
							}
	
							@Override
							public CompletionStage&lt;ProcessorInfo&lt;P&gt;&gt; getParentProcessorInfo() {
<span class="nc" id="L155">								return config.getParentProcessorInfo();</span>
							}
	
							@Override
							public CompletionStage&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; getRegistry() {
<span class="nc" id="L160">								return config.getRegistry();</span>
							}
	
							@Override
							public Node getElement() {
<span class="nc" id="L165">								return (Node) config.getElement();</span>
							}
	
							@Override
							public Map&lt;Connection, CompletionStage&lt;E&gt;&gt; getIncomingEndpoints() {
<span class="nc" id="L170">								return unwiredIncomingEndpoints;</span>
							}
	
							@Override
							public Map&lt;Connection, Consumer&lt;H&gt;&gt; getIncomingHandlerConsumers() {
<span class="nc" id="L175">								return unwiredIncomingHandlerConsumers;</span>
							}
	
							@Override
							public Map&lt;Connection, CompletionStage&lt;E&gt;&gt; getOutgoingEndpoints() {
<span class="nc" id="L180">								return unwiredOutgoingEndpoints;</span>
							}
	
							@Override
							public Map&lt;Connection, Consumer&lt;H&gt;&gt; getOutgoingHandlerConsumers() {
<span class="nc" id="L185">								return unwiredOutgoingHandlerConsumers;</span>
							}
						};
<span class="nc bnc" id="L188" title="All 2 branches missed.">					} else if (config instanceof ConnectionProcessorConfig) {</span>
<span class="nc" id="L189">						ConnectionProcessorConfig&lt;P, H, E&gt; connectionProcessorConfig = (ConnectionProcessorConfig&lt;P, H, E&gt;) config;</span>
<span class="nc" id="L190">						boolean wiredSourceEndpoint = wireSourceEndpoint(processor, connectionProcessorConfig.getSourceEndpoint(), processorIntrospectionLevel, failureHandler);</span>
<span class="nc" id="L191">						boolean wiredSourceHandler = wireSourceHandler(processor, connectionProcessorConfig, processorIntrospectionLevel);</span>
<span class="nc" id="L192">						boolean wiredTargetEndpoint = wireTargetEndpoint(processor, connectionProcessorConfig.getTargetEndpoint(), processorIntrospectionLevel, failureHandler);</span>
<span class="nc" id="L193">						boolean wiredTargetHandler = wireTargetHandler(processor, connectionProcessorConfig, processorIntrospectionLevel);</span>
						
<span class="nc" id="L195">						unwiredConfig = new ConnectionProcessorConfig&lt;P, H, E&gt;() {</span>
	
							@Override
							public Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; getChildProcessorsInfo() {
<span class="nc" id="L199">								return unwiredChildProcessorsInfo;</span>
							}
							
							@Override
							public CompletionStage&lt;ProcessorInfo&lt;P&gt;&gt; getParentProcessorInfo() {
<span class="nc" id="L204">								return config.getParentProcessorInfo();</span>
							}
	
							@Override
							public CompletionStage&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; getRegistry() {
<span class="nc" id="L209">								return config.getRegistry();</span>
							}
	
							@Override
							public Connection getElement() {
<span class="nc" id="L214">								return (Connection) config.getElement();</span>
							}
	
							@Override
							public CompletionStage&lt;E&gt; getSourceEndpoint() {
<span class="nc bnc" id="L219" title="All 2 branches missed.">								return wiredSourceEndpoint ? null : connectionProcessorConfig.getSourceEndpoint();</span>
							}
	
							@Override
							public void setSourceHandler(H sourceHandler) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">								if (wiredSourceHandler) {</span>
<span class="nc" id="L225">									throw new IllegalStateException(&quot;Source handler is already wired for &quot; + getElement());</span>
								}
<span class="nc" id="L227">								connectionProcessorConfig.setSourceHandler(sourceHandler);</span>
<span class="nc" id="L228">							}</span>
	
							@Override
							public CompletionStage&lt;E&gt; getTargetEndpoint() {
<span class="nc bnc" id="L232" title="All 2 branches missed.">								return wiredTargetEndpoint ? null : connectionProcessorConfig.getTargetEndpoint();</span>
							}
	
							@Override
							public void setTargetHandler(H targetHandler) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">								if (wiredTargetHandler) {</span>
<span class="nc" id="L238">									throw new IllegalStateException(&quot;Target handler is already wired for &quot; + getElement());</span>
								}
<span class="nc" id="L240">								connectionProcessorConfig.setTargetHandler(targetHandler);</span>
<span class="nc" id="L241">							}</span>
						};
<span class="nc" id="L243">					} else {</span>
<span class="nc" id="L244">						unwiredConfig = new ProcessorConfig&lt;P&gt;() {</span>
	
							@Override
							public Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; getChildProcessorsInfo() {
<span class="nc" id="L248">								return unwiredChildProcessorsInfo;</span>
							}
							
							@Override
							public CompletionStage&lt;ProcessorInfo&lt;P&gt;&gt; getParentProcessorInfo() {
<span class="nc" id="L253">								return config.getParentProcessorInfo();</span>
							}
	
							@Override
							public CompletionStage&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; getRegistry() {
<span class="nc" id="L258">								return config.getRegistry();</span>
							}
	
							@Override
							public Element getElement() {
<span class="nc" id="L263">								return config.getElement();</span>
							}
	
						};
					}

<span class="nc bnc" id="L269" title="All 2 branches missed.">					return ProcessorInfo.of(hideWired ? unwiredConfig : config, (P) processor, () -&gt; failures);</span>
				}
			}
			
			// Factories
<span class="nc" id="L274">			List&lt;Entry&lt;Object, IntrospectionLevel&gt;&gt; factories = getFieldsAndMethods(target.getClass(), introspectionLevel)</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">					.filter(ae -&gt; ae.getAnnotation(Factory.class) != null)</span>
<span class="nc" id="L276">					.filter(ae -&gt; matchPredicate(config.getElement(), ae.getAnnotation(Factory.class).value()))</span>
<span class="nc" id="L277">					.filter(ae -&gt; mustGet(ae, null, &quot;Methods annotated with Factory shall have no parameters: &quot; + ae))</span>
<span class="nc" id="L278">					.sorted((a, b) -&gt; b.getAnnotation(Factory.class).priority() - a.getAnnotation(Factory.class).priority())</span>
<span class="nc" id="L279">					.map(ae -&gt; Map.entry(get(target, ae), ae.getAnnotation(Factory.class).introspect()))</span>
<span class="nc" id="L280">					.collect(Collectors.toList());</span>
			
<span class="nc bnc" id="L282" title="All 2 branches missed.">			for (Entry&lt;Object, IntrospectionLevel&gt; factory: factories) {</span>
				// TODO - sub-monitors
<span class="nc" id="L284">				ProcessorInfo&lt;P&gt; elementProcessorInfo = createProcessor(factory.getKey(), config, factory.getValue(), progressMonitor);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">				if (elementProcessorInfo != null) {</span>
<span class="nc" id="L286">					return elementProcessorInfo;</span>
				}
<span class="nc" id="L288">			}</span>
			
<span class="nc" id="L290">			factories = getFieldsAndMethods(target.getClass(), introspectionLevel)</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">					.filter(ae -&gt; ae.getAnnotation(Factories.class) != null)</span>
<span class="nc" id="L292">					.filter(ae -&gt; matchPredicate(config.getElement(), ae.getAnnotation(Factories.class).value()))</span>
<span class="nc" id="L293">					.filter(ae -&gt; mustGet(ae, Collection.class, &quot;Methods and fields annotated with Factories shall be of type/return Collection. Methods shall have no parameters: &quot; + ae))</span>
<span class="nc" id="L294">					.sorted((a, b) -&gt; b.getAnnotation(Factories.class).priority() - a.getAnnotation(Factories.class).priority())</span>
<span class="nc" id="L295">					.flatMap(ae -&gt; ((Collection&lt;Object&gt;) get(target, ae)).stream().map(e -&gt; Map.entry(e, ae.getAnnotation(Factories.class).introspect())))</span>
<span class="nc" id="L296">					.collect(Collectors.toList());</span>
			
<span class="nc bnc" id="L298" title="All 2 branches missed.">			for (Entry&lt;Object, IntrospectionLevel&gt; factory: factories) {</span>
				// TODO - sub-monitors
<span class="nc" id="L300">				ProcessorInfo&lt;P&gt; elementProcessorInfo = createProcessor(factory.getKey(), config, factory.getValue(), progressMonitor);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">				if (elementProcessorInfo != null) {</span>
<span class="nc" id="L302">					return elementProcessorInfo;</span>
				}
<span class="nc" id="L304">			}			</span>
			
		}
<span class="nc" id="L307">		return null;</span>
	}

	protected int compareProcessorMethods(Method a, Method b) {
<span class="nc" id="L311">		int priorityCmp = b.getAnnotation(Processor.class).priority() - a.getAnnotation(Processor.class).priority();</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">		if (priorityCmp != 0) {</span>
<span class="nc" id="L313">			return priorityCmp;</span>
		}
		
<span class="nc" id="L316">		Class&lt;Element&gt; aType = a.getAnnotation(Processor.class).type();</span>
<span class="nc" id="L317">		Class&lt;Element&gt; bType = b.getAnnotation(Processor.class).type();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">		if (!Objects.equals(aType, bType)) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (aType.isAssignableFrom(bType)) {</span>
				// b is more specific
<span class="nc" id="L321">				return 1;</span>
			}
<span class="nc bnc" id="L323" title="All 2 branches missed.">			if (bType.isAssignableFrom(aType)) {</span>
				// a is more specific
<span class="nc" id="L325">				return -1;</span>
			}
		}
		
		// Taking config is more specific 
<span class="nc" id="L330">		int paramCountCmp = b.getParameterCount() - a.getParameterCount();</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">		if (paramCountCmp != 0) {</span>
<span class="nc" id="L332">			return paramCountCmp;</span>
		}
		
<span class="nc" id="L335">		return a.getName().compareTo(b.getName());</span>
	}
		
	protected Consumer&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; wireRegistryEntry(Object processor, IntrospectionLevel processorIntrospectionLevel) {
<span class="nc" id="L339">		List&lt;AccessibleObject&gt; registryEntrySetters = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(RegistryEntry.class) != null)</span>
<span class="nc" id="L341">			.filter(ae -&gt; mustSet(ae, null, &quot;Fields/methods annotated with RegistryEntry must have (parameter) type assignable from the processor type or ProcessorConfig if config is set to true: &quot; + ae))</span>
<span class="nc" id="L342">			.collect(Collectors.toList());</span>
		
<span class="nc" id="L344">		return registry -&gt; {</span>
<span class="nc" id="L345">			registryEntrySetters.forEach(setter -&gt; {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">				for (Entry&lt;Element, ProcessorInfo&lt;P&gt;&gt; re: registry.entrySet()) {</span>
<span class="nc" id="L347">					RegistryEntry registryEntryAnnotation = setter.getAnnotation(RegistryEntry.class);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">					if (matchPredicate(re.getKey(), registryEntryAnnotation.value())) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">						set(processor, setter, registryEntryAnnotation.config() ? re.getValue().getConfig() : re.getValue().getProcessor());</span>
					};						
<span class="nc" id="L351">				}				</span>
<span class="nc" id="L352">			});						</span>
<span class="nc" id="L353">		};</span>
	}

	protected Consumer&lt;Map&lt;Element, ProcessorInfo&lt;P&gt;&gt;&gt; wireRegistry(Object processor, IntrospectionLevel processorIntrospectionLevel) {
<span class="nc" id="L357">		List&lt;AccessibleObject&gt; registrySetters = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(Registry.class) != null)</span>
<span class="nc" id="L359">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with Registry must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L360">				.collect(Collectors.toList());</span>
			
<span class="nc" id="L362">		return registry -&gt; registrySetters.forEach(setter -&gt; set(processor, setter, registry));</span>
	}

	protected void wireProcessorElement(
			Object processor, 
			Element element,
			IntrospectionLevel processorIntrospectionLevel) {
<span class="nc" id="L369">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(ProcessorElement.class) != null)</span>
<span class="nc" id="L371">				.filter(ae -&gt; mustSet(ae, element.getClass(), &quot;Methods annotated with ProcessorElement must have one parameter compatible with the processor element type (&quot; + element.getClass() + &quot;): &quot; + ae))</span>
<span class="nc" id="L372">				.forEach(setter -&gt; {</span>
<span class="nc" id="L373">					set(processor, setter, element);</span>
<span class="nc" id="L374">				});						</span>
<span class="nc" id="L375">	}</span>

	protected Consumer&lt;ProcessorInfo&lt;P&gt;&gt; wireParentProcessor(
			Object processor, 
			IntrospectionLevel processorIntrospectionLevel) {
<span class="nc" id="L380">		List&lt;AccessibleObject&gt; parentProcessorSetters = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(ParentProcessor.class) != null)</span>
<span class="nc" id="L382">				.filter(ae -&gt; mustSet(ae, null, &quot;Fields/methods annotated with ParentProcessor must have (parameter) type assignable from the processor type or ProcessorConfig if value is set to true: &quot; + ae))</span>
<span class="nc" id="L383">				.collect(Collectors.toList());</span>
			
<span class="nc" id="L385">			return parentProcessorInfo -&gt; {</span>
<span class="nc" id="L386">				parentProcessorSetters.forEach(setter -&gt; {</span>
<span class="nc" id="L387">					ParentProcessor parentProcessorAnnotation = setter.getAnnotation(ParentProcessor.class);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">					set(processor, setter, parentProcessorAnnotation.value() ? parentProcessorInfo.getConfig() : parentProcessorInfo.getProcessor());</span>
<span class="nc" id="L389">				});						</span>
<span class="nc" id="L390">			};</span>
	}
	
	private Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; wireChildProcessor(
			Object processor, 
			Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; childProcessorsInfo,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L398">		Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; ret = new LinkedHashMap&lt;&gt;(childProcessorsInfo); </span>
		
<span class="nc" id="L400">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(ChildProcessor.class) != null)</span>
<span class="nc" id="L402">			.filter(ae -&gt; mustSet(ae, null, &quot;Fields/methods annotated with ChildProcessor must have (parameter) type assignable from the processor type or ProcessorConfig if config is set to true: &quot; + ae))</span>
<span class="nc" id="L403">			.forEach(setter -&gt; {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">				for (Entry&lt;Element, ProcessorInfo&lt;P&gt;&gt; ce: childProcessorsInfo.entrySet()) {</span>
<span class="nc" id="L405">					ChildProcessor childProcessorAnnotation = setter.getAnnotation(ChildProcessor.class);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">					if (matchPredicate(ce.getKey(), childProcessorAnnotation.value())) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">						set(processor, setter, childProcessorAnnotation.config() ? ce.getValue().getConfig() : ce.getValue().getProcessor());</span>
					};						
<span class="nc" id="L409">				}				</span>
				
<span class="nc" id="L411">			});</span>
<span class="nc" id="L412">		return ret;</span>
	}	

	protected void wireChildProcessors(
			Object processor, 
			Map&lt;Element, ProcessorInfo&lt;P&gt;&gt; childProcessorsInfo,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L420">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(ChildProcessors.class) != null)</span>
<span class="nc" id="L422">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with ChildProcessors must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L423">				.forEach(setter -&gt; set(processor, setter, childProcessorsInfo));</span>
<span class="nc" id="L424">	}</span>
	
	/**
	 * Matches processor field or method and incoming connection.
	 * @return
	 */
	protected boolean matchIncomingHandler(AnnotatedElement handlerMember, Connection incomingConnection) {
<span class="nc" id="L431">		IncomingHandler incomingHandlerAnnotation = handlerMember.getAnnotation(IncomingHandler.class);</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">		if (incomingHandlerAnnotation == null) {</span>
<span class="nc" id="L433">			return false;</span>
		}
		
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (handlerMember instanceof Method) {</span>
<span class="nc" id="L437">			Method handlerMethod = (Method) handlerMember;</span>
<span class="nc" id="L438">			int pc = handlerMethod.getParameterCount();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">			if (pc &gt; 1) {</span>
<span class="nc" id="L440">				throw new NasdanikaException(&quot;A method annotated with IncomingHandler shall have zero or one parameter: &quot; + handlerMethod);</span>
			}
<span class="nc bnc" id="L442" title="All 4 branches missed.">			if (pc == 1 &amp;&amp; !handlerMethod.getParameterTypes()[0].isInstance(incomingConnection)) {</span>
<span class="nc" id="L443">				throw new NasdanikaException(&quot;A single parameter type of a method annotated with IncomingHandler shall be assignable from Connection: &quot; + handlerMethod);				</span>
			}
		}
				
<span class="nc" id="L447">		return matchPredicate(incomingConnection, incomingHandlerAnnotation.value());</span>
	}
	
	// Node wiring
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Map&lt;Connection, Consumer&lt;H&gt;&gt; wireIncomingHandler(
			Object processor, 
			Map&lt;Connection, Consumer&lt;H&gt;&gt; incomingHandlerConsumers,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L457">		Map&lt;Connection, Consumer&lt;H&gt;&gt; ret = new LinkedHashMap&lt;&gt;(incomingHandlerConsumers);</span>

		// Streaming fields and methods and then flat mapping them to all permutations with incoming handler consumers.
		// then filtering using matchIncomingHandler, sorting by priority, finding first, wiring it and removing from ret.
<span class="nc" id="L461">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">			.filter(m -&gt; !Modifier.isAbstract(((Member) m).getModifiers()))</span>
<span class="nc" id="L463">			.flatMap(ae -&gt; incomingHandlerConsumers.entrySet().stream().map(ihce -&gt; Map.entry(ae, ihce)))</span>
<span class="nc" id="L464">			.filter(e -&gt; matchIncomingHandler(e.getKey(), e.getValue().getKey()))</span>
<span class="nc" id="L465">			.sorted((a, b) -&gt; b.getKey().getAnnotation(IncomingHandler.class).priority() - a.getKey().getAnnotation(IncomingHandler.class).priority())</span>
<span class="nc" id="L466">			.findFirst().ifPresent(e -&gt; {</span>
<span class="nc" id="L467">				AccessibleObject handlerMember = e.getKey();</span>
<span class="nc" id="L468">				Entry&lt;Connection, Consumer&lt;H&gt;&gt; incomingHandlerConsumerEntry = e.getValue();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">				if (handlerMember instanceof Field) {					</span>
<span class="nc" id="L470">					incomingHandlerConsumerEntry.getValue().accept((H) getFieldValue(processor, (Field) handlerMember));</span>
				} else {
<span class="nc" id="L472">					Method handlerSupplierMethod = (Method) handlerMember;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">					Object incomingHandler = handlerSupplierMethod.getParameterCount() == 0 ? invokeMethod(processor, handlerSupplierMethod) : invokeMethod(processor, handlerSupplierMethod, incomingHandlerConsumerEntry.getKey());</span>
<span class="nc" id="L474">					incomingHandlerConsumerEntry.getValue().accept((H) incomingHandler);</span>
				}
<span class="nc" id="L476">				ret.remove(incomingHandlerConsumerEntry.getKey());</span>
<span class="nc" id="L477">			});</span>
				
<span class="nc" id="L479">		return ret;</span>
	}	
	
	protected void wireIncomingHandlerConsumers(
			Object processor, 
			Map&lt;Connection, Consumer&lt;H&gt;&gt; incomingHandlerConsumers,
			IntrospectionLevel processorIntrospectionLevel) {
				
<span class="nc" id="L487">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(IncomingHandlerConsumers.class) != null)</span>
<span class="nc" id="L489">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with IncomingHandlersConsumers must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L490">				.forEach(setter -&gt; set(processor, setter, incomingHandlerConsumers));</span>
<span class="nc" id="L491">	}</span>
	
	/**
	 * Matches processor field or method and incoming connection.
	 * @return
	 */
	protected boolean matchIncomingEndpoint(AnnotatedElement endpointMember, Connection incomingConnection) {
<span class="nc" id="L498">		IncomingEndpoint incomingEndpointAnnotation = endpointMember.getAnnotation(IncomingEndpoint.class);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">		if (incomingEndpointAnnotation == null) {</span>
<span class="nc" id="L500">			return false;</span>
		}
		
<span class="nc bnc" id="L503" title="All 2 branches missed.">		if (endpointMember instanceof Method) {</span>
<span class="nc" id="L504">			Method endpointMethod = (Method) endpointMember;</span>
<span class="nc" id="L505">			int pc = endpointMethod.getParameterCount();</span>
<span class="nc bnc" id="L506" title="All 4 branches missed.">			if (pc == 0 || pc &gt; 2) {</span>
<span class="nc" id="L507">				throw new NasdanikaException(&quot;A method annotated with IncomingEndpoint shall have one or two parameters: &quot; + endpointMethod);</span>
			}
<span class="nc bnc" id="L509" title="All 2 branches missed.">			if (!endpointMethod.getParameterTypes()[0].isInstance(incomingConnection)) {</span>
<span class="nc" id="L510">				throw new NasdanikaException(&quot;The first parameter type of a method annotated with IncomingEndpoint shall be assignable from Connection: &quot; + endpointMethod);				</span>
			}
		}
				
<span class="nc" id="L514">		return matchPredicate(incomingConnection, incomingEndpointAnnotation.value());</span>
	}	

	protected Map&lt;Connection, CompletionStage&lt;E&gt;&gt; wireIncomingEndpoint(
			Object processor, 
			Map&lt;Connection, CompletionStage&lt;E&gt;&gt; incomingEndpoints,
			IntrospectionLevel processorIntrospectionLevel,
			BiFunction&lt;Void, Throwable, ProcessorInfo&lt;P&gt;&gt; failureHandler) {
						
<span class="nc" id="L523">		Map&lt;Connection, CompletionStage&lt;E&gt;&gt; ret = new LinkedHashMap&lt;&gt;(incomingEndpoints);</span>

		// Streaming fields and methods and then flat mapping them to all permutations with incoming endpoints.
		// then filtering using matchIncomingEndpoint, sorting by priority, finding first, wiring it and removing from ret.
<span class="nc" id="L527">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">			.filter(m -&gt; !Modifier.isAbstract(((Member) m).getModifiers()))</span>
<span class="nc" id="L529">			.flatMap(ae -&gt; incomingEndpoints.entrySet().stream().map(iee -&gt; Map.entry(ae, iee)))</span>
<span class="nc" id="L530">			.filter(e -&gt; matchIncomingEndpoint(e.getKey(), e.getValue().getKey()))</span>
<span class="nc" id="L531">			.sorted((a, b) -&gt; b.getKey().getAnnotation(IncomingEndpoint.class).priority() - a.getKey().getAnnotation(IncomingEndpoint.class).priority())</span>
<span class="nc" id="L532">			.findFirst().ifPresent(e -&gt; {</span>
<span class="nc" id="L533">				AccessibleObject endpointMember = e.getKey();</span>
<span class="nc" id="L534">				Entry&lt;Connection, CompletionStage&lt;E&gt;&gt; incomingEndpointEntry = e.getValue();</span>
<span class="nc" id="L535">				incomingEndpointEntry.getValue().thenAccept(incomingEndpoint -&gt; {</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">					if (endpointMember instanceof Field) {</span>
<span class="nc" id="L537">						setFieldValue(processor, (Field) endpointMember, incomingEndpoint);</span>
					} else {
<span class="nc" id="L539">						Method endpointMethod = (Method) endpointMember;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">						if (endpointMethod.getParameterCount() == 1) {</span>
<span class="nc" id="L541">							invokeMethod(processor, endpointMethod, incomingEndpoint);</span>
						} else {
<span class="nc" id="L543">							invokeMethod(processor, endpointMethod, incomingEndpointEntry.getKey(), incomingEndpoint);						</span>
						}
					}					
<span class="nc" id="L546">				}).handle(failureHandler);</span>
<span class="nc" id="L547">				ret.remove(incomingEndpointEntry.getKey());</span>
<span class="nc" id="L548">			});</span>
				
<span class="nc" id="L550">		return ret;</span>
	}

	protected void wireIncomingEndpoints(
			Object processor, 
			Map&lt;Connection, CompletionStage&lt;E&gt;&gt; incomingEndpoints,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L558">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(IncomingEndpoints.class) != null)</span>
<span class="nc" id="L560">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with IncomingEndpoints must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L561">				.forEach(setter -&gt; set(processor, setter, incomingEndpoints));</span>
<span class="nc" id="L562">	}</span>
	
	/**
	 * Matches processor field or method and outgoing connection.
	 * @return
	 */
	protected boolean matchOutgoingHandler(AnnotatedElement handlerMember, Connection outgoingConnection) {
<span class="nc" id="L569">		OutgoingHandler outgoingHandlerAnnotation = handlerMember.getAnnotation(OutgoingHandler.class);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (outgoingHandlerAnnotation == null) {</span>
<span class="nc" id="L571">			return false;</span>
		}
		
<span class="nc bnc" id="L574" title="All 2 branches missed.">		if (handlerMember instanceof Method) {</span>
<span class="nc" id="L575">			Method handlerMethod = (Method) handlerMember;</span>
<span class="nc" id="L576">			int pc = handlerMethod.getParameterCount();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">			if (pc &gt; 1) {</span>
<span class="nc" id="L578">				throw new NasdanikaException(&quot;A method annotated with OutgoingHandler shall have zero or one parameter: &quot; + handlerMethod);</span>
			}
<span class="nc bnc" id="L580" title="All 4 branches missed.">			if (pc == 1 &amp;&amp; !handlerMethod.getParameterTypes()[0].isInstance(outgoingConnection)) {</span>
<span class="nc" id="L581">				throw new NasdanikaException(&quot;A single parameter type of a method annotated with OutgoingHandler shall be assignable from Connection: &quot; + handlerMethod);				</span>
			}
		}
				
<span class="nc" id="L585">		return matchPredicate(outgoingConnection, outgoingHandlerAnnotation.value());</span>
	}
	
	@SuppressWarnings(&quot;unchecked&quot;)
	protected Map&lt;Connection, Consumer&lt;H&gt;&gt; wireOutgoingHandler(
			Object processor, 
			Map&lt;Connection, Consumer&lt;H&gt;&gt; outgoingHandlerConsumers,
			IntrospectionLevel processorIntrospectionLevel) {

<span class="nc" id="L594">		Map&lt;Connection, Consumer&lt;H&gt;&gt; ret = new LinkedHashMap&lt;&gt;(outgoingHandlerConsumers);</span>

		// Streaming fields and methods and then flat mapping them to all permutations with outgoing handler consumers.
		// then filtering using matchOutgoingHandler, sorting by priority, finding first, wiring it and removing from ret.
<span class="nc" id="L598">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			.filter(m -&gt; !Modifier.isAbstract(((Member) m).getModifiers()))</span>
<span class="nc" id="L600">			.flatMap(ae -&gt; outgoingHandlerConsumers.entrySet().stream().map(ihce -&gt; Map.entry(ae, ihce)))</span>
<span class="nc" id="L601">			.filter(e -&gt; matchOutgoingHandler(e.getKey(), e.getValue().getKey()))</span>
<span class="nc" id="L602">			.sorted((a, b) -&gt; b.getKey().getAnnotation(OutgoingHandler.class).priority() - a.getKey().getAnnotation(OutgoingHandler.class).priority())</span>
<span class="nc" id="L603">			.findFirst().ifPresent(e -&gt; {</span>
<span class="nc" id="L604">				AccessibleObject handlerMember = e.getKey();</span>
<span class="nc" id="L605">				Entry&lt;Connection, Consumer&lt;H&gt;&gt; outgoingHandlerConsumerEntry = e.getValue();</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">				if (handlerMember instanceof Field) {					</span>
<span class="nc" id="L607">					outgoingHandlerConsumerEntry.getValue().accept((H) getFieldValue(processor, (Field) handlerMember));</span>
				} else {
<span class="nc" id="L609">					Method handlerSupplierMethod = (Method) handlerMember;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">					Object incomingHandler = handlerSupplierMethod.getParameterCount() == 0 ? invokeMethod(processor, handlerSupplierMethod) : invokeMethod(processor, handlerSupplierMethod, outgoingHandlerConsumerEntry.getKey());</span>
<span class="nc" id="L611">					outgoingHandlerConsumerEntry.getValue().accept((H) incomingHandler);</span>
				}
<span class="nc" id="L613">				ret.remove(outgoingHandlerConsumerEntry.getKey());</span>
<span class="nc" id="L614">			});</span>
				
<span class="nc" id="L616">		return ret;</span>
	}
	
	protected void wireOutgoingHandlerConsumers(
			Object processor,
			Map&lt;Connection, Consumer&lt;H&gt;&gt; outgoingHandlerConsumers,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L624">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(OutgoingHandlerConsumers.class) != null)</span>
<span class="nc" id="L626">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with OutgoingHandlersConsumers must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L627">				.forEach(setter -&gt; set(processor, setter, outgoingHandlerConsumers));</span>
<span class="nc" id="L628">	}</span>
	
	/**
	 * Matches processor field or method and outgoing connection.
	 * @return
	 */
	protected boolean matchOutgoingEndpoint(AnnotatedElement endpointMember, Connection outgoingConnection) {
<span class="nc" id="L635">		OutgoingEndpoint outgoingEndpointAnnotation = endpointMember.getAnnotation(OutgoingEndpoint.class);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">		if (outgoingEndpointAnnotation == null) {</span>
<span class="nc" id="L637">			return false;</span>
		}
		
<span class="nc bnc" id="L640" title="All 2 branches missed.">		if (endpointMember instanceof Method) {</span>
<span class="nc" id="L641">			Method endpointMethod = (Method) endpointMember;</span>
<span class="nc" id="L642">			int pc = endpointMethod.getParameterCount();</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">			if (pc == 0 || pc &gt; 2) {</span>
<span class="nc" id="L644">				throw new NasdanikaException(&quot;A method annotated with OutgoingEndpoint shall have one or two parameters: &quot; + endpointMethod);</span>
			}
<span class="nc bnc" id="L646" title="All 2 branches missed.">			if (!endpointMethod.getParameterTypes()[0].isInstance(outgoingConnection)) {</span>
<span class="nc" id="L647">				throw new NasdanikaException(&quot;The first parameter type of a method annotated with OutgoingEndpoint shall be assignable from Connection: &quot; + endpointMethod);				</span>
			}
		}
				
<span class="nc" id="L651">		return matchPredicate(outgoingConnection, outgoingEndpointAnnotation.value());</span>
	}	

	protected Map&lt;Connection, CompletionStage&lt;E&gt;&gt; wireOutgoingEndpoint(
			Object processor, 
			Map&lt;Connection, CompletionStage&lt;E&gt;&gt; outgoingEndpoints,
			IntrospectionLevel processorIntrospectionLevel,
			BiFunction&lt;Void, Throwable, ProcessorInfo&lt;P&gt;&gt; failureHandler) {
						
<span class="nc" id="L660">		Map&lt;Connection, CompletionStage&lt;E&gt;&gt; ret = new LinkedHashMap&lt;&gt;(outgoingEndpoints);</span>

		// Streaming fields and methods and then flat mapping them to all permutations with outgoing endpoints.
		// then filtering using matchOutgoingEndpoint, sorting by priority, finding first, wiring it and removing from ret.
<span class="nc" id="L664">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">			.filter(m -&gt; !Modifier.isAbstract(((Member) m).getModifiers()))</span>
<span class="nc" id="L666">			.flatMap(ae -&gt; outgoingEndpoints.entrySet().stream().map(iee -&gt; Map.entry(ae, iee)))</span>
<span class="nc" id="L667">			.filter(e -&gt; matchOutgoingEndpoint(e.getKey(), e.getValue().getKey()))</span>
<span class="nc" id="L668">			.sorted((a, b) -&gt; b.getKey().getAnnotation(OutgoingEndpoint.class).priority() - a.getKey().getAnnotation(OutgoingEndpoint.class).priority())</span>
<span class="nc" id="L669">			.findFirst().ifPresent(e -&gt; {</span>
<span class="nc" id="L670">				AccessibleObject endpointMember = e.getKey();</span>
<span class="nc" id="L671">				Entry&lt;Connection, CompletionStage&lt;E&gt;&gt; outgoingEndpointEntry = e.getValue();</span>
<span class="nc" id="L672">				outgoingEndpointEntry.getValue().thenAccept(outgoingEndpoint -&gt; {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">					if (endpointMember instanceof Field) {</span>
<span class="nc" id="L674">						setFieldValue(processor, (Field) endpointMember, outgoingEndpoint);</span>
					} else {
<span class="nc" id="L676">						Method endpointMethod = (Method) endpointMember;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">						if (endpointMethod.getParameterCount() == 1) {</span>
<span class="nc" id="L678">							invokeMethod(processor, endpointMethod, outgoingEndpoint);</span>
						} else {
<span class="nc" id="L680">							invokeMethod(processor, endpointMethod, outgoingEndpointEntry.getKey(), outgoingEndpoint);						</span>
						}
					}					
<span class="nc" id="L683">				}).handle(failureHandler);</span>
<span class="nc" id="L684">				ret.remove(outgoingEndpointEntry.getKey());</span>
<span class="nc" id="L685">			});</span>
				
<span class="nc" id="L687">		return ret;</span>
	}

	protected void wireOutgoingEndpoints(
			Object processor, 
			Map&lt;Connection, CompletionStage&lt;E&gt;&gt; outgoingEndpoints,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L695">		getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">				.filter(ae -&gt; ae.getAnnotation(OutgoingEndpoints.class) != null)</span>
<span class="nc" id="L697">				.filter(ae -&gt; mustSet(ae, Map.class, &quot;Fields/methods annotated with OutgoingEndpoints must have (parameter) type assignable from Map: &quot; + ae))</span>
<span class="nc" id="L698">				.forEach(setter -&gt; set(processor, setter, outgoingEndpoints));</span>
<span class="nc" id="L699">	}</span>

	// Connection wiring
	@SuppressWarnings(&quot;unchecked&quot;)
	protected boolean wireTargetHandler(
			Object processor, 
			ConnectionProcessorConfig&lt;P, H, E&gt; connectionProcessorConfig, 
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L708">		Optional&lt;AccessibleObject&gt; getter = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(TargetHandler.class) != null)</span>
<span class="nc" id="L710">			.filter(ae -&gt; mustGet(ae, null, &quot;Cannot use &quot; + ae + &quot; to get target connection handler&quot;))</span>
<span class="nc" id="L711">			.findFirst();</span>
		
		
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (getter.isPresent()) {</span>
<span class="nc" id="L715">			 connectionProcessorConfig.setTargetHandler((H) get(processor, getter.get()));</span>
<span class="nc" id="L716">			 return true;</span>
		}
<span class="nc" id="L718">		return false;</span>
	}

	protected boolean wireTargetEndpoint(
			Object processor, 
			CompletionStage&lt;E&gt; targetEndpointCompletionStage, 
			IntrospectionLevel processorIntrospectionLevel,
			BiFunction&lt;Void, Throwable, ProcessorInfo&lt;P&gt;&gt; failureHandler) {
		
<span class="nc" id="L727">		Optional&lt;AccessibleObject&gt; setter = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(TargetEndpoint.class) != null)</span>
<span class="nc" id="L729">			.filter(ae -&gt; mustSet(ae, null, &quot;Cannot use &quot; + ae + &quot; to set target connection endpoint&quot;))</span>
<span class="nc" id="L730">			.findFirst();</span>
		
		
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (setter.isPresent()) {</span>
<span class="nc" id="L734">			targetEndpointCompletionStage.thenAccept(targetEndpoint -&gt; {</span>
<span class="nc" id="L735">				set(processor, setter.get(), targetEndpoint);	</span>
<span class="nc" id="L736">			}).handle(failureHandler);</span>
<span class="nc" id="L737">			return true;</span>
		}
<span class="nc" id="L739">		return false;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	protected boolean wireSourceHandler(
			Object processor, 
			ConnectionProcessorConfig&lt;P, H, E&gt; connectionProcessorConfig,
			IntrospectionLevel processorIntrospectionLevel) {
		
<span class="nc" id="L748">		Optional&lt;AccessibleObject&gt; getter = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(SourceHandler.class) != null)</span>
<span class="nc" id="L750">			.filter(ae -&gt; mustGet(ae, null, &quot;Cannot use &quot; + ae + &quot; to get source connection handler&quot;))</span>
<span class="nc" id="L751">			.findFirst();</span>
		
		
<span class="nc bnc" id="L754" title="All 2 branches missed.">		if (getter.isPresent()) {</span>
<span class="nc" id="L755">			 connectionProcessorConfig.setSourceHandler((H) get(processor, getter.get()));</span>
<span class="nc" id="L756">			 return true;</span>
		}
<span class="nc" id="L758">		return false;</span>
	}

	protected boolean wireSourceEndpoint(
			Object processor, 
			CompletionStage&lt;E&gt; sourceEndpointCompletionStage,
			IntrospectionLevel processorIntrospectionLevel,
			BiFunction&lt;Void, Throwable, ProcessorInfo&lt;P&gt;&gt; failureHandler) {
		
<span class="nc" id="L767">		Optional&lt;AccessibleObject&gt; setter = getFieldsAndMethods(processor.getClass(), processorIntrospectionLevel)</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">			.filter(ae -&gt; ae.getAnnotation(SourceEndpoint.class) != null)</span>
<span class="nc" id="L769">			.filter(ae -&gt; mustSet(ae, null, &quot;Cannot use &quot; + ae + &quot; to set source connection endpoint&quot;))</span>
<span class="nc" id="L770">			.findFirst();</span>
		
		
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if (setter.isPresent()) {</span>
<span class="nc" id="L774">			sourceEndpointCompletionStage.thenAccept(sourceEndpoint -&gt; {</span>
<span class="nc" id="L775">				set(processor, setter.get(), sourceEndpoint);	</span>
<span class="nc" id="L776">			}).handle(failureHandler);				</span>
<span class="nc" id="L777">			return true;</span>
		}
<span class="nc" id="L779">		return false;</span>
	}
	
	protected boolean matchFactoryMethod(ProcessorConfig&lt;P&gt; elementProcessorConfig, Method method) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">		if (Modifier.isAbstract(method.getModifiers())) {</span>
<span class="nc" id="L784">			return false;</span>
		}
		
<span class="nc" id="L787">		Processor elementProcessorAnnotation = method.getAnnotation(Processor.class);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">		if (elementProcessorAnnotation == null) {</span>
<span class="nc" id="L789">			return false;</span>
		}
		
<span class="nc" id="L792">		Element element = elementProcessorConfig.getElement();</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">		if (!elementProcessorAnnotation.type().isInstance(element)) {</span>
<span class="nc" id="L794">			return false;</span>
		}
		
<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (method.getParameterCount() &gt; 1) {</span>
<span class="nc" id="L798">			return false;</span>
		}
		
<span class="nc bnc" id="L801" title="All 4 branches missed.">		if (method.getParameterCount() == 1 &amp;&amp; !method.getParameterTypes()[0].isInstance(elementProcessorConfig)) {</span>
<span class="nc" id="L802">			return false;</span>
		}
		
<span class="nc" id="L805">		return matchPredicate(elementProcessorConfig.getElement(), elementProcessorAnnotation.value());</span>
	}

	/**
	 * Parses and evaluates expression using &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions&quot;&gt;Spring Expression Language&lt;/a&gt; 
	 * @param obj
	 * @param expr 
	 * @return true if expression is blank or evaluates to true, false if the expression evaluates to false or throws EvaluationException.
	 */
	protected boolean matchPredicate(Object obj, String expr) {
<span class="nc bnc" id="L815" title="All 2 branches missed.">		if (Util.isBlank(expr)) {</span>
<span class="nc" id="L816">			return true;</span>
		}
		
<span class="nc" id="L819">		ExpressionParser parser = new SpelExpressionParser();</span>
<span class="nc" id="L820">		Expression exp = parser.parseExpression(expr);</span>
<span class="nc" id="L821">		EvaluationContext evaluationContext = getEvaluationContext();</span>
		try {			
<span class="nc bnc" id="L823" title="All 2 branches missed.">			return evaluationContext == null ? exp.getValue(obj, Boolean.class) : exp.getValue(evaluationContext, obj, Boolean.class);</span>
<span class="nc" id="L824">		} catch (EvaluationException e) {</span>
<span class="nc" id="L825">			return false;</span>
		}
	}
	
	/**
	 * @return A stream of methods. Accessible methods for the introspection level ACCESSIBLE and declared methods from the class and all super classes and implemented interfaces for the introspection level DECLARED.
	 */
	protected static Stream&lt;Method&gt; getMethods(Class&lt;?&gt; clazz, IntrospectionLevel introspectionLevel) {
<span class="nc bnc" id="L833" title="All 8 branches missed.">		if (clazz == null || introspectionLevel == null || introspectionLevel == IntrospectionLevel.NONE || Object.class.equals(clazz)) {</span>
<span class="nc" id="L834">			return Stream.empty();</span>
		}
		
<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (introspectionLevel == IntrospectionLevel.ACCESSIBLE) {</span>
<span class="nc" id="L838">			return Arrays.stream(clazz.getMethods());</span>
		}
		
<span class="nc" id="L841">		Stream&lt;Method&gt; declared = Arrays.stream(clazz.getDeclaredMethods());</span>
		
<span class="nc" id="L843">		Class&lt;?&gt; superClass = clazz.getSuperclass();</span>
<span class="nc" id="L844">		declared = Stream.concat(declared, getMethods(superClass, introspectionLevel));</span>
		
<span class="nc bnc" id="L846" title="All 2 branches missed.">		for (Class&lt;?&gt; implementedInterface: clazz.getInterfaces()) {</span>
<span class="nc" id="L847">			declared = Stream.concat(declared, getMethods(implementedInterface, introspectionLevel));</span>
			
		}
<span class="nc" id="L850">		return declared;</span>
	}
	
	/**
	 * @return A stream of fields. Accessible fields for the introspection level ACCESSIBLE and declared fields from the class and all super classes and implemented interfaces for the introspection level DECLARED.
	 */
	protected static Stream&lt;Field&gt; getFields(Class&lt;?&gt; clazz, IntrospectionLevel introspectionLevel) {
<span class="nc bnc" id="L857" title="All 8 branches missed.">		if (clazz == null || introspectionLevel == null || introspectionLevel == IntrospectionLevel.NONE || Object.class.equals(clazz)) {</span>
<span class="nc" id="L858">			return Stream.empty();</span>
		}
		
<span class="nc bnc" id="L861" title="All 2 branches missed.">		if (introspectionLevel == IntrospectionLevel.ACCESSIBLE) {</span>
<span class="nc" id="L862">			return Arrays.stream(clazz.getFields());</span>
		}
		
<span class="nc" id="L865">		Stream&lt;Field&gt; declared = Arrays.stream(clazz.getDeclaredFields());</span>
		
<span class="nc" id="L867">		Class&lt;?&gt; superClass = clazz.getSuperclass();</span>
<span class="nc" id="L868">		declared = Stream.concat(declared, getFields(superClass, introspectionLevel));</span>
		
<span class="nc bnc" id="L870" title="All 2 branches missed.">		for (Class&lt;?&gt; implementedInterface: clazz.getInterfaces()) {</span>
<span class="nc" id="L871">			declared = Stream.concat(declared, getFields(implementedInterface, introspectionLevel));</span>
			
		}
<span class="nc" id="L874">		return declared;</span>
	}
	
	protected static Stream&lt;AccessibleObject&gt; getFieldsAndMethods(Class&lt;?&gt; clazz, IntrospectionLevel introspectionLevel) {
<span class="nc" id="L878">		return Stream.concat(getMethods(clazz, introspectionLevel), getFields(clazz, introspectionLevel));</span>
	}
	
	/**
	 * Retrieves field value. May need to be overridden if the target class is not exported by its module.
	 * @param target
	 * @param field
	 * @return
	 */
	protected Object getFieldValue(Object target, Field field) {
<span class="nc" id="L888">		boolean canAccess = field.canAccess(target);</span>
		try {
<span class="nc bnc" id="L890" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L891">				field.setAccessible(true);</span>
			}
<span class="nc" id="L893">			return  field.get(target);</span>
<span class="nc" id="L894">		} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L895">			throw new NasdanikaException(&quot;Cannot access field &quot; + field + &quot; of &quot; + target + &quot;: &quot; + e, e);</span>
		} finally {
<span class="nc bnc" id="L897" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L898">				field.setAccessible(false);</span>
			}
		}	
	}

	/**
	 * Sets field value. May need to be overridden if the target class is not exported by its module.
	 * @param target
	 * @param field
	 * @param value
	 * @return
	 */
	protected void setFieldValue(Object target, Field field, Object value) {
<span class="nc" id="L911">		boolean canAccess = field.canAccess(target);</span>
		try {
<span class="nc bnc" id="L913" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L914">				field.setAccessible(true);</span>
			}
<span class="nc" id="L916">			field.set(target, value);</span>
<span class="nc" id="L917">		} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L918">			throw new NasdanikaException(&quot;Cannot access field &quot; + field + &quot; of &quot; + target + &quot;: &quot; + e, e);</span>
		} finally {
<span class="nc bnc" id="L920" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L921">				field.setAccessible(false);</span>
			}
		}	
<span class="nc" id="L924">	}</span>
	
	/**
	 * Invokes method. May need to be overridden if the target class is not exported by its module.
	 * @param target
	 * @param method
	 * @param args
	 * @return
	 */
	protected Object invokeMethod(Object target, Method method, Object... args) {
<span class="nc" id="L934">		boolean canAccess = method.canAccess(target);</span>
		try {
<span class="nc bnc" id="L936" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L937">				method.setAccessible(true);</span>
			}
<span class="nc" id="L939">			return method.invoke(target, args);</span>
<span class="nc" id="L940">		} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {</span>
<span class="nc" id="L941">			throw new NasdanikaException(&quot;Error invoking &quot; + method + &quot; of &quot; + target + &quot;: &quot; + e, e);</span>
		} finally {
<span class="nc bnc" id="L943" title="All 2 branches missed.">			if (!canAccess) {</span>
<span class="nc" id="L944">				method.setAccessible(false);</span>
			}
		}		
	}
	
	protected boolean canSet(AnnotatedElement element, Class&lt;?&gt; type) {
<span class="nc bnc" id="L950" title="All 2 branches missed.">		if (element instanceof Field) {</span>
<span class="nc bnc" id="L951" title="All 4 branches missed.">			return type == null || ((Field) element).getType().isAssignableFrom(type);</span>
		}
<span class="nc bnc" id="L953" title="All 2 branches missed.">		if (element instanceof Method) {</span>
<span class="nc" id="L954">			Method method = (Method) element;</span>
<span class="nc bnc" id="L955" title="All 8 branches missed.">			return !Modifier.isAbstract(((Member) method).getModifiers()) &amp;&amp; method.getParameterCount() == 1 &amp;&amp; (type == null || method.getParameterTypes()[0].isAssignableFrom(type));</span>
		}
<span class="nc" id="L957">		return false;</span>
	}
	
	protected boolean mustSet(AnnotatedElement element, Class&lt;?&gt; type, String message) {
<span class="nc bnc" id="L961" title="All 2 branches missed.">		if (canSet(element, type)) {</span>
<span class="nc" id="L962">			return true;</span>
		}
<span class="nc" id="L964">		throw new NasdanikaException(message);</span>
	}
	
	protected void set(Object target, AnnotatedElement element, Object value) {
<span class="nc bnc" id="L968" title="All 2 branches missed.">		if (element instanceof Field) {</span>
<span class="nc" id="L969">			setFieldValue(target, (Field) element, value);</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">		} else if (element instanceof Method) {</span>
<span class="nc" id="L971">			invokeMethod(target, (Method) element, value);</span>
		} else {
<span class="nc" id="L973">			throw new IllegalArgumentException(&quot;Cannot set value into &quot; + element);</span>
		}
<span class="nc" id="L975">	}</span>
	
	protected Object get(Object target, AnnotatedElement element) {
<span class="nc bnc" id="L978" title="All 2 branches missed.">		if (element instanceof Field) {</span>
<span class="nc" id="L979">			return getFieldValue(target, (Field) element);</span>
		} 
<span class="nc bnc" id="L981" title="All 2 branches missed.">		if (element instanceof Method) {</span>
<span class="nc" id="L982">			return invokeMethod(target, (Method) element);</span>
		}
		
<span class="nc" id="L985">		throw new IllegalArgumentException(&quot;Cannot get value from &quot; + element);</span>
	}
	
	protected boolean canGet(AnnotatedElement element, Class&lt;?&gt; type) {
<span class="nc bnc" id="L989" title="All 2 branches missed.">		if (element instanceof Field) {</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">			return type == null || type.isAssignableFrom(((Field) element).getType());</span>
		}
<span class="nc bnc" id="L992" title="All 2 branches missed.">		if (element instanceof Method) {</span>
<span class="nc" id="L993">			Method method = (Method) element;					</span>
<span class="nc bnc" id="L994" title="All 8 branches missed.">			return !Modifier.isAbstract(((Member) method).getModifiers()) &amp;&amp; method.getParameterCount() == 0 &amp;&amp; (type == null || type.isAssignableFrom(method.getReturnType()));</span>
		}
<span class="nc" id="L996">		return false;</span>
	}
	
	protected boolean mustGet(AnnotatedElement element, Class&lt;?&gt; type, String message) {
<span class="nc bnc" id="L1000" title="All 2 branches missed.">		if (canGet(element, type)) {</span>
<span class="nc" id="L1001">			return true;</span>
		}
<span class="nc" id="L1003">		throw new NasdanikaException(message);</span>
	}

	protected boolean isValueSupplier(AnnotatedElement element) {
<span class="nc bnc" id="L1007" title="All 6 branches missed.">		return element instanceof Field || (element instanceof Method &amp;&amp; ((Method) element).getParameterCount() == 0);</span>
	}
	
	protected EvaluationContext getEvaluationContext() {
<span class="nc" id="L1011">		return null;</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>