<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DelegatingAdapterFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika EMF</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.emf</a> &gt; <span class="el_source">DelegatingAdapterFactory.java</span></div><h1>DelegatingAdapterFactory.java</h1><pre class="source lang-java linenums">package org.nasdanika.emf;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.notify.impl.AdapterImpl;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EcorePackage;
import org.nasdanika.common.FunctionFactory;

/**
 * Base class for adapter factories delegating to {@link Supplier} or {@link FunctionFactory} to create an adapter and 
 * wrapping adapter into a dynamic proxy if the adapter does not implement {@link Adapter}.
 * @author Pavel Vlasov
 *
 */
public abstract class DelegatingAdapterFactory&lt;T&gt; extends ComposeableAdapterFactoryImpl {
	
	private Class&lt;T&gt; type;
	private ClassLoader proxyClassLoader;
	
	/**
	 * Uses {@link EObject}'s {@link EClass} as eClass argument
	 * @param type
	 * @param proxyClassLoader
	 */
	protected DelegatingAdapterFactory(Class&lt;T&gt; type, ClassLoader proxyClassLoader) {
<span class="nc" id="L37">		this(EcorePackage.Literals.EOBJECT, type, proxyClassLoader);</span>
<span class="nc" id="L38">	}	</span>

	/**
	 * 
	 * @param type
	 * @param proxyClassLoader Proxy class loader, can be null if created adapter implements {@link Adapter} and no proxy is required.
	 */
	protected DelegatingAdapterFactory(EClass eClass, Class&lt;T&gt; type, ClassLoader proxyClassLoader) {
<span class="nc" id="L46">		super(eClass);</span>
<span class="nc" id="L47">		this.type = type;</span>
<span class="nc" id="L48">		this.proxyClassLoader = proxyClassLoader;</span>
<span class="nc" id="L49">	}</span>
	
	@Override
	public boolean isFactoryForType(Object type) {
<span class="nc bnc" id="L53" title="All 2 branches missed.">		return this.type == type;</span>
	}
		
	private class DelegatingAdapter extends AdapterImpl {
		
		private T delegate;

<span class="nc" id="L60">		public DelegatingAdapter(T adapter, Notifier target) {			</span>
<span class="nc" id="L61">			this.delegate = adapter;</span>
<span class="nc" id="L62">			this.target = target;</span>
<span class="nc" id="L63">		}</span>
		
		@Override
		public void setTarget(Notifier newTarget) {			
<span class="nc bnc" id="L67" title="All 2 branches missed.">			if (target != newTarget) {</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">				if (newTarget == null) {</span>
<span class="nc" id="L69">					delegate = null;</span>
				} else {
<span class="nc" id="L71">					delegate = doCreateAdapter(newTarget);</span>
				}
			}
<span class="nc" id="L74">			super.setTarget(newTarget);</span>
<span class="nc" id="L75">		}</span>
		
		@Override
		public boolean isAdapterForType(Object type) {
<span class="nc" id="L79">			return DelegatingAdapterFactory.this.isFactoryForType(type);</span>
		}		
				
	}
	
	/**
	 * Creates adapter. This adapter does not have to implement {@link Adapter}. 
	 * If it does not then a proxy will be created implementing both T and adapter.
	 * @param target
	 * @return
	 */
	protected abstract T doCreateAdapter(Notifier target);
	
	public static List&lt;Class&lt;?&gt;&gt; allInterfaces(Class&lt;?&gt; klass) {
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (klass==null) {</span>
<span class="nc" id="L94">			return Collections.emptyList();</span>
		}
<span class="nc" id="L96">		List&lt;Class&lt;?&gt;&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (klass.isInterface()) {</span>
<span class="nc" id="L98">			ret.add(klass);</span>
		} else {
<span class="nc" id="L100">			ret.addAll(Arrays.asList(klass.getInterfaces()));</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">			Z: for (Class&lt;?&gt; i: allInterfaces(klass.getSuperclass())) {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">				for (Class&lt;?&gt; ei: ret) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">					if (i.isAssignableFrom(ei)) {</span>
<span class="nc" id="L104">						continue Z;</span>
					}
<span class="nc" id="L106">				}</span>
<span class="nc" id="L107">				ret.add(i);</span>
<span class="nc" id="L108">			}</span>
		}
<span class="nc" id="L110">		return ret;</span>
	}	
		
	@Override
	protected Adapter createAdapter(Notifier target) {
<span class="nc" id="L115">		T adapter = doCreateAdapter(target);</span>
		
<span class="nc bnc" id="L117" title="All 2 branches missed.">		if (adapter == null) {</span>
<span class="nc" id="L118">			return null;</span>
		}
		
<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (adapter instanceof Adapter) {</span>
<span class="nc" id="L122">			return (Adapter) adapter;</span>
		}		
		
<span class="nc" id="L125">		DelegatingAdapter da = new DelegatingAdapter(adapter, target);</span>
		
<span class="nc" id="L127">		List&lt;Class&lt;?&gt;&gt; adapterInterfaces = allInterfaces(adapter.getClass());</span>
<span class="nc" id="L128">		Class&lt;?&gt;[] proxyInterfaces = new Class&lt;?&gt;[adapterInterfaces.size() + 1];</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">		for (int i = 0; i &lt; adapterInterfaces.size(); ++i) {</span>
<span class="nc" id="L130">			proxyInterfaces[i] = adapterInterfaces.get(i);</span>
		}
<span class="nc" id="L132">		proxyInterfaces[proxyInterfaces.length -1] = Adapter.class;</span>
		
<span class="nc" id="L134">		return (Adapter) Proxy.newProxyInstance(proxyClassLoader, proxyInterfaces, new InvocationHandler() {</span>
			
			@Override
			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
<span class="nc" id="L138">				Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">				if (declaringClass == Object.class) {</span>
					// Handling equals
<span class="nc bnc" id="L141" title="All 6 branches missed.">					if (method.getName().equals(&quot;equals&quot;) &amp;&amp; method.getParameterCount() == 1 &amp;&amp; method.getParameterTypes()[0] == Object.class) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">						return args[0] == proxy;</span>
					}
				}
<span class="nc bnc" id="L145" title="All 2 branches missed.">				Object target = declaringClass == Adapter.class ? da : da.delegate;</span>
<span class="nc" id="L146">				return  method.invoke(target, args);</span>
			}
			
		});
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>