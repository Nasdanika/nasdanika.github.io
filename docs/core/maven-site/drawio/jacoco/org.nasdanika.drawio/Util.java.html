<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java API for working with Drawio diagrams</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.drawio</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">package org.nasdanika.drawio;

import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class Util {
	
	private Util() {}
			
	/**
	 * Lays out the diagram so nodes do not overlap.
	 * @param root
	 * @param gridSize
	 */
	public static void layout(Root root, int gridSize) {
<span class="fc" id="L34">		List&lt;Node&gt; topLevelNodes = root.getLayers().stream().flatMap(layer -&gt; layer.getElements().stream()).filter(Node.class::isInstance).map(Node.class::cast).collect(Collectors.toList());</span>
<span class="fc" id="L35">		layout(topLevelNodes, new Point(gridSize, gridSize), down -&gt; createOffsetGenerator(gridSize, down));</span>
<span class="fc" id="L36">	}		</span>
	
	/**
	 * Computes sizes and positions of a collection of elements so they don't overlap
	 * @param elements
	 * @return
	 */
	public static Map&lt;Node, Rectangle&gt; layout(
			Collection&lt;Node&gt; nodes, 
			Point offset,
			Function&lt;Boolean, Supplier&lt;Point&gt;&gt; offsetGeneratorProvider /*,			
			BiConsumer&lt;Node, Rectangle&gt; geometryConsumer */) {
		
<span class="fc" id="L49">		Map&lt;Node, Rectangle&gt; ret = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">		for (Node node: nodes) {</span>
<span class="fc" id="L51">			ret.put(node, createElementRectangle(node, offset, offsetGeneratorProvider /*, geometryConsumer */));</span>
<span class="fc" id="L52">		}</span>
		
		// Sort
<span class="fc" id="L55">		List&lt;Map.Entry&lt;Node, Rectangle&gt;&gt; remaining = new ArrayList&lt;&gt;(ret.entrySet());</span>
<span class="fc" id="L56">		List&lt;Map.Entry&lt;Node, Rectangle&gt;&gt; sorted = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L57">		Map&lt;Rectangle,Boolean&gt; downMap = new IdentityHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">		while (!remaining.isEmpty()) {</span>
<span class="fc" id="L59">			Entry&lt;Node, Rectangle&gt; candidate = null;</span>
<span class="fc" id="L60">			int candidateAffinity = 0;</span>
<span class="fc" id="L61">			boolean isCandidateDown = false;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">			for (Entry&lt;Node, Rectangle&gt; e: remaining) {</span>
				Collection&lt;Map.Entry&lt;Node, Rectangle&gt;&gt; els;
<span class="fc bfc" id="L64" title="All 2 branches covered.">				if (sorted.isEmpty()) {</span>
<span class="fc" id="L65">					els = new ArrayList&lt;&gt;(remaining);</span>
<span class="fc" id="L66">					els.remove(e);</span>
				} else {
<span class="fc" id="L68">					els = sorted;</span>
				}
<span class="fc" id="L70">				int[] eAffinity = affinity(e.getKey(), els.stream().map(Map.Entry::getKey).collect(Collectors.toList()));</span>
<span class="fc" id="L71">				int teAffinity = eAffinity[0] + eAffinity[1];</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">				if (candidate == null || (candidateAffinity &lt; teAffinity)) {</span>
<span class="fc" id="L73">					candidate = e;</span>
<span class="fc" id="L74">					candidateAffinity = teAffinity;</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">					isCandidateDown = eAffinity[1] &gt; eAffinity[0];</span>
				}		
<span class="fc" id="L77">			}</span>
<span class="fc" id="L78">			sorted.add(candidate);</span>
<span class="fc" id="L79">			downMap.put(candidate.getValue(), isCandidateDown);</span>
<span class="fc" id="L80">			remaining.remove(candidate);</span>
<span class="fc" id="L81">		}				</span>
		
<span class="fc" id="L83">		position(sorted, new HashMap&lt;&gt;(), offset, offsetGeneratorProvider, downMap::get);</span>
		
<span class="fc" id="L85">		double minX = Integer.MAX_VALUE;</span>
<span class="fc" id="L86">		double minY = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">		for (Rectangle rectangle: ret.values()) {			</span>
<span class="fc" id="L88">			minX = Math.min(rectangle.getX(), minX);</span>
<span class="fc" id="L89">			minY = Math.min(rectangle.getY(), minY);</span>
<span class="fc" id="L90">		}</span>
		
<span class="fc bfc" id="L92" title="All 2 branches covered.">		for (Rectangle rectangle: ret.values()) {</span>
<span class="fc" id="L93">			rectangle.translate((int) (-minX + offset.getX()), (int) (-minY + offset.getY()));</span>
<span class="fc" id="L94">		}	</span>
		
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (Entry&lt;Node, Rectangle&gt; e: ret.entrySet()) {</span>
<span class="fc" id="L97">			Rectangle rectangle = e.getValue();</span>
<span class="fc" id="L98">			e.getKey().getGeometry().setBounds(rectangle.x, rectangle.y, rectangle.width, rectangle.height);</span>
<span class="fc" id="L99">		}	</span>
		
<span class="fc" id="L101">		return ret;</span>
	}
	
	private static boolean isSameOrAncestor(ModelElement child, ModelElement ancestor) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">		if (child == null) {</span>
<span class="fc" id="L106">			return false;</span>
		}
<span class="fc bfc" id="L108" title="All 2 branches covered.">		if (child.equals(ancestor)) {</span>
<span class="fc" id="L109">			return true;</span>
		}
<span class="fc" id="L111">		return isSameOrAncestor(child.getParent(), ancestor);</span>
	}
	
	/**
	 * Computes affinity of a given diagram element to a collection of other elements.
	 * Affinity is a two-elements array with the first element containing a total number of 
	 * connections from the first argument element to the second argument elements recursively including child elements on both sides.
	 * The second array element contains a total number of connections from the second argument elements to the first argument element also recursively
	 * including child elements on both sides. Affinity is used to layout elements in a top-down   
	 * @param element
	 * @param elements
	 * @return
	 */
	private static int[] affinity(ModelElement element, Collection&lt;ModelElement&gt; elements) {
<span class="fc" id="L125">		int[] outgoing = { 0 };</span>
<span class="fc" id="L126">		element.accept(e -&gt; {</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">			if (e instanceof Connection) {</span>
<span class="fc" id="L128">				Node target = ((Connection) e).getTarget();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">				for (ModelElement oe: elements) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">					if (isSameOrAncestor(target, oe)) {</span>
<span class="fc" id="L131">						++outgoing[0];</span>
					}
<span class="fc" id="L133">				}</span>
			}
<span class="fc" id="L135">		}, ConnectionBase.SOURCE);</span>
		
<span class="fc" id="L137">		int[] inbound = { 0 };</span>
<span class="fc" id="L138">		element.accept(e -&gt; {</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">			if (e instanceof Connection) {</span>
<span class="fc" id="L140">				Node source = ((Connection) e).getSource();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">				for (ModelElement oe: elements) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">					if (isSameOrAncestor(source, oe)) {</span>
<span class="fc" id="L143">						++inbound[0];</span>
					}
<span class="fc" id="L145">				}</span>
			}
<span class="fc" id="L147">		}, ConnectionBase.TARGET);</span>
		
<span class="fc" id="L149">		return new int[] { outgoing[0], inbound[0] };</span>
	}
	
	/**
	 * Sorts rectangles entry set by size and affinity to positioned offset rectangles.
	 * Then positions the first element so it doesn't overlap with the offset rectangles. 
	 * Then passes the remaining elements for positioning.
	 * @param rectangles
	 * @param offsetRectangles
	 */
	private static void position(
			List&lt;Map.Entry&lt;Node, Rectangle&gt;&gt; rectangles, 
			Map&lt;Node, Rectangle&gt; offsetRectangles,
			Point offset,
			Function&lt;Boolean, Supplier&lt;Point&gt;&gt; offsetGeneratorProvider,
			Predicate&lt;Rectangle&gt; downPredicate) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">		if (rectangles.isEmpty()) {</span>
<span class="fc" id="L166">			return;</span>
		}
		
<span class="fc" id="L169">		Entry&lt;Node, Rectangle&gt; firstEntry = rectangles.get(0);</span>
<span class="fc" id="L170">		Rectangle firstRectangle = firstEntry.getValue();</span>
<span class="fc" id="L171">		position(firstRectangle, offsetRectangles.values(), offsetGeneratorProvider, downPredicate.test(firstRectangle)); </span>
<span class="fc" id="L172">		Rectangle offsetRectangle = new Rectangle(firstRectangle);</span>
<span class="fc" id="L173">		offsetRectangle.translate((int) -offset.getX(), (int) - offset.getY());</span>
<span class="fc" id="L174">		offsetRectangle.grow( 2 * (int) offset.getX(), 2 * (int) offset.getY());</span>
<span class="fc" id="L175">		offsetRectangles.put(firstEntry.getKey(), offsetRectangle);			</span>
		
<span class="fc" id="L177">		position(rectangles.subList(1, rectangles.size()), offsetRectangles, offset, offsetGeneratorProvider, downPredicate);</span>
<span class="fc" id="L178">	}</span>

	/**
	 * Positions the rectangle so it doesn't overlap with existing rectangles.
	 * @param element
	 * @param geometry
	 * @param rectangle
	 * @param rectangles
	 */
	private static void position(
			Rectangle rectangle, 
			Collection&lt;Rectangle&gt; offsetRectangles,
			Function&lt;Boolean, Supplier&lt;Point&gt;&gt; offsetGeneratorProvider,
			boolean down) {
		
<span class="fc bfc" id="L193" title="All 2 branches covered.">		if (offsetRectangles.isEmpty()) {</span>
<span class="fc" id="L194">			return;</span>
		}
		
		// Start at the center of offset rectangles union
<span class="fc" id="L198">		Rectangle union = null;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">		for (Rectangle offsetRectangle: offsetRectangles) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">			if (union == null) {</span>
<span class="fc" id="L201">				union = new Rectangle(offsetRectangle);</span>
			} else {
<span class="fc" id="L203">				union.add(offsetRectangle); </span>
			}
<span class="fc" id="L205">		}</span>
<span class="fc" id="L206">		double unionCenter = (union.getX() + union.getWidth())/2;</span>
<span class="fc" id="L207">		double unionMiddle = (union.getY() + union.getHeight())/2;</span>

<span class="fc" id="L209">		double rectangleCenter = (rectangle.getX() + rectangle.getWidth())/2;</span>
<span class="fc" id="L210">		double rectangleMiddle = (rectangle.getY() + rectangle.getHeight())/2;</span>
		
<span class="fc" id="L212">		rectangle.translate((int) (unionCenter - rectangleCenter), (int) (unionMiddle - rectangleMiddle));</span>
	
<span class="fc" id="L214">		Supplier&lt;Point&gt; offsetGenerator = offsetGeneratorProvider.apply(down);</span>
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">		Z: for (Point offset = offsetGenerator.get(); offset != null; offset = offsetGenerator.get()) {</span>
<span class="fc" id="L216">			rectangle.translate((int) offset.getX(), (int) offset.getY());</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">			for (Rectangle offsetRectangle: offsetRectangles) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">				if (!rectangle.intersection(offsetRectangle).isEmpty()) {</span>
<span class="fc" id="L219">					continue Z;</span>
				}
<span class="fc" id="L221">			}</span>
<span class="fc" id="L222">			break; // No intersection.</span>
		}
<span class="fc" id="L224">	}</span>
	
	/**
	 * @param gridSize difference x, y, or both, between offset points in pixels,
	 * @param down Direction of traversing.  
	 * @return generator of a sequence of points which are offset from the initial point for positioning of a rectangle. 
	 * This implementation returns a sequence of offsets which form concentric half-circles up or down.
	 */
	public static Supplier&lt;Point&gt; createOffsetGenerator(int gridSize, boolean down) {
<span class="fc" id="L233">		return new Supplier&lt;Point&gt;() {</span>

<span class="fc" id="L235">			private Point lastPosition = new Point(0, 0);</span>
<span class="fc" id="L236">			private Set&lt;Point&gt; visited = new HashSet&lt;&gt;();</span>

			@Override
			public Point get() {
<span class="fc bfc" id="L240" title="All 2 branches covered.">				if (visited.add(lastPosition)) {</span>
<span class="fc" id="L241">					return lastPosition;</span>
				}
<span class="fc" id="L243">				List&lt;Point&gt; newPositions = new ArrayList&lt;&gt;();					</span>
<span class="fc" id="L244">				newPositions.add(new Point(lastPosition.x + gridSize, lastPosition.y));					</span>
<span class="fc" id="L245">				newPositions.add(new Point(lastPosition.x, lastPosition.y + gridSize));					</span>
<span class="fc" id="L246">				newPositions.add(new Point(lastPosition.x + gridSize, lastPosition.y + gridSize));					</span>
<span class="fc" id="L247">				newPositions.add(new Point(lastPosition.x + gridSize, lastPosition.y - gridSize));					</span>
<span class="fc" id="L248">				newPositions.add(new Point(lastPosition.x - gridSize, lastPosition.y));					</span>
<span class="fc" id="L249">				newPositions.add(new Point(lastPosition.x, lastPosition.y - gridSize));					</span>
<span class="fc" id="L250">				newPositions.add(new Point(lastPosition.x - gridSize, lastPosition.y - gridSize));</span>
<span class="fc" id="L251">				newPositions.add(new Point(lastPosition.x - gridSize, lastPosition.y + gridSize));</span>
<span class="fc" id="L252">				newPositions.sort((a, b) -&gt; a.x*a.x + a.y*a.y - b.x*b.x - b.y*b.y);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">				for (Point newPosition: newPositions) {</span>
<span class="fc bfc" id="L254" title="All 10 branches covered.">					if ((down &amp;&amp; newPosition.y &gt;= 0 || !down &amp;&amp; newPosition.y &lt;=0) &amp;&amp; visited.add(newPosition)) {</span>
<span class="fc" id="L255">						Point offset = new Point(newPosition.x - lastPosition.x, newPosition.y - lastPosition.y);</span>
<span class="fc" id="L256">						lastPosition = newPosition;</span>
<span class="fc" id="L257">						return offset;</span>
					}
<span class="fc" id="L259">				}</span>
<span class="nc" id="L260">				throw new IllegalStateException(&quot;Nowhere to move&quot;);</span>
			}
			
		};
	}

	/**
	 * Creates a rectangle for the diagram element and its children at position 0, 0.
	 * @param element
	 * @param offset
	 * @return
	 */
	private static Rectangle createElementRectangle(
			Node node, 
			Point offset, 
			Function&lt;Boolean, Supplier&lt;Point&gt;&gt; offsetGeneratorProvider) {
		
<span class="fc" id="L277">		org.nasdanika.drawio.Rectangle nodeGeometry = node.getGeometry();</span>
<span class="fc" id="L278">		Rectangle rectangle = new Rectangle(0, 0, (int) nodeGeometry.getWidth(), (int) nodeGeometry.getHeight());</span>
<span class="fc" id="L279">		List&lt;Node&gt; children = node.getElements().stream().filter(Node.class::isInstance).map(Node.class::cast).collect(Collectors.toList());</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">		if (!children.isEmpty()) {</span>
<span class="nc" id="L281">			Point childOffset = new Point((int) offset.getX(), (int) offset.getY() + 30);</span>
<span class="nc" id="L282">			Map&lt;Node, Rectangle&gt; childGeometry = layout(children, childOffset, offsetGeneratorProvider);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">			for (ModelElement child: children) {</span>
<span class="nc" id="L284">				Rectangle childRectangle = childGeometry.get(child);</span>
<span class="nc" id="L285">				rectangle.add(childRectangle);</span>
<span class="nc" id="L286">			}</span>
<span class="nc" id="L287">			rectangle.grow((int) offset.getX(), (int) offset.getY());</span>
		}
<span class="fc" id="L289">		return rectangle;</span>
	}
	
	// Mappers
	
	private static Collection&lt;? extends Element&gt; getChildren(Element element) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if (element instanceof Document) {</span>
<span class="nc" id="L296">			return ((Document) element).getPages();</span>
		}
<span class="nc bnc" id="L298" title="All 2 branches missed.">		if (element instanceof Page) {</span>
<span class="nc" id="L299">			return Collections.singleton(((Page) element).getModel());</span>
		}
<span class="nc bnc" id="L301" title="All 2 branches missed.">		if (element instanceof Model) {</span>
<span class="nc" id="L302">			return Collections.singleton(((Model) element).getRoot());</span>
		}
<span class="nc bnc" id="L304" title="All 2 branches missed.">		if (element instanceof Root) {</span>
<span class="nc" id="L305">			return ((Root) element).getLayers();</span>
		}
<span class="nc bnc" id="L307" title="All 2 branches missed.">		if (element instanceof Layer) {</span>
<span class="nc" id="L308">			return ((Layer) element).getElements();</span>
		}
<span class="nc" id="L310">		return Collections.emptySet();</span>
	}
	
	
	public static Function&lt;Element, Stream&lt;? extends Element&gt;&gt; childrenMapper(Predicate&lt;Element&gt; predicate) {
<span class="nc" id="L315">		return new Function&lt;Element, Stream&lt;? extends Element&gt;&gt;() {</span>
						
			@Override
			public Stream&lt;? extends Element&gt; apply(Element element) {
<span class="nc" id="L319">				Stream&lt;? extends Element&gt; ret = getChildren(element).stream();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">				return predicate == null ? ret : ret.filter(predicate);</span>
			}
			
		};
	}
	
	public static Function&lt;Element, Stream&lt;? extends Element&gt;&gt; childrenRecursiveMapper() {
<span class="nc" id="L327">		return new Function&lt;Element, Stream&lt;? extends Element&gt;&gt;() {</span>
			
			@Override
			public Stream&lt;? extends Element&gt; apply(Element element) {
<span class="nc" id="L331">				return getChildren(element).stream().flatMap(childrenRecursiveMapper());</span>
			}
			
		};
		
	}
	
	public static Stream&lt;Element&gt; childrenStream(Element element, Predicate&lt;Element&gt; predicate) {
<span class="nc" id="L339">		return Stream.of(element).flatMap(childrenMapper(predicate));</span>
	}
	
	/**
	 * @param &lt;T&gt;
	 * @param visitor
	 * @param connectionBase Connection base for visiting linked pages.
	 * @return Visitor which passes itself to linked pages and adds linked pages' result to child results.
	 */
	public static &lt;T&gt; BiFunction&lt;Element, Map&lt;Element, T&gt;, T&gt; withLinkedPages(BiFunction&lt;? super Element, Map&lt;? extends Element, T&gt;, T&gt; visitor, ConnectionBase connectionBase) {
<span class="nc" id="L349">		return new BiFunction&lt;Element, Map&lt;Element, T&gt;, T&gt;() {</span>

			@Override
			public T apply(Element element, Map&lt;Element, T&gt; childResults) {				
<span class="nc bnc" id="L353" title="All 2 branches missed.">				if (element instanceof ModelElement) {</span>
<span class="nc" id="L354">					Page linkedPage = ((ModelElement) element).getLinkedPage();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">					if (linkedPage != null) {</span>
<span class="nc" id="L356">						Map&lt;Element, T&gt; cr = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">						if (childResults != null) {</span>
<span class="nc" id="L358">							cr.putAll(childResults);</span>
						}
<span class="nc" id="L360">						T linkedPageResult = linkedPage.accept(this, connectionBase);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">						if (linkedPageResult != null) {</span>
<span class="nc" id="L362">							cr.put(linkedPage, linkedPageResult);</span>
						}
<span class="nc" id="L364">						return visitor.apply(element, cr);</span>
					}
				}
<span class="nc" id="L367">				return visitor.apply(element, childResults);</span>
			}
			
		};
	}
	
	/**
	 * @param &lt;T&gt;
	 * @param visitor
	 * @param connectionBase Connection base for visiting linked pages.
	 * @return Visitor which passes itself to linked pages and adds linked pages' result to child results.
	 */
	public static &lt;T&gt; Consumer&lt;Element&gt; withLinkedPages(Consumer&lt;Element&gt; visitor, ConnectionBase connectionBase) {
<span class="fc" id="L380">		return new Consumer&lt;Element&gt;() {</span>

			@Override
			public void accept(Element element) {				
<span class="fc bfc" id="L384" title="All 2 branches covered.">				if (element instanceof ModelElement) {</span>
<span class="fc" id="L385">					Page linkedPage = ((ModelElement) element).getLinkedPage();</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">					if (linkedPage != null) {</span>
<span class="fc" id="L387">						linkedPage.accept(this, connectionBase);</span>
					}
				}
<span class="fc" id="L390">				visitor.accept(element);</span>
<span class="fc" id="L391">			}</span>
			
		};
	}
	
//	/**
//	 * Creates an element wrapper which substitutes accept()'s visitor with a visitor which also traverses linked pages.
//	 * @param element
//	 * @return
//	 */
//	public static org.nasdanika.graph.Element withLinkedPages(org.nasdanika.graph.Element element) {
//		
//	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>