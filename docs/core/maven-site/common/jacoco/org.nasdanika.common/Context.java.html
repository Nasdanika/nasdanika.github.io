<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Context.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika Common</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.common</a> &gt; <span class="el_source">Context.java</span></div><h1>Context.java</h1><pre class="source lang-java linenums">package org.nasdanika.common;

import java.io.File;
import java.io.InputStream;
import java.io.Reader;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A generic source of contextual information keyed by a {@link String} - property, or a {@link Class} (type) - service. 
 * @author Pavel
 *
 */
public interface Context extends Composeable&lt;Context&gt; {
	
	/**
	 * Constant for base URI property.
	 */
	String BASE_URI_PROPERTY = &quot;base-uri&quot;;
	
	/**
	 * Empty context which can be used as a starting point
	 * for creating of composed/mounted contexts. 
	 */
<span class="fc" id="L39">	static final Context EMPTY_CONTEXT = new Context() {</span>
		
		/**
		 * For types with static INSTANCE field of compatible type returns field value.
		 */
		@SuppressWarnings(&quot;unchecked&quot;)
		@Override
		public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="pc bfc" id="L47" title="All 2 branches covered.">			for (Field f: type.getFields()) {</span>
<span class="pc bpc" id="L48" title="3 of 6 branches missed.">				if (&quot;INSTANCE&quot;.equals(f.getName()) &amp;&amp; Modifier.isStatic(f.getModifiers()) &amp;&amp; type.isAssignableFrom(f.getType())) {</span>
					try {
<span class="fc" id="L50">						return (T) f.get(null);</span>
<span class="nc" id="L51">					} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L52">						throw new NasdanikaException(&quot;Error accessing INSTANCE field of &quot; + type.getName(), e);</span>
					}
				}
			}
<span class="fc" id="L56">			return null;</span>
		}
		
		@Override
		public Object get(String key) {
<span class="fc" id="L61">			return null;</span>
		}
		
		/**
		 * Returns this context if other is null or other context otherwise because there is no
		 * reason to compose the empty context. A convenient method to get a non-null context.
		 */
		@Override
		public Context compose(Context other) {
<span class="nc bnc" id="L70" title="All 2 branches missed.">			return other == null ? this : other;</span>
		}
		
	};
	
	/**
	 * @param key Object key (property name).
	 * @return Property by a key.
	 */
	Object get(String key);
	
	/**
	 * Convenience method for retrieving string properties.
	 * @param key
	 * @return
	 */
	default String getString(String key) {
<span class="nc" id="L87">		return get(key, String.class);</span>
	}
	
	/**
	 * Convenience method for retrieving string properties.
	 * @param key
	 * @param defaultValue
	 * @return
	 */
	default String getString(String key, String defaultValue) {
<span class="fc" id="L97">		return get(key, String.class, defaultValue);</span>
	}
	
	/**
	 * @param key Object key (property name).
	 * @param defaultValue value to return if key is not present.
	 * @return Property by key or default value if property is not present.
	 */
	default Object get(String key, Object defaultValue) {
<span class="fc" id="L106">		Object ret = get(key);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		return ret == null ? defaultValue : ret;</span>
	}
	
	/**
	 * @param key Object key (property name).
	 * @param computer FunctionFactory to compute value if key is not present.
	 * @return Property by key of a value returned by the computer if property is not present.
	 */
	default Object get(String key, Function&lt;String,Object&gt; computer) {
<span class="nc" id="L116">		Object ret = get(key);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		return ret == null ? computer.apply(key) : ret;		</span>
	}
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @return Service of a particular type. Multiple service instances maybe obtained by passing an array type.
	 */
	&lt;T&gt; T get(Class&lt;T&gt; type);
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @param defaultService Default service implementation to return if no service is found. 
	 * @return Service of a particular type or default service if no service of requested type is found in the context. Multiple service instances maybe obtained by passing an array type.
	 */
	default &lt;T&gt; T get(Class&lt;T&gt; type, T defaultService) {
<span class="fc" id="L134">		T ret = get(type);</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">		return ret == null ? defaultService : ret;		</span>
	}
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @param computer FunctionFactory to compute a service instance if none is found in the context.
	 * @return Service of a particular type or a service returned by the computer if not service of requested type is found in the context. Multiple service instances maybe obtained by passing an array type.
	 */
	default &lt;T&gt; T get(Class&lt;T&gt; type, Function&lt;Class&lt;T&gt;,T&gt; computer) {
<span class="nc" id="L145">		T ret = get(type);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		return ret == null ? computer.apply(type) : ret;		</span>
	}
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @param predicate Service predicate (filter).
	 * @return Service of a particular type. Multiple service instances maybe obtained by passing an array type. To filter multiple instances use Predicate&amp;lt;Object&amp;gt; for
	 * compatibility with both array and component types. 
	 */
	default &lt;T&gt; T get(Class&lt;T&gt; type, Predicate&lt;? super T&gt; predicate) {
<span class="nc" id="L157">		T ret = get(type);</span>
<span class="nc bnc" id="L158" title="All 4 branches missed.">		return predicate == null || predicate.test(ret) ? ret : null;</span>
	};
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @param predicate Service predicate (filter).
	 * @param defaultService Default service implementation to return if no service is found. 
	 * @return Service of a particular type. Multiple service instances maybe obtained by passing an array type. To filter multiple instances use Predicate&amp;lt;Object&amp;gt; for
	 * compatibility with both array and component types. 
	 */
	default &lt;T&gt; T get(Class&lt;T&gt; type, Predicate&lt;? super T&gt; predicate, T defaultService) {
<span class="nc" id="L170">		T ret = get(type, predicate);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">		return ret == null ? defaultService : ret;		</span>
	}
	
	/**
	 * @param &lt;T&gt; Service type.
	 * @param type Service type class.
	 * @param predicate Service predicate (filter).
	 * @param computer FunctionFactory to compute a service instance if none is found in the context.
	 * @return Service of a particular type. Multiple service instances maybe obtained by passing an array type. To filter multiple instances use Predicate&amp;lt;Object&amp;gt; for
	 * compatibility with both array and component types. 
	 */
	default &lt;T&gt; T get(Class&lt;T&gt; type, Predicate&lt;? super T&gt; predicate, Function&lt;Class&lt;T&gt;,T&gt; computer) {
<span class="nc" id="L183">		T ret = get(type, predicate);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">		return ret == null ? computer.apply(type) : ret;		</span>
	}
	
	/**
	 * Returns a property converted to the requested type. E.g. property which is a {@link File} or {@link URL} may be converted to {@link InputStream}, {@link Reader} or {@link String}.
	 * The default implementation looks up {@link Converter} service to convert the value returned by &lt;code&gt;get(String)&lt;/code&gt; to requested type and falls-back to {@link DefaultConverter}.INSTANCE
	 * if the converter service is not present in the context.
	 * @param &lt;T&gt; Property type.
	 * @param key Object key (property/service name).
	 * @param type Property type class.
	 * @return Property by key converted to requested type. 
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default &lt;T&gt; T get(String key, Class&lt;T&gt; type) {
<span class="fc" id="L198">		Object prop = get(key);</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">		if (type == null || type.isInstance(prop)) {</span>
<span class="fc" id="L200">			return (T) prop;</span>
		}
<span class="fc" id="L202">		return get(Converter.class, DefaultConverter.INSTANCE).convert(prop, type);</span>
	}
	
	/**
	 * Returns a property converted to the requested type. E.g. property which is a {@link File} or {@link URL} may be converted to {@link InputStream}, {@link Reader} or {@link String}.
	 * The default implementation looks up {@link Converter} service to convert the value returned by &lt;code&gt;get(String)&lt;/code&gt; to requested type and falls-back to {@link DefaultConverter}.INSTANCE
	 * if the converter service is not present in the context.
	 * @param &lt;T&gt; Property/service type.
	 * @param key Object key (property/service name).
	 * @param type Property/service type class.
	 * @param defaultValue Default property value. 
	 * @return Property by key converted to requested type or default value if property is not found. 
	 */
	default &lt;T&gt; T get(String key, Class&lt;T&gt; type, T defaultValue) {
<span class="fc" id="L216">		T ret = get(key, type);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">		return ret == null ? defaultValue : ret;		</span>
	}
	
	/**
	 * Returns a property converted to the requested type. E.g. property which is a {@link File} or {@link URL} may be converted to {@link InputStream}, {@link Reader} or {@link String}.
	 * The default implementation looks up {@link Converter} service to convert the value returned by &lt;code&gt;get(String)&lt;/code&gt; to requested type and falls-back to {@link DefaultConverter}.INSTANCE
	 * if the converter service is not present in the context.
	 * @param &lt;T&gt; Property/service type.
	 * @param key Object key (property/service name).
	 * @param type Property/service type class.
	 * @param computer FunctionFactory to compute property value if none is found in the context.
	 * @return Property by key converted to requested type or computed value if property is not present. 
	 */
	default &lt;T&gt; T get(String key, Class&lt;T&gt; type, BiFunction&lt;String,Class&lt;T&gt;,T&gt; computer)  {
<span class="nc" id="L231">		T ret = get(key, type);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">		return ret == null ? computer.apply(key, type) : ret;		</span>
	}
	
	/**
	 * Mounts a context under a specified prefix. get(String) and get(String,Class) methods look up property/source in the mounted context first if the key start with the prefix, removing the prefix.
	 * E.g. if the prefix is &lt;code&gt;resources/&lt;/code&gt; then &lt;code&gt;get(&quot;resources/myResource&quot;)&lt;/code&gt; will call &lt;code&gt;get(&quot;myResource&quot;)&lt;/code&gt; in the mounted resource first and will return a value if it is not null.
	 * If the value returned by the mounted context is null, then the value from &lt;code&gt;get(&quot;resources/myResource&quot;)&lt;/code&gt; call to this context will be returned.
	 * In other words, the mounted value shadows this context value, but doesn't hide it.
	 * Typed service calls are always made against this context.
	 * @param context Context to mount.
	 * @param prefix Mount prefix.
	 * @return This context if argument context or argument prefix are null null or a context which delegates get(String) and get(String,Class) to the mounted context if the key start with the prefix. 
	 */
	default Context mount(Context context, String prefix) {
<span class="nc bnc" id="L246" title="All 4 branches missed.">		if (context == null || prefix == null) {</span>
<span class="nc" id="L247">			return this;</span>
		}
		
<span class="nc" id="L250">		return new Context() {</span>

			@Override
			public Object get(String key) {
<span class="nc bnc" id="L254" title="All 4 branches missed.">				if (key != null &amp;&amp; key.startsWith(prefix)) {</span>
<span class="nc" id="L255">					Object ret = context.get(key.substring(prefix.length()));</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">					if (ret != null) {</span>
<span class="nc" id="L257">						return ret;</span>
					}
				}
<span class="nc" id="L260">				return Context.this.get(key);</span>
			}

			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc" id="L265">				return Context.this.get(type);</span>
			}

			@Override
			public &lt;T&gt; T get(String key, Class&lt;T&gt; type) {
<span class="nc bnc" id="L270" title="All 4 branches missed.">				if (key != null &amp;&amp; key.startsWith(prefix)) {</span>
<span class="nc" id="L271">					T ret = context.get(key.substring(prefix.length()), type);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">					if (ret != null) {</span>
<span class="nc" id="L273">						return ret;</span>
					}
				}
<span class="nc" id="L276">				return Context.this.get(key, type);</span>
			}
			
		};
	}
	
	/**
	 * @param mapper Key mapping function. 
	 * @return A context which maps the key using the mapper function in &lt;code&gt;get(String&gt;&lt;/code&gt; and &lt;code&gt;get(String,Class)&lt;/code&gt; methods. Returns this context if mapper is null.
	 */
	default Context map(Function&lt;String,String&gt; mapper) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">		if (mapper == null) {</span>
<span class="nc" id="L288">			return this;</span>
		}
		
<span class="fc" id="L291">		return new Context() {</span>

			@Override
			public Object get(String key) {
<span class="fc" id="L295">				return Context.this.get(mapper.apply(key));</span>
			}

			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc" id="L300">				return Context.this.get(type);</span>
			}

			@Override
			public &lt;T&gt; T get(String key, Class&lt;T&gt; type) {
<span class="nc" id="L305">				return Context.this.get(mapper.apply(key), type);</span>
			}
			
		};
	}
	
	/**
	 * Returns this context if other is null, or a new context which delegates to this context and falls back to the other if property/service is not found in this context.
	 * @param chain
	 */
	default Context compose(Context other) {
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if (other == null) {</span>
<span class="nc" id="L317">			return this;</span>
		}
		
<span class="nc" id="L320">		Context[] chain = {this, other};</span>
		
<span class="nc" id="L322">		return new Context() {</span>
			
			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">				for (Context ce: chain) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">					if (ce != null) {</span>
<span class="nc" id="L328">						T ret = ce.get(type);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">						if (ret != null) {</span>
<span class="nc" id="L330">							return ret;</span>
						}
					}
				}
<span class="nc" id="L334">				return null;</span>
			}
						
			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type, Predicate&lt;? super T&gt; predicate) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">				for (Context ce: chain) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">					if (ce != null) {</span>
<span class="nc" id="L341">						T ret = ce.get(type, predicate);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">						if (ret != null) {</span>
<span class="nc" id="L343">							return ret;</span>
						}
					}
				}
<span class="nc" id="L347">				return null;</span>
			}			
			
			@Override
			public Object get(String key) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">				for (Context ce: chain) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">					if (ce != null) {</span>
<span class="nc" id="L354">						Object ret = ce.get(key);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">						if (ret != null) {</span>
<span class="nc" id="L356">							return ret;</span>
						}
					}
				}
<span class="nc" id="L360">				return null;</span>
			}
			
			@Override
			public &lt;T&gt; T get(String key, Class&lt;T&gt; type) {
<span class="nc bnc" id="L365" title="All 2 branches missed.">				for (Context ce: chain) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">					if (ce != null) {</span>
<span class="nc" id="L367">						T ret = ce.get(key, type);</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">						if (ret != null) {</span>
<span class="nc" id="L369">							return ret;</span>
						}
					}
				}
<span class="nc" id="L373">				return null;</span>
			}
						
		};
	}
	
	/**
	 * Creates a new mutable context backed by this context.
	 * This call is equivalent to ``fork(null,null)``.
	 * @return
	 */
	default MutableContext fork() {
<span class="nc" id="L385">		return fork(null,null);</span>
	}
	
	/**
	 * Creates a new mutable context with a given prefix and service predicate. 
	 * @param mapper Mapper functions, the same as in map();
	 * @param servicePredicate Predicate to use during look up of parent services. One possible scenario is to filter-out {@link Composeable} services from the parent.
	 * @return
	 */
	default MutableContext fork(Function&lt;String,String&gt; mapper, Predicate&lt;Object&gt; servicePredicate) {
<span class="nc" id="L395">		Context mapped = map(mapper);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">		if (servicePredicate == null) {</span>
<span class="nc" id="L397">			return new SimpleMutableContext(mapped);</span>
		}
<span class="nc" id="L399">		Context predicated = new Context() {</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc" id="L404">				T ret = mapped.get(type);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">				if (ret == null) {</span>
<span class="nc" id="L406">					return null;</span>
				}
<span class="nc bnc" id="L408" title="All 2 branches missed.">				if (ret.getClass().isArray()) {</span>
<span class="nc" id="L409">					List&lt;Object&gt; filtered = new ArrayList&lt;Object&gt;(); </span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">					for (int i = 0; i &lt; Array.getLength(ret); ++i) {</span>
<span class="nc" id="L411">						Object service = Array.get(ret, i);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">						if (servicePredicate.test(service)) {</span>
<span class="nc" id="L413">							filtered.add(service);</span>
						}
					}
<span class="nc" id="L416">					ret = (T) filtered.toArray((Object[]) Array.newInstance(ret.getClass().getComponentType(), filtered.size()));</span>
				}
<span class="nc bnc" id="L418" title="All 2 branches missed.">				return servicePredicate.test(ret) ? null : ret;</span>
			}
			
			@Override
			public Object get(String key) {
<span class="nc" id="L423">				return mapped.get(key);</span>
			}
		};
<span class="nc" id="L426">		return new SimpleMutableContext(predicated);</span>
	}
		
<span class="fc" id="L429">	static Pattern EXPANDER_PATTERN = Pattern.compile(&quot;\\$\\{(.+?)\\}&quot;);	</span>
	
	/**
	 * Expands tokens in the form of ``${token name|default value}`` to their values.
	 * If a token is not found the default value after the pipe is used for expansion.
	 * If there is no default value then the expansion is not processed. Token names shall not contain pipes.
	 * If replacement is not null and there is a {@link Converter} service then the converter is used 
	 * to convert the replacement to {@link String}. If no such conversion can be done then toString() is used 
	 * as default conversion. Add extra open/closing curly brackets to escape the token, e.g. in documentation. 
	 * For example &lt;code&gt;${{xyz}}&lt;/code&gt; will be &quot;interpolated&quot; as &lt;code&gt;${xyz}&lt;/code&gt;. There may be multiple levels of curly brackets.
	 * This behavior may be leveraged in multi-stage interpolation where early stage interpolators &quot;peel&quot; the token until it comes at the interpolation level where it is supposed to be expanded.    
	 * @param input
	 * @return If the string contains just a single token then the token value is returned as-is. Otherwise tokens in the input are replaced with their values converted to string using context {@link Converter} service if it is present or toString() method.
	 */
	default Object interpolate(String input) {
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		if (input == null) {</span>
<span class="nc" id="L445">			return input;</span>
		}
		
		// Computing properties.
<span class="fc" id="L449">		Context tokenComputer = computingContext();</span>
		
<span class="fc" id="L451">		Matcher matcher = EXPANDER_PATTERN.matcher(input);</span>
<span class="fc" id="L452">		StringBuilder output = new StringBuilder();</span>
<span class="fc" id="L453">		int i = 0;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">		while (matcher.find()) {</span>
<span class="fc" id="L455">		    String token = matcher.group();</span>
<span class="fc" id="L456">		    String peeledToken = token.substring(2, token.length()-1); // Peeling of ${ and }</span>
<span class="pc bpc" id="L457" title="2 of 6 branches missed.">		    if (peeledToken.startsWith(&quot;{&quot;) &amp;&amp; input.length() &gt; matcher.end() &amp;&amp; '}' == input.charAt(matcher.end())) {</span>
<span class="fc" id="L458">			    output</span>
<span class="fc" id="L459">			    	.append(input.substring(i, matcher.start() + 2))</span>
<span class="fc" id="L460">			    	.append(peeledToken.substring(1));</span>
<span class="fc" id="L461">			    i = matcher.end();</span>
		    } else {
<span class="fc" id="L463">			    int pipeIdx = peeledToken.indexOf('|');</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">			    String defaultValue = pipeIdx == -1 ? null : peeledToken.substring(pipeIdx + 1);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			    if (pipeIdx != -1) {</span>
<span class="fc" id="L466">			    	peeledToken = peeledToken.substring(0, pipeIdx);</span>
			    }
			    
<span class="fc bfc" id="L469" title="All 4 branches covered.">		    	if (matcher.start() == 0 &amp;&amp; matcher.end() == input.length()) {</span>
<span class="fc" id="L470">		    		Object replacement = tokenComputer.get(peeledToken, defaultValue);</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">					return replacement == null ? input : replacement;</span>
		    	}
			    
<span class="fc" id="L474">				Object replacement = tokenComputer.getString(peeledToken, defaultValue);</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">			    if (replacement != null) {</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">			    	if (!(replacement instanceof String)) {</span>
<span class="nc" id="L477">				    	Converter converter = get(Converter.class);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">				    	if (converter != null) {</span>
<span class="nc" id="L479">				    		String str = converter.convert(replacement, String.class);</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">				    		if (str != null) {</span>
<span class="nc" id="L481">				    			replacement = str;</span>
				    		}
				    	}
			    	}
<span class="fc" id="L485">				    output.append(input.substring(i, matcher.start())).append(replacement);			    </span>
<span class="fc" id="L486">				    i = matcher.end();</span>
			    }
		    }
<span class="fc" id="L489">		}</span>
<span class="fc" id="L490">		output.append(input.substring(i, input.length()));</span>
<span class="fc" id="L491">		return output.toString();</span>
	}
	
	/**
	 * Interpolates to {@link String}.
	 * @param input
	 * @return
	 */
	default String interpolateToString(String input) {
<span class="nc" id="L500">		Object result = interpolate(input);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L502">			return null;</span>
		}
<span class="nc bnc" id="L504" title="All 2 branches missed.">		if (result instanceof String) {</span>
<span class="nc" id="L505">			return (String) result;</span>
		}
<span class="nc" id="L507">    	Converter converter = get(Converter.class);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">    	if (converter != null) {</span>
<span class="nc" id="L509">    		String str = converter.convert(result, String.class);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">    		if (str != null) {</span>
<span class="nc" id="L511">    			return str;</span>
    		}
    	}		
<span class="nc" id="L514">    	return String.valueOf(result);</span>
	}
	
	/**
	 * Creates a copy of this map using {@link LinkedHashMap} with {@link String} values interpolated and
	 * {@link Map} and {@link Collection} values passed through interpolate methods with respective parameter types.
	 * @param input
	 * @return A deep copy of the map with string values interpolated.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default &lt;K&gt; Map&lt;K,Object&gt; interpolate(Map&lt;K,?&gt; input) {
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">		if (input == null) {</span>
<span class="nc" id="L526">			return null;</span>
		}
<span class="fc" id="L528">		Map&lt;K,Object&gt; ret = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L529">		input.forEach((k,v) -&gt; {</span>
			Object u;
<span class="fc bfc" id="L531" title="All 2 branches covered.">			if (v instanceof String) {</span>
<span class="fc" id="L532">				u = interpolate((String) v);</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">			} else if (v instanceof Collection) {</span>
<span class="nc" id="L534">				u = interpolate((Collection&lt;Object&gt;) v);</span>
<span class="pc bpc" id="L535" title="1 of 2 branches missed.">			} else if (v instanceof Map) {</span>
<span class="fc" id="L536">				u = interpolate((Map&lt;K,Object&gt;) v);</span>
			} else {
<span class="nc" id="L538">				u = v;</span>
			}
<span class="fc" id="L540">			ret.put(k,u);</span>
<span class="fc" id="L541">		});</span>
<span class="fc" id="L542">		return ret;</span>
	}
	
	/**
	 * Creates a copy of this map using {@link ArrayList} with {@link String} values interpolated and
	 * {@link Map} and {@link Collection} values passed through interpolate methods with respective parameter types.
	 * @param input
	 * @return A deep copy of the collection with string values interpolated.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	default List&lt;Object&gt; interpolate(Collection&lt;?&gt; input) {
<span class="nc bnc" id="L553" title="All 2 branches missed.">		if (input == null) {</span>
<span class="nc" id="L554">			return null;</span>
		}
<span class="nc" id="L556">		List&lt;Object&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L557">		input.forEach(v -&gt; {</span>
			Object u;
<span class="nc bnc" id="L559" title="All 2 branches missed.">			if (v instanceof String) {</span>
<span class="nc" id="L560">				u = interpolate((String) v);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">			} else if (v instanceof Collection) {</span>
<span class="nc" id="L562">				u = interpolate((Collection&lt;Object&gt;) v);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">			} else if (v instanceof Map) {</span>
<span class="nc" id="L564">				u = interpolate((Map&lt;Object,Object&gt;) v);</span>
			} else {
<span class="nc" id="L566">				u = v;</span>
			}
<span class="nc" id="L568">			ret.add(u);</span>
<span class="nc" id="L569">		});</span>
<span class="nc" id="L570">		return ret;</span>
		
	}
	
	/**
	 * @return A context backed by this context which caches values of propeties by key and of services by type.
	 */	
	default Context cachingContext() {
		
<span class="nc" id="L579">		return new Context() {</span>
			
<span class="nc" id="L581">			private Map&lt;String, Optional&lt;Object&gt;&gt; properties = new HashMap&lt;&gt;();</span>
<span class="nc" id="L582">			private Map&lt;Class&lt;?&gt;, Optional&lt;Object&gt;&gt; services = new HashMap&lt;&gt;();</span>
			
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc" id="L588">				Optional&lt;Object&gt; sopt = services.computeIfAbsent(type, (theType) -&gt; Optional.ofNullable(Context.this.get(theType)));</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">				return sopt.isPresent() ? (T) sopt.get() : null;</span>
			}
			
			@Override
			public Object get(String key) {
<span class="nc" id="L594">				Optional&lt;Object&gt; popt = properties.computeIfAbsent(key, (theKey) -&gt; Optional.ofNullable(Context.this.get(theKey)));</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">				return popt.isPresent() ? popt.get() : null;</span>
			}
			
		};
				
	}
	
	/**
	 * Computing context retrieves properties from this context. If a property is found and is of {@link PropertyComputer} type, then the property computer is
	 * invoked to produce value otherwise the value is returned as is. If a property for a given key is not found, the computer traverses the key hierarchy up. Slash (/) is 
	 * a key separator. When it finds a parent property value then is computes the property value in the following way - for a property computer its compute() method is invoked,
	 * for {@link Context} the path from the parent property is used to retrieve value, for {@link Map} its get method is used, for {@link List} an element is retrived if key path is parseable to int,  
	 * for {@link Function} the path is passed to it as an argument and the value is returned as property value. 
	 * @return 
	 */
	default Context computingContext() {
		
<span class="fc" id="L612">		return new Context() {</span>

			@Override
			public Object get(String key) {
<span class="fc" id="L616">				return get(key, Object.class);</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T get(String key, Class&lt;T&gt; type) {
<span class="fc" id="L622">				Object value = Context.this.get(key, (Class&lt;?&gt;) null);</span>
				
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">				if (value instanceof PropertyComputer) {</span>
<span class="nc" id="L625">					return ((PropertyComputer) value).compute(this, key, null, type);</span>
				}
				
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">				if (value instanceof Function) {</span>
<span class="nc" id="L629">					return ((Function&lt;Context, T&gt;) value).apply(this);</span>
				}
				
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">				if (value instanceof BiFunction) {</span>
<span class="nc" id="L633">					return ((BiFunction&lt;Context, Class&lt;?&gt;, T&gt;) value).apply(this, type);</span>
				}													
				
<span class="fc" id="L636">				T ret = Context.this.get(key, type);</span>
				
				// At the spot computing of the property itself
				
<span class="fc bfc" id="L640" title="All 2 branches covered.">				return ret == null ? computeByParent(key, null, type) : ret;</span>
			}
			
			/**
			 * Computes value by walking up the property key path.
			 * @param &lt;T&gt;
			 * @param key Current path
			 * @param path Key path after the key
			 * @param type
			 * @return
			 */
			@SuppressWarnings(&quot;unchecked&quot;)
			private &lt;T&gt; T computeByParent(String key, String path, Class&lt;T&gt; type) {				
				Converter converter;
<span class="pc bpc" id="L654" title="1 of 4 branches missed.">				if (type == null || type == Object.class) {</span>
<span class="fc" id="L655">					converter = new Converter() {</span>
						
						@Override
						public &lt;TP&gt; TP convert(Object source, Class&lt;TP&gt; type) {
<span class="nc" id="L659">							return (TP) source;</span>
						}
					};  
				} else {
<span class="fc" id="L663">					converter = get(Converter.class, DefaultConverter.INSTANCE);</span>
				}
				
<span class="fc" id="L666">				int lastSlash = key.lastIndexOf('/');</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">				if (lastSlash == -1) {</span>
<span class="fc" id="L668">					return null;</span>
				}
				
<span class="fc" id="L671">				String parentKey = key.substring(0, lastSlash);</span>
<span class="fc" id="L672">				String subKey = key.substring(lastSlash + 1);</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">				if (path != null) {</span>
<span class="fc" id="L674">					subKey += &quot;/&quot; + path;</span>
				}
<span class="fc" id="L676">				Object parentProperty = Context.this.get(parentKey);</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">				if (parentProperty instanceof PropertyComputer) {</span>
<span class="fc" id="L678">					return ((PropertyComputer) parentProperty).compute(this,  parentKey, subKey, type);</span>
				}
				
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">				if (parentProperty instanceof Context) {</span>
<span class="nc" id="L682">					return ((Context) parentProperty).get(subKey, type);	</span>
				}
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">				if (parentProperty instanceof Map) {</span>
<span class="nc" id="L685">					return converter.convert(((Map&lt;?,?&gt;) parentProperty).get(subKey), type);</span>
				}
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">				if (parentProperty instanceof List) {</span>
					try {
<span class="nc" id="L689">						int idx = Integer.parseInt(subKey);</span>
<span class="nc bnc" id="L690" title="All 4 branches missed.">						if (idx &gt;= 0 &amp;&amp; idx &lt; ((List&lt;?&gt;) parentProperty).size()) {</span>
<span class="nc" id="L691">							return converter.convert(((List&lt;?&gt;) parentProperty).get(idx), type);</span>
						}
<span class="nc" id="L693">					} catch (NumberFormatException e) {</span>
						// NOP
<span class="nc" id="L695">					}</span>
				}
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">				if (parentProperty instanceof Function) {</span>
<span class="nc" id="L698">					return converter.convert(((Function&lt;String, Object&gt;) parentProperty).apply(subKey), type);</span>
				}

<span class="fc" id="L701">				return computeByParent(parentKey, subKey, type);</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="fc" id="L707">				T svc = Context.this.get(type);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">				if (svc instanceof ServiceComputer) {</span>
<span class="fc" id="L709">					return ((ServiceComputer&lt;T&gt;) svc).compute(this, type);</span>
				}
<span class="fc bfc" id="L711" title="All 2 branches covered.">				if (svc != null) {</span>
<span class="fc" id="L712">					return svc;</span>
				}
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">				for (Field f: type.getFields()) {</span>
<span class="nc bnc" id="L715" title="All 6 branches missed.">					if (&quot;INSTANCE&quot;.equals(f.getName()) &amp;&amp; Modifier.isStatic(f.getModifiers()) &amp;&amp; type.isAssignableFrom(f.getType())) {</span>
						try {
<span class="nc" id="L717">							return (T) f.get(null);</span>
<span class="nc" id="L718">						} catch (IllegalArgumentException | IllegalAccessException e) {</span>
<span class="nc" id="L719">							throw new NasdanikaException(&quot;Error accessing INSTANCE field of &quot; + type.getName(), e);</span>
						}
					}
				}
<span class="fc" id="L723">				return null;				</span>
			}
			
			@Override
			public String toString() {
<span class="nc" id="L728">				return &quot;Computing context &quot; + super.toString();</span>
			}
			
		};
	}
	
	/**
	 * Creates a context with a single service entry.
	 * @param key
	 * @param value
	 * @return
	 */
	static &lt;T&gt; Context singleton(Class&lt;T&gt; type, T service) {
<span class="nc" id="L741">		return new Context() {</span>

			@Override
			public Object get(String key) {
<span class="nc" id="L745">				return null;</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;ST&gt; ST get(Class&lt;ST&gt; sType) {
<span class="nc bnc" id="L751" title="All 2 branches missed.">				Object ret = sType == type ? service : null;</span>
<span class="nc" id="L752">				return (ST) ret;</span>
			}
			
		};
	}	
	
	/**
	 * Creates a context with a single property entry.
	 * @param key
	 * @param value
	 * @return
	 */
	static Context singleton(String key, Object value) {	
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">		return wrap(k -&gt; key.equals(k) ? value : null);</span>
	}

	/**
	 * Wraps a source function, e.g. Map&lt;String,Object&gt;::get into a context. Performs resolution of hierarchical properties.
	 * @param source Source function.
	 * @return
	 */
	static Context wrap(Function&lt;String,Object&gt; source) {
<span class="fc" id="L774">		return new Context() {</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public Object get(String key) {
<span class="fc" id="L779">				Object ret = source.apply(key);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">				if (ret != null) {</span>
<span class="fc" id="L781">					return ret;</span>
				}
				
<span class="fc" id="L784">				int lastSlash = key.lastIndexOf('/');</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">				if (lastSlash == -1) {</span>
<span class="nc" id="L786">					return null;</span>
				}
				
<span class="fc" id="L789">				Object parentProperty = get(key.substring(0, lastSlash));</span>
<span class="fc" id="L790">				String subKey = key.substring(lastSlash + 1);</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">				if (parentProperty instanceof Context) {</span>
<span class="nc" id="L792">					return ((Context) parentProperty).get(subKey);	</span>
				}
<span class="fc bfc" id="L794" title="All 2 branches covered.">				if (parentProperty instanceof Map) {</span>
<span class="fc" id="L795">					return ((Map&lt;?,?&gt;) parentProperty).get(subKey);</span>
				}
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">				if (parentProperty instanceof List) {</span>
					try {
<span class="nc" id="L799">						int idx = Integer.parseInt(subKey);</span>
<span class="nc bnc" id="L800" title="All 4 branches missed.">						if (idx &gt;= 0 &amp;&amp; idx &lt; ((List&lt;?&gt;) parentProperty).size()) {</span>
<span class="nc" id="L801">							return ((List&lt;?&gt;) parentProperty).get(idx);</span>
						}
<span class="nc" id="L803">					} catch (NumberFormatException e) {</span>
						// NOP
<span class="nc" id="L805">					}</span>
				}
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">				if (parentProperty instanceof Function) {</span>
<span class="fc" id="L808">					return ((Function&lt;String, Object&gt;) parentProperty).apply(subKey);</span>
				}

<span class="nc" id="L811">				return null;</span>
			}

			@Override
			public &lt;T&gt; T get(Class&lt;T&gt; type) {
<span class="nc" id="L816">				return null;</span>
			}
			
		};
	}	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>