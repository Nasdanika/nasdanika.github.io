<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Util.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika Persistence</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.persistence</a> &gt; <span class="el_source">Util.java</span></div><h1>Util.java</h1><pre class="source lang-java linenums">package org.nasdanika.persistence;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import org.nasdanika.common.Adaptable;
import org.nasdanika.common.CollectionCompoundConsumerFactory;
import org.nasdanika.common.CommandFactory;
import org.nasdanika.common.CompoundCommandFactory;
import org.nasdanika.common.ConsumerFactory;
import org.nasdanika.resources.BinaryEntityContainer;

<span class="nc" id="L18">public class Util {</span>
		
	/**
	 * Returns marker if map is {@link MarkedLinkedHashMap} and the key is marked, or null otherwise.
	 * @param map
	 * @param key
	 * @return
	 */
	public static List&lt;? extends Marker&gt; getMarkers(Map&lt;?,?&gt; map, Object key) {
<span class="nc bnc" id="L27" title="All 2 branches missed.">		if (map instanceof MarkedLinkedHashMap) {</span>
<span class="nc" id="L28">			return ((MarkedLinkedHashMap&lt;?,?&gt;) map).getEntryMarkers(key);</span>
		}
<span class="nc" id="L30">		return null;</span>
	}
		
	/**
	 * Returns marker if collection is {@link MarkedArrayList} and the index is present is marked, or null otherwise.
	 * @param map
	 * @param key
	 * @return
	 */
	public static List&lt;? extends Marker&gt; getMarkers(Collection&lt;?&gt; collection, int index) {
<span class="nc bnc" id="L40" title="All 6 branches missed.">		return collection instanceof MarkedArrayList &amp;&amp; index &gt; -1 &amp;&amp; index &lt; ((MarkedArrayList&lt;?&gt;) collection).getElementMarkers().size() ? ((MarkedArrayList&lt;?&gt;) collection).getElementMarkers().get(index) : null;</span>
	}
		
	/**
	 * Convenience method for adding a marker to exception messages if source is {@link MarkedLinkedHashMap}.
	 * @param candidate
	 * @param prefix
	 * @return
	 */
	public static String mark(String prefix, Object source, String key) {
<span class="nc bnc" id="L50" title="All 2 branches missed.">		if (source instanceof MarkedLinkedHashMap) {</span>
<span class="nc" id="L51">			List&lt;? extends Marker&gt; markers = ((MarkedLinkedHashMap&lt;?,?&gt;) source).getEntryMarkers(key);</span>
<span class="nc bnc" id="L52" title="All 4 branches missed.">			if (markers != null &amp;&amp; !markers.isEmpty()) {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">				return (prefix == null ? &quot;&quot; : prefix) + markers.stream().map(Object::toString).collect(Collectors.joining(&quot;, &quot;));</span>
			}
		}
		
<span class="nc" id="L57">		return &quot;&quot;;</span>
	}
	
	// --- Helper methods for loading configuration from maps

	/**
	 * Returns a {@link String} value or throws {@link ConfigurationException} if value is not null and not a string.
	 * @param map
	 * @param key
	 * @return
	 */
	public static String getString(Map&lt;?,?&gt; map, Object key, String defaultValue) {
<span class="nc" id="L69">		Object val = map.get(key);</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (val == null) {</span>
<span class="nc" id="L71">			return defaultValue;</span>
		}
<span class="nc bnc" id="L73" title="All 2 branches missed.">		if (val instanceof String) {</span>
<span class="nc" id="L74">			return (String) val;</span>
		}
<span class="nc" id="L76">		throw new ConfigurationException(key + &quot; value must be a string&quot;, getMarkers(map, key));		</span>
	}

	/**
	 * Returns a {@link String} value or throws {@link ConfigurationException} if value is not null and not a string.
	 * @param map
	 * @param key
	 * @return
	 */
	public static int getInt(Map&lt;?,?&gt; map, Object key, int defaultValue) {
<span class="nc" id="L86">		Object val = map.get(key);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if (val == null) {</span>
<span class="nc" id="L88">			return defaultValue;</span>
		}
<span class="nc bnc" id="L90" title="All 2 branches missed.">		if (val instanceof Number) {</span>
<span class="nc" id="L91">			return ((Number) val).intValue();</span>
		}
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (val instanceof String) {</span>
			try {
<span class="nc" id="L95">				return Integer.parseInt((String) val);</span>
<span class="nc" id="L96">			} catch (NumberFormatException e) {</span>
<span class="nc" id="L97">				throw new ConfigurationException(e.getMessage(), e, getMarkers(map, key));						</span>
			}
		}
<span class="nc" id="L100">		throw new ConfigurationException(key + &quot; value must be a string&quot;, getMarkers(map, key));		</span>
	}

	/**
	 * Returns a {@link String} value or throws {@link ConfigurationException} if value is not null and not a string.
	 * @param map
	 * @param key
	 * @return
	 */
	public static boolean getBoolean(Map&lt;?,?&gt; map, Object key, boolean defaultValue) {
<span class="nc" id="L110">		Object val = map.get(key);</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (val == null) {</span>
<span class="nc" id="L112">			return defaultValue;</span>
		}
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (val instanceof Boolean) {</span>
<span class="nc" id="L115">			return (Boolean) val;</span>
		}
<span class="nc" id="L117">		throw new ConfigurationException(key + &quot; value must be a boolean&quot;, getMarkers(map, key));		</span>
	}

	/**
	 * Returns a {@link Collection} value or throws {@link ConfigurationException} if value is not null and not a collection.
	 * @param map
	 * @param key
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;T&gt; Collection&lt;T&gt; getCollection(Map&lt;String,?&gt; map, Object key, Collection&lt;T&gt; defaultValue) {
<span class="nc" id="L128">		Object val = map.get(key);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">		if (val == null) {</span>
<span class="nc" id="L130">			return defaultValue;</span>
		}
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (val instanceof Collection) {</span>
<span class="nc" id="L133">			return (Collection&lt;T&gt;) val;</span>
		}
<span class="nc" id="L135">		throw new ConfigurationException(key + &quot; value must be a collection&quot;, getMarkers(map, key));		</span>
	}

	/**
	 * Returns a {@link Map} value or throws {@link ConfigurationException} if value is not null and not a map.
	 * @param map
	 * @param key
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;K,V&gt; Map&lt;K,V&gt; getMap(Map&lt;?,?&gt; map, Object key, Map&lt;K,V&gt; defaultValue) {
<span class="nc" id="L146">		Object val = map.get(key);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (val == null) {</span>
<span class="nc" id="L148">			return defaultValue;</span>
		}
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if (val instanceof Map) {</span>
<span class="nc" id="L151">			return (Map&lt;K,V&gt;) val;</span>
		}
<span class="nc" id="L153">		throw new ConfigurationException(key + &quot; value must be a map&quot;, getMarkers(map, key));		</span>
	}
		
	/**
	 * A convenience method to check for presence of required configuration keys
	 * @param config Configuration map.
	 * @param supportedKeys Supported keys.
	 * @param marker Map location.
	 * @return config argument
	 */
	public static Map&lt;String,Object&gt; checkRequiredKeys(Map&lt;String,Object&gt; config, String... requiredKeys) throws ConfigurationException {
<span class="nc" id="L164">		return checkRequiredKeys(config, Arrays.asList(requiredKeys));</span>
	}
	
	/**
	 * A convenience method to check for presence of required configuration keys
	 * @param config Configuration map.
	 * @param supportedKeys Supported keys.
	 * @param marker Map location.
	 * @return config argument
	 */
	public static Map&lt;String,Object&gt; checkRequiredKeys(Map&lt;String,Object&gt; config, Collection&lt;String&gt; requiredKeys) throws ConfigurationException {
<span class="nc" id="L175">		StringBuilder missingKeyList = new StringBuilder();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		for (String rk: requiredKeys) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">			if (!config.containsKey(rk)) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">				if (missingKeyList.length() &gt; 0) {</span>
<span class="nc" id="L179">					missingKeyList.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L181">				missingKeyList.append(rk);</span>
			}
<span class="nc" id="L183">		}</span>
		
<span class="nc bnc" id="L185" title="All 2 branches missed.">		if (missingKeyList.length() == 0) {</span>
<span class="nc" id="L186">			return config;</span>
		}
		
<span class="nc bnc" id="L189" title="All 2 branches missed.">		throw new ConfigurationException(&quot;Missing required configuration keys: &quot; + missingKeyList, config instanceof Marked ? ((Marked) config).getMarkers() : null);</span>
	}

	/**
	 * A convenience method to check for presence of unsupported configuration keys
	 * @param config Configuration map.
	 * @param supportedKeys Supported keys.
	 * @param marker Map location.
	 * @return config argument.
	 */
	public static Map&lt;?,?&gt; checkUnsupportedKeys(Map&lt;?,?&gt; config, Collection&lt;?&gt; supportedKeys) throws ConfigurationException {
<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (config == null) {</span>
<span class="nc" id="L201">			return config;</span>
		}
<span class="nc" id="L203">		Collection&lt;?&gt; unsupportedKeys = new ArrayList&lt;Object&gt;(config.keySet());</span>
<span class="nc" id="L204">		unsupportedKeys.removeAll(supportedKeys);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (unsupportedKeys.isEmpty()) {</span>
<span class="nc" id="L206">			return config;</span>
		}		
		
<span class="nc bnc" id="L209" title="All 2 branches missed.">		if (unsupportedKeys.size() == 1) {</span>
<span class="nc" id="L210">			Object unsupportedKey = unsupportedKeys.iterator().next();</span>
<span class="nc" id="L211">			throw new ConfigurationException(&quot;Unsupported configuration key: &quot; + unsupportedKey, getMarkers(config, unsupportedKey));</span>
		}
		
<span class="nc" id="L214">		StringBuilder keyList = new StringBuilder();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">		for (Object uk: unsupportedKeys) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">			if (keyList.length() &gt; 0) {</span>
<span class="nc" id="L217">				keyList.append(&quot;, &quot;);</span>
			}
<span class="nc" id="L219">			keyList.append(uk);</span>
<span class="nc" id="L220">		}</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">		throw new ConfigurationException(&quot;Unsupported configuration keys: &quot; + keyList, config instanceof Marked ? ((Marked) config).getMarkers() : null);</span>
	}

	/**
	 * A convenience method to check for presence of unsupported configuration keys
	 * @param config Configuration map.
	 * @param supportedKeys Supported keys.
	 * @param marker Map location.
	 * @return config argument
	 */
	public static Map&lt;?,?&gt; checkUnsupportedKeys(Map&lt;?,?&gt; config, Object... supportedKeys) throws ConfigurationException {
<span class="nc" id="L232">		return checkUnsupportedKeys(config, Arrays.asList(supportedKeys));</span>
	}

	/**
	 * Gets string configuration value.
	 * @param configMap
	 * @param key
	 * @param required
	 * @return
	 */
	public static String getString(Map&lt;?, ?&gt; configMap, Object key, boolean required, List&lt;? extends Marker&gt; markers) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (configMap.containsKey(key)) {</span>
<span class="nc" id="L244">			Object val = configMap.get(key);</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">			if (val == null &amp;&amp; !required) {</span>
<span class="nc" id="L246">				return null;</span>
			}
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if (val instanceof String) {</span>
<span class="nc" id="L249">				return (String) val;</span>
			} 
			
<span class="nc" id="L252">			throw new ConfigurationException(key + &quot; value must be a string&quot;, getMarkers(configMap, key));</span>
		}
		
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (required) {</span>
<span class="nc" id="L256">			throw new ConfigurationException(key + &quot; is missing&quot;, markers);			</span>
		}
		
<span class="nc" id="L259">		return null;</span>
	}

	/**
	 * Loads values from a key which can be either a string (single value) or a list of strings (multi-value)
	 * @param configMap
	 * @param key
	 * @param consumer
	 */
	public static void loadMultiString(Map&lt;?,?&gt; configMap, Object key, Consumer&lt;String&gt; consumer) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (configMap.containsKey(key)) {</span>
<span class="nc" id="L270">			Object val = configMap.get(key);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">			if (val instanceof String) {</span>
<span class="nc" id="L272">				consumer.accept((String) val);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			} else if (val instanceof Collection) {</span>
<span class="nc" id="L274">				int idx = 0;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">				for (Object ve: (Collection&lt;?&gt;) val) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">					if (ve instanceof String) {</span>
<span class="nc" id="L277">						consumer.accept((String) ve);</span>
					} else {
<span class="nc" id="L279">						throw new ConfigurationException(key + &quot; element must be a string&quot;, getMarkers((Collection&lt;?&gt;) val, idx));							</span>
					}
<span class="nc" id="L281">					++idx;</span>
<span class="nc" id="L282">				}</span>
<span class="nc" id="L283">			} else {</span>
<span class="nc" id="L284">				throw new ConfigurationException(key + &quot; value must be a string or list&quot;, getMarkers(configMap, key));</span>
			}
		}		
<span class="nc" id="L287">	}</span>
	/**
	 * Wraps object into an {@link BinaryEntityContainer} consumer factory. Handles adapters and collections.
	 * @param obj
	 * @return
	 */
	public static ConsumerFactory&lt;BinaryEntityContainer&gt; asConsumerFactory(Object obj)  {
<span class="nc bnc" id="L294" title="All 2 branches missed.">		return asConsumerFactory(obj, obj instanceof Marked ? ((Marked) obj).getMarkers() : null);</span>
	}
	
	/**
	 * Wraps object into an {@link BinaryEntityContainer} consumer factory. Handles adapters and collections.
	 * @param obj
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static &lt;T&gt; ConsumerFactory&lt;T&gt; asConsumerFactory(Object obj, List&lt;? extends Marker&gt; markers) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">		if (obj instanceof Collection) {</span>
<span class="nc" id="L305">			CollectionCompoundConsumerFactory&lt;T&gt; ret = new CollectionCompoundConsumerFactory&lt;&gt;(&quot;Consumer collection&quot;);</span>
<span class="nc" id="L306">			int idx = 0;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			for (Object e: (Collection&lt;?&gt;) obj) {</span>
<span class="nc" id="L308">				ret.add(asConsumerFactory(e, getMarkers((Collection&lt;?&gt;) obj, idx++)));</span>
<span class="nc" id="L309">			}</span>
<span class="nc" id="L310">			return ret;</span>
		}
		
<span class="nc bnc" id="L313" title="All 2 branches missed.">		if (obj instanceof ConsumerFactory) {		</span>
<span class="nc" id="L314">			return (ConsumerFactory&lt;T&gt;) obj;</span>
		}		
		
<span class="nc bnc" id="L317" title="All 2 branches missed.">		if (obj instanceof Adaptable) {</span>
<span class="nc" id="L318">			ConsumerFactory&lt;T&gt; adapter = ((Adaptable) obj).adaptTo(ConsumerFactory.class);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">			if (adapter != null) {</span>
<span class="nc" id="L320">				return adapter;</span>
			}
		}
		
<span class="nc" id="L324">		throw new ConfigurationException(obj.getClass() + &quot; cannot be wrapped/adapted to a consumer factory&quot;, markers);</span>
	}

	/**
	 * Wraps object into a {@link CommandFactory}. Handles adapters and collections.
	 * @param obj
	 * @return
	 */
	public static CommandFactory asCommandFactory(Object obj) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">		return asCommandFactory(obj, obj instanceof Marked ? ((Marked) obj).getMarkers() : null);</span>
	}

	/**
	 * Wraps object into a {@link CommandFactory}. Handles adapters and collections.
	 * @param obj
	 * @return
	 */
	public static CommandFactory asCommandFactory(Object obj, List&lt;? extends Marker&gt; markers) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (obj instanceof Collection) {</span>
<span class="nc" id="L343">			CompoundCommandFactory ret = new CompoundCommandFactory(&quot;Command collection&quot;);</span>
<span class="nc" id="L344">			int idx = 0;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">			for (Object e: (Collection&lt;?&gt;) obj) {</span>
<span class="nc" id="L346">				ret.add(asCommandFactory(e, getMarkers((Collection&lt;?&gt;) obj, idx++)));</span>
<span class="nc" id="L347">			}</span>
<span class="nc" id="L348">			return ret;</span>
		}
		
<span class="nc bnc" id="L351" title="All 2 branches missed.">		if (obj instanceof CommandFactory) {		</span>
<span class="nc" id="L352">			return (CommandFactory) obj;</span>
		}
		
<span class="nc bnc" id="L355" title="All 2 branches missed.">		if (obj instanceof Adaptable) {</span>
<span class="nc" id="L356">			CommandFactory adapter = ((Adaptable) obj).adaptTo(CommandFactory.class);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">			if (adapter != null) {</span>
<span class="nc" id="L358">				return adapter;</span>
			}
		}
				
<span class="nc" id="L362">		throw new ConfigurationException(obj.getClass() + &quot; cannot be wrapped/adapted to a command factory&quot;, markers);</span>
	}
		
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>