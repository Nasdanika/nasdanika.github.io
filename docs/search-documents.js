var searchDocuments = {
    "modules/core/modules/exec/modules/model/content/package-summary.html": {
        "path": "Products/Core/Exec/Model/Content",
        "title": "Content",
        "content": "Content classes are adapted to SupplierFactory<InputStream> to supply content for files, HTTP Call bodies etc. in a form of input streams."
    },
    "modules/togaf/modules/adm/issues/deliverables-and-artifacts-folders/index.html": {
        "path": "Products/TOGAF/ADM/Issues/Deliverables and Artifacts folders",
        "title": "Deliverables and Artifacts folders",
        "content": "Section 32 Deliverables under deliverables. Artifacts as it goes or look throug the TOC. Origin adm/engineering.yml 11:5 Uri engineering://nasdanika/modules/togaf/modules/adm/issues/deliverables-and-artifacts-folders Target ADM Workable"
    },
    "modules/core/modules/flow/features.html": {
        "path": "Products/Core/Flow/Features",
        "title": "Features",
        "content": "Visualizations Inheritance Responsibility Assignments (RACI) Data Provenance Validation"
    },
    "modules/engineering/modules/gen/issues/in-browser-editing/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/In-browsing editing feature",
        "title": "In-browsing editing feature",
        "content": "Collaboration, inner source. Create pull request. Related to Data Provenance. Origin gen/engineering.yml 27:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/in-browser-editing Target Generation Adapters Workable"
    },
    "modules/html/modules/ecore/issues/javadoc/index.html": {
        "path": "Products/HTML/Ecore/Issues/Javadoc link to instance class.",
        "title": "Javadoc link to instance class.",
        "content": "Origin ecore/engineering.yml 31:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/javadoc Target Ecore Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Size.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Size",
        "title": "Size",
        "content": "org.nasdanika.html.bootstrap.Size Uses Spacing"
    },
    "modules/engineering/releases.html": {
        "path": "Products/Engineering/Releases",
        "title": "Releases",
        "content": "2021.12.4"
    },
    "principles/spa/index.html": {
        "path": "Principles/Single-page Applications",
        "title": "Single-page Applications",
        "content": "Implement dynamic behavior using Single Page Applications built with Vue and BootstrapVue, add them to static sites generated from models. Generate application input data from source models. Create backing services as needed. Origin engineering/nasdanika.yml 65:5 Uri engineering://nasdanika/principles/spa"
    },
    "modules/html/modules/models/modules/html/modules/model/issues/fluent-api/index.html": {
        "path": "Products/HTML/Models/HTML/Model/Issues/Fluent API",
        "title": "Fluent API",
        "content": "attribute() to add attribute, class(), style(), content(Object) - convert to text if not EObject and add. The goal it to make the model API easier to work with. Review HTMLElement methods and BootstrapElement methods. Implement in the model. Origin model/html/engineering.yml 9:5 Uri engineering://nasdanika/modules/html/modules/models/modules/html/modules/model/issues/fluent-api Target Model Workable"
    },
    "increments/2022/children/Q2/children/jun/index.html": {
        "path": "Increments/2022/Q2/June",
        "title": "June",
        "content": "Origin engineering/nasdanika.yml 124:13 Uri engineering://nasdanika/increments/2022/children/Q2/children/jun Start Jun 1, 2022 End Jul 1, 2022 Duration 30 days"
    },
    "modules/engineering/releases/2021-12-4/index.html": {
        "path": "Products/Engineering/Releases/2021.12.4",
        "title": "2021.12.4",
        "content": "Origin engineering.yml 5:6 Uri engineering://nasdanika/modules/engineering/releases/2021-12-4"
    },
    "modules/html/index.html": {
        "path": "Products/HTML",
        "title": "HTML",
        "content": "Origin engineering.yml 1:1 Uri engineering://nasdanika/modules/html"
    },
    "modules/html/modules/bootstrap/issues/upgrade-to-bootstrap-5/index.html": {
        "path": "Products/HTML/Bootstrap/Issues/Updgrade to Bootstrap 5",
        "title": "Updgrade to Bootstrap 5",
        "content": "https://getbootstrap.com/docs/5.0/migration/ Origin bootstrap/engineering.yml 8:5 Uri engineering://nasdanika/modules/html/modules/bootstrap/issues/upgrade-to-bootstrap-5 Total cost 40.0 Effort 40.0 Remaining effort 40.0 Target Bootstrap Workable"
    },
    "modules/html/modules/emf/issues/temporal-rendering/index.html": {
        "path": "Products/HTML/EMF/Issues/Temporal rendering",
        "title": "Temporal rendering",
        "content": "Implement for relative temporals, generate start/end actions for period subclasses if start/end temporals have offset, base, bounds, or derivatives. Also info icon in render value navigating to the respective actions. Origin emf/engineering.yml 12:5 Uri engineering://nasdanika/modules/html/modules/emf/issues/temporal-rendering Target EMF Workable"
    },
    "modules/togaf/modules/adm/issues/migrate-to-maven-plugin/index.html": {
        "path": "Products/TOGAF/ADM/Issues/Migrate to Maven plug-in",
        "title": "Migrate to Maven plug-in",
        "content": "Migrate generation from tests to Maven plug-in once available. Origin adm/engineering.yml 8:5 Uri engineering://nasdanika/modules/togaf/modules/adm/issues/migrate-to-maven-plugin Target ADM Workable"
    },
    "modules/core/modules/flow/issues/pseudo-state-links/index.html": {
        "path": "Products/Core/Flow/Issues/Pseudo-state links",
        "title": "Pseudo-state links",
        "content": "Add links to pseudo-states - supported by Drawio. If linked then shall have an action - need a flag to indicate that it is a real state. Maybe a way to have real states rendered as pseudo-states. Origin flow/engineering/engineering.yml 76:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/pseudo-state-links Target Flow Workable"
    },
    "modules/engineering/index.html": {
        "path": "Products/Engineering",
        "title": "Engineering",
        "content": "Origin engineering.yml 1:1 Uri engineering://nasdanika/modules/engineering"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Accordion.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Accordion",
        "title": "Accordion",
        "content": "org.nasdanika.html.model.bootstrap.Accordion"
    },
    "modules/togaf/modules/adm/index.html": {
        "path": "Products/TOGAF/ADM",
        "title": "ADM",
        "content": "Origin adm/engineering.yml 1:1 Uri engineering://nasdanika/modules/togaf/modules/adm"
    },
    "modules/core/modules/ncore/BooleanProperty.html": {
        "path": "Products/Core/Ncore/BooleanProperty",
        "title": "BooleanProperty",
        "content": "org.nasdanika.ncore.BooleanProperty Supertypes Property Boolean"
    },
    "modules/engineering/modules/gen/issues/marker-relative-drawio-representation/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Marker-relative drawio representations",
        "title": "Marker-relative drawio representations",
        "content": "Currently is resolved relative to the instance model. If URL starts with ./ resolve relative to the marker. Or interpolate with ${marker-location} token. Origin gen/engineering.yml 62:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/marker-relative-drawio-representation Target Generation Adapters Workable"
    },
    "modules/core/modules/cli/index.html": {
        "path": "Products/Core/CLI",
        "title": "CLI",
        "content": "Origin cli/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/cli Dependencies Common Dependants EMF"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/ButtonToolbar.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/ButtonToolbar",
        "title": "ButtonToolbar",
        "content": "org.nasdanika.html.model.bootstrap.ButtonToolbar"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Color.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Color",
        "title": "Color",
        "content": "org.nasdanika.html.bootstrap.Color Uses Alert Appearance Badge Border Button Item NavigationBar TableCell TableRow Text"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/FormGroup.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/FormGroup",
        "title": "FormGroup",
        "content": "org.nasdanika.html.model.bootstrap.FormGroup"
    },
    "modules/core/modules/diagram/modules/model/index.html": {
        "path": "Products/Core/Diagram/Model",
        "title": "Model",
        "content": "Abstraction level for help with generating diagrams for multiple targets with PlantUML being the primary target. Origin diagram/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/diagram/modules/model Dependencies Ncore Dependants Generators Flow"
    },
    "modules/html/modules/ecore/issues/ekeys/index.html": {
        "path": "Products/HTML/Ecore/Issues/EKeys as qualifiers - similar to EMaps. Report in documentation.",
        "title": "EKeys as qualifiers - similar to EMaps. Report in documentation.",
        "content": "Origin ecore/engineering.yml 25:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/ekeys Target Ecore Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Collapse.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Collapse",
        "title": "Collapse",
        "content": "org.nasdanika.html.model.bootstrap.Collapse"
    },
    "modules/engineering/modules/model/issues/event-to-ncore/index.html": {
        "path": "Products/Engineering/Model/Issues/Move Event to Ncore",
        "title": "Move Event to Ncore",
        "content": "Origin model/engineering.yml 9:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/event-to-ncore Target Model Workable"
    },
    "issue-severities/medium/index.html": {
        "path": "Issue/Severities/Medium",
        "title": "Medium",
        "content": "Origin engineering/nasdanika.yml 47:5 Uri engineering://nasdanika/issue-severities/medium"
    },
    "modules/html/modules/models/modules/app/modules/gen/issues/content-modes/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters/Issues/Content modes",
        "title": "Content modes",
        "content": "Add configuration to select content row modes - cols (the current implementation), cols-nowrap (add flex-nowrap class to the row), table. At the action level. For the principal action works on the content row, for other actions works in a similar way with left and right content panels. Origin model/app.gen/engineering.yml 28:6 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen/issues/content-modes Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generation Adapters Workable"
    },
    "modules/html/modules/emf/index.html": {
        "path": "Products/HTML/EMF",
        "title": "EMF",
        "content": "Origin emf/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/emf Dependencies HTML EMF Dependants Ecore Flow"
    },
    "issue-severities/critical/index.html": {
        "path": "Issue/Severities/Critical",
        "title": "Critical",
        "content": "Origin engineering/nasdanika.yml 43:5 Uri engineering://nasdanika/issue-severities/critical"
    },
    "modules/html/modules/models/issues/bootstrap-vue/index.html": {
        "path": "Products/HTML/Models/Issues/BootstrapVue model and generation adapters",
        "title": "BootstrapVue model and generation adapters",
        "content": "Extends Bootstrap element for styling, appearance. Also extends Vue inteface for directives Create issues for components, implement table first for issues Origin model/engineering.yml 26:5 Uri engineering://nasdanika/modules/html/modules/models/issues/bootstrap-vue Target Models Workable"
    },
    "modules/core/modules/diagram/modules/model/Start.html": {
        "path": "Products/Core/Diagram/Model/Start",
        "title": "Start",
        "content": "org.nasdanika.diagram.Start Start pseudo-state. Supertypes DiagramElement"
    },
    "objectives/test-objective/key-results/do-something/index.html": {
        "path": "Objectives/Test Objective/Key Results/Do something",
        "title": "Do something",
        "content": "Origin engineering/nasdanika.yml 19:9 Uri engineering://nasdanika/objectives/test-objective/key-results/do-something"
    },
    "increments/2022/children/Q3/children/sep/index.html": {
        "path": "Increments/2022/Q3/September",
        "title": "September",
        "content": "Origin engineering/nasdanika.yml 141:13 Uri engineering://nasdanika/increments/2022/children/Q3/children/sep Start Sep 1, 2022 End Oct 1, 2022 Duration 30 days"
    },
    "modules/core/modules/ncore/Duration.html": {
        "path": "Products/Core/Ncore/Duration",
        "title": "Duration",
        "content": "java.time.Duration Duration is an amount of time in the ISO-8601 Duration format. Supports days and smaller units. Weeks, months and years are not supported. Example: P28DT10H. Uses Period Temporal"
    },
    "modules/html/modules/ecore/index.html": {
        "path": "Products/HTML/Ecore",
        "title": "Ecore",
        "content": "Origin ecore/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/ecore Dependencies EMF With ecore module you can generate documentation for Ecore models. To use add ecore dependency to pom.xml, e.g. <dependency>\n  <groupId>org.nasdanika.html<\/groupId>\n  <artifactId>ecore<\/artifactId>\n  <version>2022.1.1<\/version>\n<\/dependency>\n Then write generation logic following the below examples: TestNasdanikaDocEngineeringGen.java - generator of this web site. TestEcoreDoc.java - a test generating documentation for a few models. Generation steps Generate action model If you are generating documentation for cross-referencing models, you may need to copy the models so their physical relative location on disk matches their relative logical location in Eclipse (project name). For example, Ncore physical location relative to the Git root directory is core/ncore, but its logical (project) name in Eclipse is org.nasdanika.ncore. Therefore, in order for the flow model to reference Ncore classes the Ncore model is copied from core/ncore to org.nasdanika.ncore in a Maven target directory. The flow model is copied in a similar way. Generate resource model Once you have generated action models, mount them to a root action model (defined in actions.yml in the examples above) and generate a resource model using a page template - defined in page-template.yml in the examples. Examples Root action model app-action:\n  icon: https://docs.nasdanika.org/images/nasdanika-logo.png\n  uri: nasdanika:test/action/s1/s2\n  text: Nasdanika\n  location: https://www.nasdanika.org \n  tooltip: Root action\n  children:\n    - app-action:\n        icon: fa fa-book\n        text: Documentation\n        id: doc\n        location: ${base-uri}index.html \n        tooltip: Documentation\n        content:\n          content-text: TODO  \n        children:\n          - app-action-reference: \"../../../../../../../target/model-doc/actions/ncore.genmodel.xml#/\"\n          - app-action-reference: \"../../../../../../../target/model-doc/actions/exec.genmodel.xml#/\"\n          - app-action-reference: \"../../../../../../../target/model-doc/actions/flow.genmodel.xml#/\"\n Page template bootstrap-page:\n  cdn: true\n  theme: Cerulean\n  name: Application Page Template\n  language: EN\n  stylesheets: \n    - https://cdn.jsdelivr.net/gh/Nasdanika/html@master/model/app.gen/web-resources/css/app.css \n    - https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css\n    - https://cdn.jsdelivr.net/npm/jstree@3.3.11/dist/themes/default/style.min.css\n    - https://cdn.jsdelivr.net/npm/github-markdown-css@5.1.0/github-markdown.min.css\n    - https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/default.min.css\n    - https://cdn.jsdelivr.net/npm/bootstrap-vue@2.21.2/dist/bootstrap-vue.css\n  scripts:\n    - https://cdn.jsdelivr.net/gh/Nasdanika/html@master/model/app.gen/web-resources/js/common.js \n    - https://cdn.jsdelivr.net/gh/Nasdanika/html@master/model/app.gen/web-resources/js/dark-head.js \n    - https://cdn.jsdelivr.net/npm/jstree@3.3.11/dist/jstree.min.js\n    - https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js\n    - https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js\n    - https://cdn.jsdelivr.net/npm/bootstrap-vue@2.21.2/dist/bootstrap-vue.min.js\n    - https://cdn.jsdelivr.net/gh/Nasdanika/html@master/model/app.gen/web-resources/js/components/table.js\n  body:\n    app-page:\n      fluid: true\n      navigation-panel:\n        style: COLLAPSIBLE_CARDS\n        collapsible: true\n Examples Ncore Diagram Flow Exec HTML Bootstrap Application Engineering"
    },
    "modules/core/modules/exec/modules/gen/issues/embedded-image-data/index.html": {
        "path": "Products/Core/Exec/Generation Adapters/Issues/Embedded image data",
        "title": "Embedded image data",
        "content": "Add embedded image data interpolation for markdown. Origin exec.gen/engineering.yml 8:5 Uri engineering://nasdanika/modules/core/modules/exec/modules/gen/issues/embedded-image-data Target Generation Adapters Workable"
    },
    "modules/html/modules/models/modules/html/index.html": {
        "path": "Products/HTML/Models/HTML",
        "title": "HTML",
        "content": "Origin model/engineering.yml 5:5 Uri engineering://nasdanika/modules/html/modules/models/modules/html"
    },
    "modules/core/modules/flow/issues/children-only-representation/index.html": {
        "path": "Products/Core/Flow/Issues/Children only representation",
        "title": "Children only representation",
        "content": "A flag to diagram or a property to indicate that the element itself shall not appear on the diagram, only children. May use something like context = -1. Origin flow/engineering/engineering.yml 61:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/children-only-representation Target Flow Workable"
    },
    "modules/core/modules/flow/features/data-provenance/index.html": {
        "path": "Products/Core/Flow/Features/Data Provenance",
        "title": "Data Provenance",
        "content": "Origin flow/engineering/engineering.yml 36:5 Uri engineering://nasdanika/modules/core/modules/flow/features/data-provenance Tracing definitions to Git files, lines, and commits."
    },
    "issue-categories.html": {
        "path": "Issue/Categories",
        "title": "Categories",
        "content": "Development Good First Issue"
    },
    "modules/html/modules/ecore/issues/emaps/index.html": {
        "path": "Products/HTML/Ecore/Issues/Display EMaps directly to the value class with a different relationship, e.g. ``#--``",
        "title": "Display EMaps directly to the value class with a different relationship, e.g. ``#--``",
        "content": "Origin ecore/engineering.yml 23:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/emaps Target Ecore Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/issues/fluent-api/index.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Issues/Fluent API",
        "title": "Fluent API",
        "content": "Fluent API. e.g. appearance().margin().top(1) - creates apperance and margin on access. Model after the Bootstrap API Origin model/bootstrap/engineering.yml 9:5 Uri engineering://nasdanika/modules/html/modules/models/modules/bootstrap/modules/model/issues/fluent-api Target Model Workable"
    },
    "modules/engineering/modules/model/index.html": {
        "path": "Products/Engineering/Model",
        "title": "Model",
        "content": "One of definitions of engineering is \u201cThe action of working artfully to bring something about.\u201d Bringing something of value about is usually quite a lot of effort. In a situation of limited resources, which is the case most of the time, that efforts need to be carefully organized to achieve the maximum bang for the buck. The goal of Nasdanika Engineering is to help to carefully organize efforts in order to bring something about. That \u201cabout\u201d may be a software product, an organization, a vacation, or life in general. Nasdanika Engineering provides science and tooling to guide and track the process of translating dreams and ideas into organizing thought, sharing that organized thought with others and aligning efforts of many to turn dreams and ideas into reality. Nasdanika Engineering takes a low-tech approach - all you need to use it is a text editor to author YAML and Markdown files. Shall YAML and Markdown sound scary for non-technical people, YAML is a glorified indented list - if you know how to create a PowerPoint slide with bullet points, you should be able to manage YAML. And Markdown is pretty close to plain text. YAML and Markdown are resource formats supported out-of-the box. If needed, model data can be loaded from other resources. E.g. issues can be loaded from issue trackers such as GitHub Issues, Jira, or MantisBT by implementing resource factories for respective systems. Then you\u2019d need Java 8+ and Maven to generate a static HTML site from those files. Optionally, you can publish your site - there are many options, e.g. GitHub Pages. You wouldn\u2019t need a database or a cloud application - you can keep your plans on an encrypted flash drive in a safe in an underground vault, shall they be super-secret. Because with Nasdanika Engineering all artifacts \u201clive\u201d in one place it makes it an attractive choice for small efforts, or efforts which may have long periods of dormancy - POC\u2019s, R&D, ideation, innovation, and conceptualization. In the case of innovation in an organization, innovators may benefit from shared models, e.g. an organization model with products, services, personas, and goals - in this case an innovation idea can be defined in terms/context of these products, services, and goals. E.g. \u201cBuild a new service X which would leverage an existing service A and product B to address goal C of the internal persona D\u201d. This disciplined innovation would help the innovators to align their innovations to organization goals, and the rest of organization to grasp the value of the ideas and prioritize them for implementation. In a team environment Nasdanika Engineering files can be kept in a source control system such as Git. For example, on GitHub. In this case site generation and publishing can be done on code push, e.g. with CircleCI or Jenkins. In case of using Nasdanika Engineering to engineer a software product, engineering files with the source code. In a multi-module, multi-product scenario engineering files for each product/module can be kept with the source code of that product/module and then be federated into one model to generate a team/organization site. Nasdanika documentation site is generated this way. Nasdanika Engineering has 46 classes - see below and in the navigation panel on the left, which can be roughly grouped into the following categories: Structure - a skeleton to support the work done by the muscles. Behavior - muscles which do the work. Strategy - brain which directs the work towards goal achievement. General purpose - connective tissue assisting the above categories. It is not necessary to know and use all the classes at once - pick what you need to get started and then expand as needed. The below sections provide overview of the core concepts, each of the categories, and explain how to get started with Nasdanika Engineering. For step-by-step instructions see the User Guide. Core concepts Getting started The easiest way to get started is to download or clone the Engineering Demo repository. You may download the latest version or any of releases. If you clone, you may checkout any of tags as a starting point. Defining the model With Nasdanika Engineering you create an engineering model by defining instances of model classes in YAML or other format, e.g. JSON. YAML is a preferred format because it is more user friendly and also because Nasdanika Engineerings keeps track of line numbers in YAML files, but this functionality is not currently supported for JSON. As has been mentioned above, a model can be loaded from different types of resources, e.g. some parts of the model can be loaded from YAML while other parts would be loaded from, say, Jira. When creating YAML specifications use \u201cLoad specification\u201d section of respective classes to find supported configuration keys. Below is a partial sample definition of an organization: engineering-organization:\n   name: Nasdanika Engineering Demo\n   path: demo \n   table-of-contents: \n     role: content-left\n     header: Contents\n You can find a full definition here. Note that the organization definition starts with engineering-organization where engineering is a package name and organization is class name. For references which are not homogenous it is required to provide class names. Homogenous references have elements of the same type and therefore there is no need to provide class names. table-of-contents above is an example of a homogenous reference. A YAML file can reference another YAML file by using a string as reference value, unless that reference is a strict-containment. In the latter case the value is treated as a value of the default feature, as in the case of Transition:   elements:\n    - engineering-activity:\n        name: A\n        path: a\n        outputs:\n          - b\n outputs is a journey element homogenous reference with strict containment and target is Transition\u2019s default feature. Therefore, b is treated as a value of target. Default features are shown in bold in load specifications. The below code snippet demonstrates referencing specification defined in other files/URL\u2019s:    resources:\n     - resources/user-guide/root.yml\n     - resources/base-journey/root.yml\n     - resources/extended-journey/root.yml\n resources reference is not strict-containment and therefore its value is treated as a URL, which is resolved relatively to the YAML resource URL. Please note that when referencing external resources homogenous is ignored, i.e. the resource must contain the type declaration. Generating a site You may generate a site by using Maven - mvn package or mvn clean package. If you work on a model in a Java IDE such as Eclipse you may run TestModel.testGenerateDemoSite() from the IDE. The generation process creates a lot of console output, you may redirect it to a file if desired. The generation process diagnoses the model and outputs warnings and errors, if there are any, at the end of console output. Warnings and errors are also displayed on the generated site. Diagnostic output to the console is very detailed and may be hard to read. It is easier to use the generated site to inspect the diagnostic, unless there was FAIL level diagnostic which caused generation to fail. Generation may also fail due to incorrect configuration - wrong configuration key or resource URL. Inspect error messages for details. Below is a sample error message - it tells what is wrong (Unsupported configuration key) and the location of the offending specification (demo.yml line 3 column 4): Tests in error:\n  testGenerateDemoSite(org.nasdanika.engineering.demo.TestModel): Unsupported configuration key: path_ at file:/.../engineering-demo/target/test-classes/demo.yml 3:4\n Structure This section provides an overview of models classes which can be categorized as structural - instances of these classes define a skeleton to which other instances are \u201cattached\u201d. First of all, ModelElement and NamedElement are base classes from which most of the other classes inherit. Although is some cases not necessary, it is recommended to specify path attribute for model elements in order to have semantic URI\u2019s and URL\u2019s. A number of classes inherit from Period which supports floating, absolute, or relative start and end dates - temporals, and duration. It allows to express plans in relative temporal terms, e.g. \u201cHire a tester 60 day after the project kick-off\u201d where \u201cProject kick-off\u201d is an event which can be initially \u201cunbound\u201d, i.e. specified without absolute or relative date. Later on an event can be \u201cbound\u201d to an \u201cinstant\u201d - absolute time, or to another temporal - an event or start/end of a period, e.g. 30 days before quarter end. Temporals may have lower and upper bounds. For example, an exact date for some event may be unknown, but it might be know that it would happen no later or no sooner than a certain point of time - absolute or relative - or within a certain time range. Engineer or Organization are typically roots of the model. For a single-person efforts with no delegation whatsoever you may define a model with an engineer as its root. However, in many cases even for efforts which start as one-man shop eventually comes time when some tasks need to be delegated and execution tracked. This is when you\u2019d need an organization as it is an engineer which can contain other engineers. Engineers may contain modules and products and own engineered elements. Note that an Engineer is a sub-class of EngineeredElement, i.e. an Engineer can be engineered. For example, a person can be mentored or take courses and an organization can improve its processes. Behavior Behavior classes are used to represent things to be done on the structure or external entities to achieve goals. They are subdivided into two sub-categories: What - specifies what needs to be done, e.g. \u201cCreate a Customer Profile microservice\u201d. It may specify how it needs to be done or may reference the existing How, e.g. \u201cCreate a new microservice\u201d journey. How - specifies how a particular task shall be carried out. What There are two base classes for the classes in this category: Endeavor EngineeredCapability, which extends Endeavor. In your models you would use subclasses of the above two classes: Issue and its subclass Decision. With issue you would use: Note to track progress IssueCategory IssuePriority IssueSeverity IssueStatus Feature Release Increment How The How means what is traditionally User Guides and Cookbooks - step-by-step instructions. With Nasdanika Engineering you can create such step-by-step guides as documents with multiple sections. However, there is another way and you may choose what is most appropriate in a given situation and even combine the two. Humans are image processors, not text processors. So if your instructions are not single level linear, i.e. there are steps and sub-steps and also conditional logic, chances are that if presented visually these instructions would be easier to follow. Nasdanika Engineering has a number of classes which can be used to create visual representations of (work)flows. Because they can be used to capture scenarios of how personas use products and services provided by an engineer or an organization, they are called journeys. A journey is a directed graph of journey elements - activities, nested journeys, services, and pseudo-states. Journey elements can transition control from one another and also call one another. Because journey elements inherit from ModelElement, they can have documentation sections to benefit from a combination of non-linear and linear knowledge representation. One important feature of journeys is journey inheritance, which is similar to inheritance in languages like Java - it is possible to define a base journey and then extend it and customize (override) journey elements. Journey inheritance can be useful in hierarchies such as organization hierarchies and technology hierarchies. In an organization hierarchy higher levels can define generic processes and specify which elements can be customized at lower levels and which cannot. Lower levels of the organization would customize what they need to their specifics, e.g. local regulations. Similar to that, in the world of technology one can define, say, a generic journey explaining how to develop and deploy a microservice. Then that journey can be customized to different ways to deploy, e.g. different cloud providers - private and public, and their offerings. Document and section inheritance is not currently supported, it will be added in the future releases. Strategy Anything worthwhile takes time and effort to build, \u2026 and there are so many ways to skin a cat. If you are working on that worthwhile alone you will need a way to ensure that you are staying focused on achieving your goals. If you are working with others, you\u2019ll need a way to provide to your team means for efficient decision making to avoid prolonged debates. With Nasdanika Engineering you do it with subclasses of Aim to which alignables such as endeavors and other aims can be aligned to. For example, issues can be aligned to, say, persona goals to ensure that your org is doing the right thing, and to principles to ensure that you are doing it right. An issue \u201cBuild Customer Profile microservice\u201d can be aligned to a customer persona goal \u201cManage my information\u201d and The Twelve Factor App principles. Nasdanika Engineering also supports the OKR goal setting framework via Objective and KeyResult classes. It is possible to define issues as initiatives under key results. This provides an alternative way to organize efforts - instead of defining issues under products and modules and then aligning them to aims. You may pick a method which works best for your situation or use a combination of these two approaches. In the case of defining issues as initiatives you may have something like this: Organization Mission - top level goal. Organization goals - multiple. Increments - quarters, years. Organization objectives aligned to goals Key results Engineers and sub-organizations Objectives for increments linked to organization key results Key results Initiatives with sub-issues hierarchy. General purpose Appearance and its subclasses can be used to declaratively customize the generated UI. Customization can be done at the class level, i.e. customizations would apply to all, say, issues, or at an individual model element level. Directory is a way to group resources such as documents, links, named element references, and any named elements in general. Model elements and documents which use sections can use tables of contents. Engineered elements can have discussion topics with messages and nested forums. For example, there might be a discussion forum for a document section or for a journey activity. This allows to have highly focused micro-communities of practice where engineered element owners and experts help others. For software development efforts models \u201clive\u201d with the code and follow its lifecycle - branching, commits, merges. As some of engineering model elements are executable, e.g. already mentioned Vinci actions, the models are code by definition as they contain instructions to be executed by a computer. Unlike text files or spreadsheets which can also \u201clive\u201d with the code, models provide more structure and functionality for the engineering domain. \u201cAs-code\u201d approach may be attractive in the following situations: Sensitive data - with as-code approach such data may be kept in a highly secure fashion and never cross the network. Reduced infrastructure requirements - there is no need for an issue tracking server. Origin model/engineering.yml 1:1 Uri engineering://nasdanika/modules/engineering/modules/model Dependencies Flow Model Dependants Generation Adapters"
    },
    "modules/html/modules/models/modules/app/modules/gen/issues/table-component/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters/Issues/Table component improvements",
        "title": "Table component improvements",
        "content": "Filterable flag to fields, also store, filterable column in the configuration table. Sortable flag to fields, also store, sortable column in the configuration table. Search using visible text, not HTML markup - an extra field, see if there are table facilities, use own filter function otherwise. Jsoup to produce text from markup during generation. Table configuration (style) - pagination, border, ... - two tabs in the dialog - Columns and Style. Primary key prop. Origin model/app.gen/engineering.yml 14:6 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen/issues/table-component Total cost 8.0 Effort 8.0 Remaining effort 8.0 Target Generation Adapters Workable"
    },
    "modules/core/modules/flow/InputPin.html": {
        "path": "Products/Core/Flow/InputPin",
        "title": "InputPin",
        "content": "org.nasdanika.flow.InputPin Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\input-pin.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/html/modules/models/modules/app/modules/model/Footer.html": {
        "path": "Products/HTML/Models/Application/Model/Footer",
        "title": "Footer",
        "content": "org.nasdanika.html.model.app.Footer Footer is displayed below the navigation and content panels. Supertypes PagePart Referrers Page"
    },
    "modules/engineering/issues/diagramming/index.html": {
        "path": "Products/Engineering/Issues/Diagramming",
        "title": "Diagramming",
        "content": "Diagramming model - PlantUML is the first generation target. mxGraph is the next - option to specify layout and merge updates with manually laid out diagrams - match by ID (URI digest), update only the semantic part if found. Delete if no match, some primitive layout for new - below all or similar to text wrapping - grow proportionally. First, validate compatibility of mxGraph-produced output with draw.io - mxGraph is end of life, but it is ostensibly used by draw.io If no compatibility - a primitive XML-based output - don't need much functionality. Longer-term potentially - diagram editing plug-in for Eclipse. Two levels of draw.io support: a) Token expansion on hand-crafted diagrams - decompress, expand tokens, re-compress and embed - handle at the core. b) Generation of (initial) diagrams and merging of changes - handle at its own product, try to leverage mxGraph. Support of Mermaid output. Origin engineering.yml 11:6 Uri engineering://nasdanika/modules/engineering/issues/diagramming Target Engineering Workable"
    },
    "modules/core/modules/emf/issues/map-markers/index.html": {
        "path": "Products/Core/EMF/Issues/Carry-over markers from Map entries to List elements",
        "title": "Carry-over markers from Map entries to List elements",
        "content": "ReferenceList - 81, 93. Origin emf/engineering.yml 9:7 Uri engineering://nasdanika/modules/core/modules/emf/issues/map-markers Target EMF Workable"
    },
    "modules/engineering/modules/gen/issues/issues-table/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/issuesTable() methods",
        "title": "issuesTable() methods",
        "content": "Generate items for all available features or at least the most of them. Take arguments for feature/column visibility, sortability, and filterability. Support of keying by model element and by string for computed features. Origin gen/engineering.yml 53:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/issues-table Target Generation Adapters Workable"
    },
    "modules/engineering/modules/model/issues/reporter/index.html": {
        "path": "Products/Engineering/Model/Issues/Reporter",
        "title": "Reporter",
        "content": "Add reported Engineer reference to Issue. Opposite reference reportedIssues - nav action similar to All Issues. Origin model/engineering.yml 27:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/reporter Target Model Workable"
    },
    "modules/html/modules/ecore/issues/association-classes/index.html": {
        "path": "Products/HTML/Ecore/Issues/Consider support of association classes using annotations. E.g. an annotation on the association class with target reference name. Say ``association-class-reference`` key with reference name.",
        "title": "Consider support of association classes using annotations. E.g. an annotation on the association class with target reference name. Say ``association-class-reference`` key with reference name.",
        "content": "Origin ecore/engineering.yml 27:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/association-classes Target Ecore Workable"
    },
    "modules/core/modules/exec/modules/gen/issues/maven-classloader/index.html": {
        "path": "Products/Core/Exec/Generation Adapters/Issues/Maven classloader",
        "title": "Maven classloader",
        "content": "For the call. Might be heavy, but powerful, it is not that much about the speed but about the result. https://stackoverflow.com/questions/35598239/load-maven-artifact-via-classloader. Origin exec.gen/engineering.yml 14:5 Uri engineering://nasdanika/modules/core/modules/exec/modules/gen/issues/maven-classloader Target Generation Adapters Workable"
    },
    "modules/engineering/modules/model/issues/past-due-validations/index.html": {
        "path": "Products/Engineering/Model/Issues/Past Due Validations",
        "title": "Past Due Validations",
        "content": "Use context Date service. Also a warning if getting close and no progress - linear approximation. For endeavors with intervals wihtout start or end - derive start/end from interval start/end Origin model/engineering.yml 14:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/past-due-validations Target Model Workable"
    },
    "modules/engineering/modules/model/NamedElement.html": {
        "path": "Products/Engineering/Model/NamedElement",
        "title": "NamedElement",
        "content": "org.nasdanika.engineering.NamedElement Named element, as the name suggests, is a base class for model elements with a name. Supertypes ModelElement NamedElement Subtypes Aim Capability Event Forum Increment IssuePriority IssueSeverity IssueStatus Link Message NamedElementReference Referrers Directory ModelElement NamedElementReference"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/TableSection.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/TableSection",
        "title": "TableSection",
        "content": "org.nasdanika.html.model.bootstrap.TableSection Table section - body or footer, header has its own class. Supertypes TableRowContainer Subtypes TableHeader Referrers Table"
    },
    "modules/html/modules/models/modules/html/modules/model/Script.html": {
        "path": "Products/HTML/Models/HTML/Model/Script",
        "title": "Script",
        "content": "org.nasdanika.html.model.html.Script Script with code stored in the model element source reference. Supertypes Filter"
    },
    "modules/core/modules/flow/Choice.html": {
        "path": "Products/Core/Flow/Choice",
        "title": "Choice",
        "content": "org.nasdanika.flow.Choice Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\choice.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/js-tree-context-items/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/JsTree context items",
        "title": "JsTree context items",
        "content": "Label context list of labels. If present use JsTree context menu in the tree and on the page - find how it is done in the old server code on GitHub. In the content panel as well. Origin model/app/engineering.yml 16:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/js-tree-context-items Target Model Workable"
    },
    "increments/2021/children/Q4/index.html": {
        "path": "Increments/2021/Q4",
        "title": "Q4",
        "content": "Origin engineering/nasdanika.yml 74:9 Uri engineering://nasdanika/increments/2021/children/Q4 Start Oct 1, 2021 End Jan 1, 2022 Duration 92 days 1 hour"
    },
    "modules/core/modules/ncore/Instant.html": {
        "path": "Products/Core/Ncore/Instant",
        "title": "Instant",
        "content": "java.time.Instant Instant is a single instantaneous point on the time-line. If instant specification contains Z, then it is parsed using Instant.parse() method. Otherwise the specification is used to construct java.util.Date which is then converted to instant. Examples: 2021-12-03T10:15:30.00Z - loaded using Instant.parse() 10/1/2021 - loaded using new Date() and then converted to instant. Uses Temporal"
    },
    "index.html": {
        "title": "Documentation",
        "content": "Origin engineering/nasdanika.yml 1:1 Uri engineering://nasdanika This page provides an overview of Nasdanika products. The primary target audience of the Nasdanika product line are Java developers who use Maven. The main theme can be expressed as \u201cEfficient knowledge capture and dissemination\u201d using Domain-Driven Design, Model-based Systems Engineering (MBSE) and code generation being the means to efficiently codify knowledge and then disseminate it. Well, it\u2019s a mouthful! Let\u2019s elaborate a bit! First of all, \u201cefficiency\u201d above means minimal requirements of human and computing resources per \u201cunit of knowledge\u201d. It also means hyper-local and hyper-focused experiences because humans are notoriously bad at context switching. One of approaches to minimize context switching is use of code generation using Java, e.g. generation of Bootstrap Web applications using fluent Java API. Another one is an option to author models in YAML without having to use a specialized model editor. Computing resources-wise - no need in server components, you can use Nasdanika products on a flash drive in a bunker or in the wilderness with no network: --everything-is-hyper-local, paraphrasing the Git motto. Access to the Internet would be needed only to pull the required libraries from Maven Central or a mirror. Sample scenario Models Engineering Flow Domain Meta-Model creation Meta-Model documentation Production of Meta-Model binaries Model editing Consumption of Meta-Model binaries Consumption of model content Use of the models Populate the model YAML or JSON Tree editor Diagram editor Specialized text editor Custom resources and factories Web application Programmatic Products overview Sample scenario You\u2019ve got an idea of a new \u201csomething\u201d - not necessarily software. Depending on the problem at hand, how your brain is wired, and who you need to communicate your idea to, you may start with а domain model, flow model, or the engineering model. Models Engineering With the engineering model you can define consumers of what you want to create - personas - and their goals. This will allow you to better understand and communicate the Why of your idea. It will also allow you enlist help of others, e.g. potential users, to elaborate the personas and their goals - they likely know better than you what they want, unless you are building it for yourself. Then1 you may define products and their features. You may break down products into modules. Align features to goals. This would define the What of your idea tied to the Why. Then, define releases, issues, increments, engineers. Assign features to releases, issues to features or releases, and releases to increments. Assign issues to engineers. You may also assign responsible engineers to releases, features, and increments. This would define the How and the When both traceable to the What (features) and the Why (persona goals). As it was mentioned above, all of that can be done on a local computer - you don\u2019t need any server component, you don\u2019t even need to keep it under version control, although it is a good idea. So, if you have a super-secret idea you can keep everything on an encrypted thumb drive and work on it at night in your basement. In a team environment you can use an isolated network to collaborate. One more advantage of everything is local is that you may produce self-contained idea definitions which can be archived, copied/forked etc. It allows to establish a discovery-delivery pipeline where many ideas can be brought to high enough level of detail to allow efficient selection for delivery later. Having shared definitions of personas, goals, principles, and objectives would simplify comparison of ideas based on their benefit and cost. There is more to it, see the engineering model documentation and a list of features for more details. Flow With Nasdanika Flow you can create and publish models of flows - graphs of activities performed by participants using resources and consuming and producing artifacts. With Nasdanika Flow you can model customer journeys and team processes. Services allow to build flows \u201cin terms\u201d of other flows, e.g. a customer journey flow referencing an internal process as an activity. Inheritance allows to define common flows and then customize them. For example, in an IT organization there might be core development process and then technology and regions specific extensions. The flow concepts are very similar to the concepts of a programming language, such as Java, or of a distributed system, such as a cloud application. In other words with Nasdanika Flow you can \u201cprogram\u201d or \u201ccodify\u201d operations of an organization. The journey package in the engineering model (work in progress) aims to provide a bridge between the flow model and then engineering model in order to allow to define flows at persona level, reference personas from participant definitions, products/features from resource definitions, etc. With that it would be possible to build persona (customer) journeys in terms of product features and services provided by the organization and its engineers. Domain Problem domain structure is captured in a form of EMF Ecore (meta) model using Ecore Tools, which are part of Eclipse Modeling Tools Package. You can use a diagram or a tree editor to create domain models. Flow and Engineering models mentioned above are examples of domain models for different problem domains. Domain models serve the following purposes: Form a Ubiquitous Language - a common rigorous language between users and developers. Nasdanika HTML Ecore allows to generate documentation from Ecore models, \u201cpublish a dictionary\u201d so to speak. It automatically generates pacakge diagrams, class context and inheritance diagrams. Documentation can be defined in annotations or loaded from external resources. Model documentation is written in Markdown and can contain embedded diagrams. Generate Java code to load, diagnose, manipulate and save models. EMF Ecore provides capabilities to load models from and save to XML (XMI). Nasdanika EMF adds an ability to load models from an arbitrary storage of maps, lists, and scalars - YAML, JSON, properties files. When loading from YAML the loaded injects markers into the loaded objects to trace data elements to resource (file), line, column where they were loaded from. If a Git repository is detected then a GitMarker is injected instead with information about remotes and the commit hash. In a a model loaded from multiple resources residing in multiple Git repositories it allows to trace data elements to their source in \u201cspace\u201d (repository, file, line and column) and time (commit). You\u2019ve probably heard before that \u201call models are wrong, but some are useful\u201d. Models are wrong by definition because their purpose to reflect an aspect of interest of reality. If we define usefulness as positive ROI and short time to market, then with Nasdanika approach to modeling it is easier to create a useful model because production and publication of a model requires less effort than alternative approaches as explained below. Meta-Model creation Use Ecore Tools. Meta-Model documentation Nasdanika: Generate HTML with visualizations from models, mount it to a larger site. This site is an example of this approach. Alternatives: Manual or Javadoc from generated model classes. Production of Meta-Model binaries Nasdanika: Maven Java build publishing to a Maven repository. Alternatives: Maven Tycho build generating a p2 site which needs to be hosted somewhere. Model editing Nasdanika: Any text editor to author YAML or JSON - use load specification from the generation documentation to create model instances. Alternatives: An editor shall be created and published to a p2 site and used from Eclipse. Or a web server is needed to host an in-browser editor. Consumption of Meta-Model binaries To programmatically read or write models. Nasdanika: Any Maven application - add a dependency. Alternatives: Eclipse product, OSGi bundle dependency. Consumption of model content Nasdanika: Generate an HTML site from the model. Alternatives: Requires Eclipse IDE and an editor/viewer or a server to host a web viewer One area where Nasdanika approach to modeling may be useful is disposable/situational models - use a modeling approach to solve a problem which is small enough to justify investment into graphical editors, p2 hosting etc., but large enough to benefit from automation. Metaphorically speaking, Nasdanika uses r-selection - create cheap models quickly, see which one is useful and then invest more if needed. The alternatives tend to be closer to the K end of the spectrum requiring larger up-front investment. Use of the models Populate the model Once there is a domain Ecore (meta) model you can start creating model resources containing definitions of model elements. E.g. if your meta-model contains classes Organization and Engineer, you may define organization, \u201cAcme Corp.\u201d with an engineer \u201cJoe Doe\u201d. There are multiple ways to populate the model. Some of them are listed below. You don\u2019t to use one particular way - they can be used in combination. Some resources in your model may be defined YAML and edited in a text editor, some other may be defined in XMI and edited with, say, a diagram editor. There resources can cross-reference each other. YAML or JSON You can create models in YAML. With this approach, unlike the others listed below, you don\u2019t need to create a specialized editor - just use a YAML or text editor and load specification pages of the generated model documentation as a reference. Because models are defined in text they are easy to collaborate on without the use of specialized merge tools - use traditional diff and merge as for other textual artifacts such as Java files. This approach also allows to relatively easily load data from external systems which have no knowledge of your models\u2019 XMI format. Data can be loaded from REST endpoints or from data exports. Tree editor You can generate a tree editor for your models using Ecore Tools. It is a relatively small effort, but you\u2019ll need to build it, publish to a p2 repository (update site) and model authors will need to have Eclipse IDE and to be able to install the editor. Diagram editor With Eclipse Sirius you can generate visual diagram editors and with Sirius Web you can provide a web interface for editing models. Specialized text editor With Xtext you can create a specialized text editor with syntax highlighting, code completions, live validation and other features. Custom resources and factories You can also load data from external sources by implementing a custom Resource and Resource.Factory. YamlResource and YamlResourceFactory are examples of such implementation. For example, you may create a resource to load issue information from Jira using Jira Java API. In Domain-Driven Design terminology such resource and a resource factory would act as an Anti-Corruption Layer. Web application So you\u2019ve captured quite a bit of knowledge in your models, now it is time to share it! One way to share knowledge with humans is to generate a web site. For example, this site was generated from multiple engineering models stored in multiple Git repositories with documentation generated from Ecore models \u201cmounted\u201d to it. You can add dynamic read-only behavior to the generated site using Single-page applications which use model data. All issues page is an example of such an application built with Vue.js and BootstrapVue. It uses browser local storage for user preferences. This approach allows to have highly focused mini-apps injected into a static web site. Shall you need more dynamic behavior you can use helper web services. In this case model data can be used as input to the services in addition to user-provided data putting user input into a context. E.g. a single site may have multiple mini-apps calling the same service but with different inputs. Programmatic Model data can also be used by computers. In Java you use the generated model classes. You may load your model from multiple sources and then save it to XMI which can be published to a binary repository or on a web site. In non-java scenarios you may generate code in the target language. E.g. cross-referencing JSON files for a static REST API or JavaScript files to use model information in the browser. It can be done in combination with generating a static file, i.e. your site would contain both HTML and JSON/JavaScript. In this case JSON/JavaScript can be used by the mini-apps. Products overview This section provides a brief overview of Nasdanika products and their modules. Core - foundational functionality CLI - classes which allow to call execution model Command from a command line. Common - common functionality such as the execution model, resource and persistence frameworks. Diagram - Diagram EMF model is a level of abstraction to create diagram visualizations using Java API and then generate PlantUML and diagrams.net diagrams from it. EMF - classes for working with Ecore models, e.g. classes for loading models from YAML files. Exec - Ecore models and adapters to execution model participants to build code generators and to load model content from different sources. Flow - Ecore flow model to capture customer journeys/business processes. mxgraph - Maven jar packaging of mxgraph sources. It is used to generate diagrams.net diagrams. Ncore - Ecore model containing common classes used/extended in other models. HTML - Java API\u2019s and models for generating HTML Bootstrap - Fluent Java API to generate Bootstrap 4 markup. Ecore - Classes to generate documentation of Ecore models as action models (see Models/Application below). EMF - Base classes for building generators of action models from Ecore model elements. Flow - Generators of action models from the flow model elements. HTML - Fluent Java API to generate HTML 5 markup. jsTree - Java API for generating jsTree JSON. Models - Ecore models to build HTML pages and applications. HTML - Ecore model representing HTML elements and generation adapters. Bootstrap - Ecore model representing Bootstrap 4 elements and generation adapters. Application - Ecore model representing a web site/application as a hierarchy of actions. Adapters to generate HTML sites (resource models) from action models. Engineering - Ecore model representing (software) engineering concepts such as an organization, engineer, product, release, feature, issue, \u2026 Adapters for generating HTML sites from engineering models. TOGAF - Models representing TOGAF concepts. ADM - flow model of TOGAF Architecture Development Method. Nasdanika products are Java-based, hosted on GitHub Nasdanika organization and published to Maven Central: Core HTML Engineering Or before, or in parallel - totally up to you. Start somewhere, expand from there. ↩"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Dropdown.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Dropdown",
        "title": "Dropdown",
        "content": "org.nasdanika.html.model.bootstrap.Dropdown"
    },
    "modules/core/modules/ncore/IMarker.html": {
        "path": "Products/Core/Ncore/IMarker",
        "title": "IMarker",
        "content": "org.nasdanika.common.persistence.Marker Subtypes Marker"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Breakpoint.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Breakpoint",
        "title": "Breakpoint",
        "content": "org.nasdanika.html.bootstrap.Breakpoint Uses Float NavigationBar Spacing"
    },
    "modules/html/modules/models/modules/app/modules/gen/issues/table-component-column-order/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters/Issues/Table component column order",
        "title": "Table component column order",
        "content": "Add support of column ordering - drag and drop or up/down arrows. Also storable in the local storage. Origin model/app.gen/engineering.yml 23:6 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen/issues/table-component-column-order Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generation Adapters Workable"
    },
    "increments/2022/children/Q3/index.html": {
        "path": "Increments/2022/Q3",
        "title": "Q3",
        "content": "Origin engineering/nasdanika.yml 128:9 Uri engineering://nasdanika/increments/2022/children/Q3 Start Jul 1, 2022 End Oct 1, 2022 Duration 92 days"
    },
    "modules/core/modules/diagram/modules/gen/issues/connection-ids/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Connection ID's",
        "title": "Connection ID's",
        "content": "Own GUID or as source ID and connection role/key e.g. xxxx-outputs-xyz Origin diagram.gen/engineering.yml 68:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/connection-ids Target Generators Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/TextWeight.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/TextWeight",
        "title": "TextWeight",
        "content": "org.nasdanika.html.bootstrap.Text.Weight Uses Text"
    },
    "personas/java-developer/goals/efficiency/children/generated-doc/index.html": {
        "path": "Personas/Java Developer/Goals/Efficiency/Children/Generated Documentation",
        "title": "Generated Documentation",
        "content": "Origin engineering/nasdanika.yml 28:15 Uri engineering://nasdanika/personas/java-developer/goals/efficiency/children/generated-doc"
    },
    "modules/core/modules/ncore/StringProperty.html": {
        "path": "Products/Core/Ncore/StringProperty",
        "title": "StringProperty",
        "content": "org.nasdanika.ncore.StringProperty Supertypes Property String"
    },
    "modules/core/modules/flow/issues/git-provenance/index.html": {
        "path": "Products/Core/Flow/Issues/Git provenance",
        "title": "Git provenance",
        "content": "Conversion of file URI's in markers to Git upstream URI's using jGit and then to URL's of, say, GitHub. Generic marker processing approach and then Git implementation with GitHub implementation as an extension. Would allow to navigate to the source location of model elements. Shall be very useful in the case of flow inheritance where elements may reside in multiple source repositories. Origin flow/engineering/engineering.yml 69:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/git-provenance Target Flow Workable"
    },
    "modules/html/modules/ecore/issues/engineering-generation-target/index.html": {
        "path": "Products/HTML/Ecore/Issues/Engineering generation target",
        "title": "Engineering generation target",
        "content": "Generate engineering model instead of action model. This would allow to link issues, owners, etc. to model elements. Need support for merging. Origin ecore/engineering.yml 18:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/engineering-generation-target Target Ecore Workable"
    },
    "modules/html/modules/models/issues/components/index.html": {
        "path": "Products/HTML/Models/Issues/Reintroduce components",
        "title": "Reintroduce components",
        "content": "Origin model/engineering.yml 24:5 Uri engineering://nasdanika/modules/html/modules/models/issues/components Target Models Workable"
    },
    "modules/core/modules/flow/index.html": {
        "path": "Products/Core/Flow",
        "title": "Flow",
        "content": "Origin flow/engineering/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/flow Dependencies Generation Adapters Model Generators Dependants Model With Nasdanika Flow you can model organizational processes as flows - directed graphs of activities connected by transitions and calls and performed by participants using resources and consuming and producing artifacts. Flow extends activity and as such flows can be nested. Artifacts can also be nested, which allows to model composite artifacts such as modular and distributed systems, e.g. a cloud application. Flow models can be defined in a set of cross-referencing YAML files with supporting Markdown documentation either embedded in YAML or stored in files. Markdown documentation supports embedding of diagrams and token interpolation/substitution. Textual definitions of flows in multiple files allow to work with them in the same way as with source code, say, Java - branch, create a pull request, merge. In a way, Nasdanika Flow allows to write \u201cprograms\u201d to be executed by an organization similar to how Java programs are executed by a JVM or how distributed systems, such as cloud applications, operate. Textual format also means that flow definitions can be edited and viewed using a wide variety of tools, including viewing and editing in a web browser using native facilities of source control systems such as GitHub. A static web site is generated from flow models. Generated site includes generated visualizations - PlantUML State diagrams or Diagrams.net diagrams. Diagrams.net diagrams can be manually edited after generation. Dynamic behavior can be added to generated pages using Single Page Applications, e.g. applications built with Vue.js, VueRouter, and BootstrapVue. It allows to inject fine-grained productivity tools into activities where they are used. Such tools may use more generic tools behind the scenes and \u201cbind\u201d some contextual parameters to reduce participant\u2019s mental load and probability of mistakes. Flows can extend other flows forming an inheritance hierarchy similar to inheritance in languages such as Java or Docker images specifying base images. This allows to define base process/flow packages and extend/tailor them to specific needs. Nasdanika Flow also features: Responsibility Assignment Matrices, Validation, Data Provenance. Core concepts Package - Root element of the flow model containing other elements including sub-packages. Flow - A composite activity containing flow elements - activities, flows, services, and pseudo-states. Activity - a flow element performed by a participant. Has output transitions and may call other flow elements. Activities can specify input and output artifacts, responsibility assignments, and artifact responsibility assignments. Transition - when an activity completes it passes control and artifacts to subsequent activities via transitions. Fire-and-forget. Transitions may specify payload - artifacts which they carry from source to target. Call - a flow element may call other flow elements as part of its execution. Calling activity blocks waiting for the called activity to complete. Request-reply. In addition to payload calls may specify response - artifacts returned to the source from the target, e.g. a signed certificate or connectivity parameters for a new database. Participant - performs activities. May contain (offer) shared activities (including flows) as services which can be referenced from flows. E.g., a technology team may offer a service \u201cCreate a cloud Environment\u201d referenced from multiple flows. A service offered by one participant may call services offered by other participants. Resource - something used to complete activities. E.g. IDE or Cl/CD pipeline. Resources can be repositories of artifacts and can provide shared activities - services, which can be referenced from flows. Artifact - inputs and outputs of activities passed between activities via transitions and calls and stored in repository resources. E.g., a design document or source code. Artifacts can form a containment hierarchy and can reference template artifacts. Service - a flow element referencing an activity provided by a participant or resource. Pseudo-states - used to combine and direct transitions. Knowledge continuum One way to think about a flow model is as of a \u201cknowledge continuum\u201d where knowledge of how to do things is organized in progression from generic to specific with bi-directional links between more generic and more specific pieces. Activity documentation would be the most specific unit of knowledge, or, to be more precise, a mix of bits and pieces of knowledge from multiple domains/disciplines. For example, to perform a microservice development activity a developer need to know how to use IDE, source control system, an issue tracking system, etc. However, they don\u2019t need to know all of that at the expert level. E.g. they just need to know how to commit their code to the source control system and how to update an issue. They don\u2019t necessarily need to know how to do branching, merging, rebasing. Activity documentation may contain links to specific parts of reference manuals for resources and artifacts used by the activity, e.g. a specific chapter in a source control reference manual. Bi-directional references between activities and participants, resources, and artifacts used in activity are automatically generated. Resource, Artifact, and Participant documentation is more generic, but still specific to the flow package. E.g. documentation for a build tool resource may provide a description how the tool is used in the flow and contain references to external resources - manuals, book, video courses. Bi-directional links between participants and tools/artifacts they use in all activities are automatically generated. A person who is new to playing a role of a particular participant may study participant documentation including resources the participant uses and activities it participates in. And finally, resources referenced from the flow documentation are most generic and flow-independent. These resources can also be categorized, if needed, from specific to generic. E.g. there might be documentation on how to use a particular tool within the organization and documentation on how to use the tool in general. Examples TOGAF ADM Sources Generated documentation Tests Sources - JUnit tests to generate HTML from models. Resources - flow definitions. Generated documentation Core Agile - not a real Agile flow, just a demo. AWS - extends (inherits from) the Core Agile above, adds AWS-specific artifacts. Flow - inherited from the Core Agile. Components - hierarchical AWS-specific artifacts. Process overview An example of generating a web site from a flow model can be found here - TestTogafAdmGen.java. Generation steps: Load the model from YAML or other resource. Optionally validate. Abstract and mix-in models may contain validation errors such as unresolved proxies \u201cby design\u201d and therefore shall not be validated upon load. Create an instance model. At this step you may save the instance model to XMI to logically separate processing steps. You may also enrich the model by loading data from external systems. Generate an action model from the instance model. Generate a resource model from the action model. At this step you may combine multiple action models. Generate a site (container) from the resource model. Maven dependency To use the flow model add the following dependency to pom.xml: <dependency>\n  <groupId>org.nasdanika.core<\/groupId>\n  <artifactId>flow<\/artifactId>\n  <version>2022.1.2<\/version>\n<\/dependency>\n A list of versions can be found here."
    },
    "modules/html/modules/jstree/index.html": {
        "path": "Products/HTML/jsTree",
        "title": "jsTree",
        "content": "Origin jstree/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/jstree Dependencies HTML Dependants Generation Adapters"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Navbar.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Navbar",
        "title": "Navbar",
        "content": "org.nasdanika.html.model.bootstrap.Navbar"
    },
    "issue-statuses.html": {
        "path": "Issue/Statuses",
        "title": "Statuses",
        "content": "Open In Progress Done Cancelled"
    },
    "modules/core/modules/common/issues/drawio-escaping/index.html": {
        "path": "Products/Core/Common/Issues/Extract shape text from drawio XML for searching",
        "title": "Extract shape text from drawio XML for searching",
        "content": "MarkdownHelper.escapeDiagramSpec(). Parse using mxgraph api, need to add/verify support for decompression - both compressed and uncompressed diagrams shall be supported. Origin common/engineering/engineering.yml 22:5 Uri engineering://nasdanika/modules/core/modules/common/issues/drawio-escaping Categories Good First Issue Target Common Workable"
    },
    "modules/core/modules/flow/issues/drawio-styling/index.html": {
        "path": "Products/Core/Flow/Issues/Drawio styling for pseudo-states",
        "title": "Drawio styling for pseudo-states",
        "content": "Choice, join, ... PlantUML layout shall take care of port positioning. Origin flow/engineering/engineering.yml 64:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/drawio-styling Target Flow Workable"
    },
    "modules/core/index.html": {
        "path": "Products/Core",
        "title": "Core",
        "content": "Origin engineering.yml 1:1 Uri engineering://nasdanika/modules/core"
    },
    "modules/html/modules/emf/issues/hierarchical-tables/index.html": {
        "path": "Products/HTML/EMF/Issues/Hierarchical tables",
        "title": "Hierarchical tables",
        "content": "RowBuilder provider similar as for lists. Perhaps needs to take depth argument so can build indent in the first column. Origin emf/engineering.yml 9:5 Uri engineering://nasdanika/modules/html/modules/emf/issues/hierarchical-tables Target EMF Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/ButtonGroup.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/ButtonGroup",
        "title": "ButtonGroup",
        "content": "org.nasdanika.html.model.bootstrap.ButtonGroup"
    },
    "modules/core/modules/diagram/modules/gen/issues/drawio-multi-page/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Support of multi-page diagrams",
        "title": "Support of multi-page diagrams",
        "content": "Low level: Encoding methods which take a colleciton of diagrams, single diagram methods delegate to them. High level (flow and state diagrams) - a flag specifying that a diagram element with child elements which is not a partition shall be generated as another page rather than navigating to that element's HTML page. Maybe refactor partition attribute to some kind of enum attribute with partition and page as possible values. For PlantUML use table by default, as it is now, but with an anchor for cross-referencing. Protected method to override to use, say, bootstrap tabs, instead of tables. Origin diagram.gen/engineering.yml 56:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/drawio-multi-page Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generators Workable"
    },
    "modules/core/modules/diagram/modules/gen/issues/word-wrapping/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Word wrapping",
        "title": "Word wrapping",
        "content": "If there are new lines - replace with space, set word wrapping to true, count lines and adjust width and heights according to the longes line and the number of lines. Origin diagram.gen/engineering.yml 71:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/word-wrapping Target Generators Workable"
    },
    "modules/core/modules/ncore/IntegerProperty.html": {
        "path": "Products/Core/Ncore/IntegerProperty",
        "title": "IntegerProperty",
        "content": "org.nasdanika.ncore.IntegerProperty Supertypes Property Integer"
    },
    "modules/html/modules/flow/issues/predicate/index.html": {
        "path": "Products/HTML/Flow/Issues/Predicate",
        "title": "Predicate",
        "content": "Add support of filtered generation using a predicate service in Context. Perhaps have a specialized interface instead of java function predicate to avoid accidental clash. Also the predicate interface may have a method for filtering typed elements - structural features and operations. E.g. hide URI's. Perhaps have this interface in the same package with EObjectActionProvider or even as a nested interface. getPredicate() returns a predicate which accepts everything - to avoid null checks all over. Origin flow/engineering.yml 15:5 Uri engineering://nasdanika/modules/html/modules/flow/issues/predicate Target Flow Workable"
    },
    "increments/2022/children/Q1/children/feb/index.html": {
        "path": "Increments/2022/Q1/February",
        "title": "February",
        "content": "Origin engineering/nasdanika.yml 103:13 Uri engineering://nasdanika/increments/2022/children/Q1/children/feb Start Feb 1, 2022 End Mar 1, 2022 Duration 28 days"
    },
    "modules/html/modules/models/modules/app/modules/model/ActionReference.html": {
        "path": "Products/HTML/Models/Application/Model/ActionReference",
        "title": "ActionReference",
        "content": "org.nasdanika.html.model.app.ActionReference Supertypes Reference<Action>"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Navs.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Navs",
        "title": "Navs",
        "content": "org.nasdanika.html.model.bootstrap.Navs"
    },
    "modules/core/modules/exec/modules/model/index.html": {
        "path": "Products/Core/Exec/Model",
        "title": "Model",
        "content": "Nasdanika Core Exec model classes can be used to create models for generation of resources such as files and their content. To use in the Maven environment search for the latest version on Maven Central and copy/paste a dependency declaration to the pom.xml. Maven dependency Example as of the time of writing: <dependency>\n  <groupId>org.nasdanika.core<\/groupId>\n  <artifactId>exec<\/artifactId>\n  <version>2021.8.0<\/version>\n<\/dependency>\n TODO - Update code snippets and content below. Java code Suppliers To load and execute content components which implement org.nasdanika.common.SupplierFactory<<a href=\u2018https://docs.oracle.com/javase/8/docs/api/index.html?java/io/InputStream.html\u2019>java.io.InputStream> from a YAML resource use code like this: import java.io.InputStream;\nimport java.util.Map;\n\nimport org.nasdanika.common.Context;\nimport org.nasdanika.common.persistence.ObjectLoader;\nimport org.nasdanika.common.PrintStreamProgressMonitor;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Supplier;\nimport org.nasdanika.common.SupplierFactory;\nimport org.nasdanika.common.Util;\nimport org.nasdanika.exec.Iterator;\nimport org.nasdanika.exec.Loader;\nimport org.yaml.snakeyaml.Yaml;\n\n...\n\n// Create a loader. There is a constructor which takes a chain loader for processing unmatched types.\nObjectLoader loader = Loader();\n\n// Progress monitor which outputs to the console. \nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\n\n// Loading YAML from a classloader resource.\nObject iterator = loader.loadYaml(TestExec.class.getResource(\"iterator-spec.yml\"), monitor);\n\t\t\n// Loading context, also from a YAML classloader resource.\t\t\nMap<String, Object> yaml = new Yaml().load(TestExec.class.getResourceAsStream(\"iterator-config.yml\"));\nContext context = Context.wrap(yaml::get);\n\t\t\n// Executing the object - in this case we are getting InputStream as a result.\nInputStream result = callSupplier(context, monitor, iterator);\n\n// Or, to get a string, use Util to convert InputStream to String \nString result = Util.toString(context, supplier.execute(monitor));\n Consumers To load and execute resource components which implement org.nasdanika.common.ConsumerFactory<<a href=\u2018https://docs.nasdanika.org/modules/core/modules/common/apidocs/index.html?org/nasdanika/common/resources/BinaryEntityContainer.html\u2019>org.nasdanika.common.resources.BinaryEntityContainer> from a YAML resource use code like this: import org.nasdanika.common.Context;\nimport org.nasdanika.common.persistence.ObjectLoader;\nimport org.nasdanika.common.PrintStreamProgressMonitor;\nimport org.nasdanika.common.ProgressMonitor;\nimport org.nasdanika.common.Consumer;\nimport org.nasdanika.common.ConsumerFactory;\nimport org.nasdanika.common.Util;\nimport org.nasdanika.exec.Loader;\nimport org.yaml.snakeyaml.Yaml;\n\n...\nObjectLoader loader = new Loader();\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(specURL, monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\");\noutDir.mkdirs();\nContext context = Context.EMPTY_CONTEXT;\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\ncallConsumer(context, monitor, container, out);\t\t\n Helper methods Code snippets in components documentation and the code snippets above use two helper methods - callSupplier() and callConsumer(). These methods cover full lifecycle of supplier and consumer execution participants (see Execution model) - diagnose, execute, commit/rollback, and close. The methods use JUnit fail() to report problems. Adjust as needed - throw an exception or return an exit or status code. callSupplier() /**\n * Executes full supplier lifecycle - diagnose, execute, commit/rollback, close.\n * @param context\n * @param monitor\n * @param component\n * @return\n * @throws Exception\n */\nstatic InputStream callSupplier(Context context, ProgressMonitor monitor, Object component) throws Exception {\n\ttry (Supplier<InputStream> supplier = Loader.asSupplierFactory(component).create(context); ProgressMonitor progressMonitor = monitor.setWorkRemaining(3).split(\"Calling component\", 3)) {\n\t\tDiagnostic diagnostic = supplier.splitAndDiagnose(progressMonitor);\n\t\tif (diagnostic.getStatus() == Status.ERROR) {\n\t\t\tdiagnostic.dump(System.err, 4);\n\t\t\tfail(\"Diagnostic failed: \" + diagnostic.getMessage());\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tInputStream result = supplier.splitAndExecute(progressMonitor);\n\t\t\tsupplier.splitAndCommit(progressMonitor);\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tif (e instanceof DiagnosticException) {\n\t\t\t\t((DiagnosticException) e).getDiagnostic().dump(System.err, 4);\n\t\t\t}\n\t\t\tif (supplier.splitAndRollback(progressMonitor)) {\n\t\t\t\tfail(\"Exception \" + e + \", rollback successful\");\n\t\t\t} else {\n\t\t\t\tfail(\"Exception \" + e + \", rollback failed\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\tthrow new NasdanikaException(\"Never get here\");\n\t\t}\n\t}\n}\n callConsumer() /**\n * Executes full consumer lifecycle - diagnose, execute, commit/rollback, close.\n * @param context\n * @param monitor\n * @param component\n * @return\n * @throws Exception\n */\nstatic void callConsumer(Context context, ProgressMonitor monitor, Object component, BinaryEntityContainer container) throws Exception {\n\ttry (Consumer<BinaryEntityContainer> consumer = Loader.asConsumerFactory(component).create(context); ProgressMonitor progressMonitor = monitor.setWorkRemaining(3).split(\"Calling component\", 3)) {\n\t\tDiagnostic diagnostic = consumer.splitAndDiagnose(progressMonitor);\n\t\tif (diagnostic.getStatus() == Status.ERROR) {\n\t\t\tdiagnostic.dump(System.err, 4);\n\t\t\tfail(\"Diagnostic failed: \" + diagnostic.getMessage());\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tconsumer.splitAndExecute(container, progressMonitor);\n\t\t\tconsumer.splitAndCommit(progressMonitor);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tif (e instanceof DiagnosticException) {\n\t\t\t\t((DiagnosticException) e).getDiagnostic().dump(System.err, 4);\n\t\t\t}\n\t\t\tif (consumer.splitAndRollback(progressMonitor)) {\n\t\t\t\tfail(\"Exception \" + e + \", rollback successful\");\n\t\t\t} else {\n\t\t\t\tfail(\"Exception \" + e + \", rollback failed\");\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n Collecting execution results In some situations it might be needed to return information from execution participants to the calling code. For example, an ID of a generated resource or commit ID of pushed code. This section outlines several ways of achieving this task: Anonymous execution participants - the calling code defines a custom loader which creates an anonymous sub-class of an execution participant. The subclass overrides one of methods to report execution result to some form of a result collector in the enclosing scope. Custom or customized execution participants - client code developer creates a custom execution participant or a sub-class of an existing execution participant class. The custom class takes some form of result collector in its constructor and stores it to an instance variable. Custom class uses the result collector to report execution result to the result collector. The sub-class overrides one of methods to report execution result to the result collector. Client code developer also creates a custom loader which takes the result collector as its constructor argument. The loader then passes the result collector to the customized execution participant constructor. This technique can be combined with the first one. For example, the loader may be anonymous and the custom component may be not, or vice versa. Also loaders can be sub-classed or chained. Context service - results collector is passed to execution participants as a context service. If the service is present in the context, execution participants report results to the service. Context property - results collector is passed as a context property. A disadvantage of this approach over the previous one is that property name may change as a result of mapping or a property may become unavailable to downstream components unless explicitly mapped. Progress monitor - results are reported as data to the progress monitor. The calling code inspects progress data to collect execution results. Exceptions - exception type and associated data is used to analyze the cause of failure. Can be used in conjunction with the progress monitor approach if the execution participant reporting failure also reports data associate with the failure to the progress monitor. The following sections provide examples of implementing the first five of the above approaches. All the examples use the same YAML specification: # Testing container and file\nfile:\n   name: hello.txt\n   contents:\n      custom-component: {}\n Anonymous execution participants // Results collector in enclosing scope.\nString[] result = {null};\n\nObjectLoader loader = new Loader() {\n\n\t@Override\n\tpublic Object create(ObjectLoader loader, String type, Object config, URL base,\tProgressMonitor progressMonitor, Marker marker) throws Exception {\n\t\t\n\t\tif (\"custom-component\".equals(type)) {\n\t\t\treturn new SupplierFactory<InputStream>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Supplier<InputStream> create(Context context) throws Exception {\n\t\t\t\t\treturn new Supplier<InputStream>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic double size() {\n\t\t\t\t\t\t\treturn 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String name() {\n\t\t\t\t\t\t\treturn \"Custom content supplier\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic InputStream execute(ProgressMonitor progressMonitor) throws Exception {\n\t\t\t\t\t\t\t// Setting result value and returning the same value.\n\t\t\t\t\t\t\tresult[0] = new Date().toString(); \n\t\t\t\t\t\t\treturn Util.toStream(context, result[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn super.create(loader, type, config, base, progressMonitor, marker);\n\t}\n\t\n};\n\n// Execution\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(TestExec.class.getResource(\"results-collection.yml\"), monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\" + File.separator + \"results-collection\" + File.separator + \"anonymous\");\noutDir.mkdirs();\nContext context = Context.EMPTY_CONTEXT;\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\ncallConsumer(context, monitor, container, out);\n\n// Accessing result\nSystem.out.println(result[0]);\n Custom execution participant Custom content supplier and custom loader with chaining. Custom supplier public class CustomSupplierFactory implements SupplierFactory<InputStream> {\n\t\n\tprivate Consumer<String> resultsCollector;\n\n\tpublic CustomSupplierFactory(java.util.function.Consumer<String> resultsCollector) {\n\t\tthis.resultsCollector = resultsCollector;\n\t}\n\n\t@Override\n\tpublic Supplier<InputStream> create(Context context) throws Exception {\n\t\treturn new Supplier<InputStream>() {\n\n\t\t\t@Override\n\t\t\tpublic double size() {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String name() {\n\t\t\t\treturn \"Custom content supplier\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic InputStream execute(ProgressMonitor progressMonitor) throws Exception {\n\t\t\t\tString result = new Date().toString();\n\t\t\t\tresultsCollector.accept(result);\n\t\t\t\treturn Util.toStream(context, result);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\t\n};\n Custom loader public class CustomLoader extends ObjectLoader {\n\t\n\tprivate Consumer<String> resultsCollector;\n\n\tpublic CustomLoader(java.util.function.Consumer<String> resultsCollector, ObjectLoader chain) {\n\t\tthis.resultsCollector = resultsCollector;\n\t\tthis.chain = chain;\n\t}\n\t\t\n\tprivate org.nasdanika.common.ObjectLoader chain;\n\n\t@Override\n\tpublic Object create(ObjectLoader loader, String type, Object config, URL base, ProgressMonitor progressMonitor, Marker marker) throws Exception {\n\t\t\n\t\ttry (ProgressMonitor subMonitor = progressMonitor.setWorkRemaining(10).split(\"Creating \" + type, 1, marker)) {\n\t\t\tswitch (type) {\n\t\t\tcase \"custom-component\":\n\t\t\t\treturn new CustomSupplierFactory(resultsCollector);\t\t\t\n\t\t\tdefault:\n\t\t\t\tif (chain == null) {\n\t\t\t\t\tthrow new ConfigurationException(\"Unsupported type: \" + type, marker);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn chain.create(loader, type, config, base, subMonitor, marker);\n\t\t\t}\n\t\t}\n\t}\n\n}\n Client code // Results consumer.\njava.util.function.Consumer<String> resultsConsumer = System.out::println;\n\nObjectLoader loader = new CustomLoader(resultsConsumer, new Loader());\n\n// Execution\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(TestExec.class.getResource(\"results-collection.yml\"), monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\" + File.separator + \"results-collection\" + File.separator + \"anonymous\");\noutDir.mkdirs();\nContext context = Context.EMPTY_CONTEXT;\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\ncallConsumer(context, monitor, container, out);\n Context service In the below example a service interface is defined for collecting results. An instance of the interface is passed as a context service down to executor. Results collecting service This example uses an interface, but it is also possible to define a results collecting class. public interface ResultsCollector {\n\t\n\tvoid onMyResult(String result);\n\n}\n Custom component public class CustomSupplierFactoryTwo implements SupplierFactory<InputStream> {\n\t\n\t@Override\n\tpublic Supplier<InputStream> create(Context context) throws Exception {\n\t\treturn new Supplier<InputStream>() {\n\n\t\t\t@Override\n\t\t\tpublic double size() {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String name() {\n\t\t\t\treturn \"Custom content supplier\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic InputStream execute(ProgressMonitor progressMonitor) throws Exception {\n\t\t\t\tString result = new Date().toString();\n\t\t\t\tResultsCollector resultsCollector = context.get(ResultsCollector.class);\n\t\t\t\tif (resultsCollector != null) {\n\t\t\t\t\tresultsCollector.onMyResult(result);\n\t\t\t\t}\n\t\t\t\treturn Util.toStream(context, result);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\t\n};\n Custom loader public class CustomLoaderTwo extends ObjectLoader {\n\n\tpublic CustomLoaderTwo(ObjectLoader chain) {\n\t\tthis.chain = chain;\n\t}\n\t\t\n\tprivate org.nasdanika.common.ObjectLoader chain;\n\n\t@Override\n\tpublic Object create(ObjectLoader loader, String type, Object config, URL base, ProgressMonitor progressMonitor, Marker marker) throws Exception {\n\t\t\n\t\ttry (ProgressMonitor subMonitor = progressMonitor.setWorkRemaining(10).split(\"Creating \" + type, 1, marker)) {\n\t\t\tswitch (type) {\n\t\t\tcase \"custom-component\":\n\t\t\t\treturn new CustomSupplierFactoryTwo();\t\t\t\n\t\t\tdefault:\n\t\t\t\tif (chain == null) {\n\t\t\t\t\tthrow new ConfigurationException(\"Unsupported type: \" + type, marker);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn chain.create(loader, type, config, base, subMonitor, marker);\n\t\t\t}\n\t\t}\n\t}\n\n}\n Client code // Results collector.\nResultsCollector resultCollector = new ResultsCollector() {\n\t\n\t@Override\n\tpublic void onMyResult(String result) {\n\t\tSystem.out.println(\"*** My result: \" + result);\n\t\t\n\t}\n};\n\nObjectLoader loader = new CustomLoaderTwo(new Loader());\n\n// Execution\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(TestExec.class.getResource(\"results-collection.yml\"), monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\" + File.separator + \"results-collection\" + File.separator + \"context-service\");\noutDir.mkdirs();\nContext context = Context.singleton(ResultsCollector.class, resultCollector);\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\ncallConsumer(context, monitor, container, out);\n Context property Custom component public class CustomSupplierFactoryThree implements SupplierFactory<InputStream> {\n\t\n\t@Override\n\tpublic Supplier<InputStream> create(Context context) throws Exception {\n\t\treturn new Supplier<InputStream>() {\n\n\t\t\t@Override\n\t\t\tpublic double size() {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String name() {\n\t\t\t\treturn \"Custom content supplier\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic InputStream execute(ProgressMonitor progressMonitor) throws Exception {\n\t\t\t\tString result = new Date().toString();\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\tjava.util.function.Consumer<String> resultsCollector = context.get(\"results-collector\", java.util.function.Consumer.class);\n\t\t\t\tif (resultsCollector != null) {\n\t\t\t\t\tresultsCollector.accept(result);\n\t\t\t\t}\n\t\t\t\treturn Util.toStream(context, result);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\t\n};\n Custom loader public class CustomLoaderThree extends ObjectLoader {\n\n\tpublic CustomLoaderThree(ObjectLoader chain) {\n\t\tthis.chain = chain;\n\t}\n\t\t\n\tprivate org.nasdanika.common.ObjectLoader chain;\n\n\t@Override\n\tpublic Object create(ObjectLoader loader, String type, Object config, URL base, ProgressMonitor progressMonitor, Marker marker) throws Exception {\n\t\t\n\t\ttry (ProgressMonitor subMonitor = progressMonitor.setWorkRemaining(10).split(\"Creating \" + type, 1, marker)) {\n\t\t\tswitch (type) {\n\t\t\tcase \"custom-component\":\n\t\t\t\treturn new CustomSupplierFactoryThree();\t\t\t\n\t\t\tdefault:\n\t\t\t\tif (chain == null) {\n\t\t\t\t\tthrow new ConfigurationException(\"Unsupported type: \" + type, marker);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn chain.create(loader, type, config, base, subMonitor, marker);\n\t\t\t}\n\t\t}\n\t}\n\n}\n Client code ObjectLoader loader = new CustomLoaderThree(new Loader());\n\n// Execution\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(TestExec.class.getResource(\"results-collection.yml\"), monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\" + File.separator + \"results-collection\" + File.separator + \"context-service\");\noutDir.mkdirs();\nContext context = Context.singleton(\"results-collector\", (java.util.function.Consumer<String>) System.out::println);\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\ncallConsumer(context, monitor, container, out);\n Progress monitor Custom supplier public class CustomSupplierFactoryFour implements SupplierFactory<InputStream> {\n\t\n\t@Override\n\tpublic Supplier<InputStream> create(Context context) throws Exception {\n\t\treturn new Supplier<InputStream>() {\n\n\t\t\t@Override\n\t\t\tpublic double size() {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String name() {\n\t\t\t\treturn \"Custom content supplier\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic InputStream execute(ProgressMonitor progressMonitor) throws Exception {\n\t\t\t\tString result = new Date().toString();\n\t\t\t\tprogressMonitor.worked(1.0, \"My execution result\", CustomSupplierFactoryFour.this, result);\n\t\t\t\treturn Util.toStream(context, result);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\t\n};\n Custom loader public class CustomLoaderFour extends ObjectLoader {\n\n\tpublic CustomLoaderFour(ObjectLoader chain) {\n\t\tthis.chain = chain;\n\t}\n\t\t\n\tprivate org.nasdanika.common.ObjectLoader chain;\n\n\t@Override\n\tpublic Object create(ObjectLoader loader, String type, Object config, URL base, ProgressMonitor progressMonitor, Marker marker) throws Exception {\n\t\t\n\t\ttry (ProgressMonitor subMonitor = progressMonitor.setWorkRemaining(10).split(\"Creating \" + type, 1, marker)) {\n\t\t\tswitch (type) {\n\t\t\tcase \"custom-component\":\n\t\t\t\treturn new CustomSupplierFactoryFour();\t\t\t\n\t\t\tdefault:\n\t\t\t\tif (chain == null) {\n\t\t\t\t\tthrow new ConfigurationException(\"Unsupported type: \" + type, marker);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn chain.create(loader, type, config, base, subMonitor, marker);\n\t\t\t}\n\t\t}\n\t}\n\n}\n Client code This code uses a subclass of FilterProgressMonitor to suppress reporting of the result to the print stream monitor. If suppression is not required monitor composition using compose() method can be used instead of filtering. ObjectLoader loader = new CustomLoaderFour(new Loader());\n\n// Execution\nProgressMonitor monitor = new PrintStreamProgressMonitor(System.out, 0, 4, false);\nObject container = loader.loadYaml(TestExec.class.getResource(\"results-collection.yml\"), monitor);\n\t\t\nFile outDir = new File(\"target\" + File.separator + \"test-output\" + File.separator + \"results-collection\" + File.separator + \"progress-monitor\");\noutDir.mkdirs();\nContext context = Context.EMPTY_CONTEXT;\t\t\nFileSystemContainer out = new FileSystemContainer(outDir);\n\nclass FilterMonitor extends FilterProgressMonitor {\n\t\n\tpublic FilterMonitor(ProgressMonitor target) {\n\t\tsuper(target);\n\t}\n\n\t@Override\n\tpublic void worked(Status status, double work, String progressMessage, Object... data) {\t\t\t\t\n\t\tif (Status.SUCCESS == status \n\t\t\t\t&& data != null \n\t\t\t\t&& data.length == 2 \n\t\t\t\t&& CustomSupplierFactoryFour.class.isInstance(data[0])) {\n\t\t\t\n\t\t\tSystem.out.println(\"Gotcha: \" + data[1]);\n\t\t} else {\n\t\t\tsuper.worked(status, work, progressMessage, data);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic ProgressMonitor split(String taskName, double size, Object... data) {\n\t\treturn new FilterMonitor(super.split(taskName, size, data));\n\t}\n\t\n}\n\n// Filtering worked notification to get to what we need by analyzing arguments, e.g. data.\ncallConsumer(context, new FilterMonitor(monitor), container, out);\n Origin exec/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/exec/modules/model Dependencies EMF Dependants Generators"
    },
    "increments/2022/children/Q1/index.html": {
        "path": "Increments/2022/Q1",
        "title": "Q1",
        "content": "Origin engineering/nasdanika.yml 94:9 Uri engineering://nasdanika/increments/2022/children/Q1 Start Jan 1, 2022 End Apr 1, 2022 Duration 89 days 23 hours"
    },
    "modules/core/modules/emf/index.html": {
        "path": "Products/Core/EMF",
        "title": "EMF",
        "content": "Origin emf/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/emf Dependencies CLI Ncore Dependants Model EMF"
    },
    "modules/core/modules/flow/ExitPoint.html": {
        "path": "Products/Core/Flow/ExitPoint",
        "title": "ExitPoint",
        "content": "org.nasdanika.flow.ExitPoint Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\exit-point.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/core/issues/merge-to-master/index.html": {
        "path": "Products/Core/Issues/Merge to master",
        "title": "Merge to master",
        "content": "Origin engineering.yml 30:5 Uri engineering://nasdanika/modules/core/issues/merge-to-master Target Core Workable"
    },
    "modules/engineering/modules/model/issues/answer-ranking/index.html": {
        "path": "Products/Engineering/Model/Issues/Answer ranking",
        "title": "Answer ranking",
        "content": "Ranks collection or something like this. Simple way - update rank - long. More advanced way - use some external mechanism and pull data during generation. Origin model/engineering.yml 23:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/answer-ranking Target Model Workable"
    },
    "modules/engineering/modules/model/Event.html": {
        "path": "Products/Engineering/Model/Event",
        "title": "Event",
        "content": "org.nasdanika.engineering.Event Event is a named temporal. Usage scenario: Define an empty event, e.g. \u201cProject start\u201d or \u201cSecond round of funding\u201d. Define other temporals, e.g. phase starts relative to the event. Generated Web UI will show start/end relative to the event date. Once the event absolute or relative date in known, enter it to the model. Generated Web UI will show absolute dates or dates relative to the event root base. Supertypes NamedElement Temporal"
    },
    "modules/engineering/modules/model/journey/package-summary.html": {
        "path": "Products/Engineering/Model/Journey",
        "title": "Journey",
        "content": "Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.engineering\\model\\doc\\journey\\package-summary.md (The system cannot find the file specified)"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Form.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Form",
        "title": "Form",
        "content": "org.nasdanika.html.model.bootstrap.Form"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/TextTransform.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/TextTransform",
        "title": "TextTransform",
        "content": "org.nasdanika.html.bootstrap.Text.Transform Uses Text"
    },
    "increments/2022/children/Q4/children/oct/index.html": {
        "path": "Increments/2022/Q4/October",
        "title": "October",
        "content": "Origin engineering/nasdanika.yml 150:13 Uri engineering://nasdanika/increments/2022/children/Q4/children/oct Start Oct 1, 2022 End Nov 1, 2022 Duration 31 days"
    },
    "issue-statuses/cancelled/index.html": {
        "path": "Issue/Statuses/Cancelled",
        "title": "Cancelled",
        "content": "Origin engineering/nasdanika.yml 59:5 Uri engineering://nasdanika/issue-statuses/cancelled"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/index.html": {
        "path": "Products/HTML/Models/Bootstrap/Model",
        "title": "Model",
        "content": "Model of Bootstrap elements. Origin model/bootstrap/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/bootstrap/modules/model Dependencies Bootstrap Model Dependants Generation Adapters Model"
    },
    "modules/html/modules/emf/issues/search/index.html": {
        "path": "Products/HTML/EMF/Issues/Search functionality",
        "title": "Search functionality",
        "content": "Pluggable - some context service for indexing, search functionality in the navigation tree - default (node text) and custom - full text. Lunrjs implementation. Minisearch is also an option. One possibility is to add search configuration to Action, e.g. searchFields String->String map - this may have a problem with unavailability of all text because it may be generated or loaded at a later time. So, maybe scanning the generated pages, parsing them with Jsoup and extracting text from nsd-app-content-panel-content-row and title from nsd-app-content-panel-title or nsd-app-content-panel-title-and-items-row > col > h1 is the way to go. Generate search index and store it in the root similar to sitemap.xml. Perhaps ignore Javadoc initially. Origin emf/engineering.yml 17:5 Uri engineering://nasdanika/modules/html/modules/emf/issues/search Target EMF Workable"
    },
    "modules/core/modules/flow/issues/critical-path/index.html": {
        "path": "Products/Core/Flow/Issues/Critical path",
        "title": "Critical path",
        "content": "Computation. Probability/frequency/distribution. Visualization - arrow width, thick border. Origin flow/engineering/engineering.yml 113:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/critical-path Target Flow Workable"
    },
    "modules/engineering/modules/model/journey/Activity.html": {
        "path": "Products/Engineering/Model/Journey/Activity",
        "title": "Activity",
        "content": "org.nasdanika.engineering.journey.Activity Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.engineering\\model\\doc\\flow\\activity.md (The system cannot find the path specified) Supertypes Activity<Activity> Referrers Engineer Uses Activity"
    },
    "modules/html/modules/models/modules/bootstrap/modules/gen/index.html": {
        "path": "Products/HTML/Models/Bootstrap/Generation Adapters",
        "title": "Generation Adapters",
        "content": "Origin model/bootstrap.gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/bootstrap/modules/gen Dependencies Model Generation Adapters Bootstrap Dependants Generation Adapters"
    },
    "increments/2021/index.html": {
        "path": "Increments/2021",
        "title": "2021",
        "content": "Origin engineering/nasdanika.yml 69:5 Uri engineering://nasdanika/increments/2021 Start Jan 1, 2021 End Jan 1, 2022 Duration 365 days"
    },
    "principles.html": {
        "title": "Principles",
        "content": "Stateful objects shall be modeled in ECore Single-page Applications"
    },
    "modules/engineering/modules/gen/issues/engineer-activity/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Engineer activity",
        "title": "Engineer activity",
        "content": "Messages, notes, issues (assignments). Filtering - date range, increments. Use for plans, e.g. what's next and progress reports - what has been done. Origin gen/engineering.yml 50:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/engineer-activity Target Generation Adapters Workable"
    },
    "modules/core/modules/flow/OutputPin.html": {
        "path": "Products/Core/Flow/OutputPin",
        "title": "OutputPin",
        "content": "org.nasdanika.flow.OutputPin Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\output-pin.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/html/modules/ecore/issues/action-template/index.html": {
        "path": "Products/HTML/Ecore/Issues/Action template",
        "title": "Action template",
        "content": "Annnotation to load documentation action from a template, e.g. YAML or XML, instead of creating with a factory. The action will then be populated as usual. This would allow to, say, have engineering issues at model element level. Origin ecore/engineering.yml 13:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/action-template Target Ecore Workable"
    },
    "modules/core/modules/emf/issues/type-selectors/index.html": {
        "path": "Products/Core/EMF/Issues/Type selectors",
        "title": "Type selectors",
        "content": "Currently homogenous reference type can be selected based on configuration type - map, list, ... Extend this capability to allow to introspect config and select element type based on config content, not just type. For example, if issue config map has github-issue key then instead of Issue an instance of GitHubIssue shall be created. One way is to keep the existing functionality for type mapping and add selector type key with value of a list for a single entry map. List elements would be maps with config-type (map, ...), element-type (EClass - string or map with EPackage and Eclass names), and selector or different selectors which can be jxpath (https://commons.apache.org/proper/commons-jxpath/), JavaScript, etc. For GitHubIssue it would be something like { config-type: map; element-type: GitHubIssue; path: } Origin emf/engineering.yml 18:7 Uri engineering://nasdanika/modules/core/modules/emf/issues/type-selectors Target EMF Workable"
    },
    "modules/core/modules/flow/issues/change-comment/index.html": {
        "path": "Products/Core/Flow/Issues/Change comment",
        "title": "Change comment",
        "content": "Add support for providing a reason for adding/suppressing/overriding package elements. Generate a changelog. Origin flow/engineering/engineering.yml 79:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/change-comment Target Flow Workable"
    },
    "modules/core/modules/diagram/modules/gen/issues/plant-uml-layout/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Use PlantUML to layout",
        "title": "Use PlantUML to layout",
        "content": "Generate PlantUML diagram, parse image map and use to position and size diagram element rectangles, if parsing is successful. After that apply sizes from styles and if there were sizes from styles and they were larger than PlantUML sizes then layout so there is no overlap. Use the existing algorithm to move overlapping resized rectangle from the center of union of all rectangles. Pass initial delta between the center points of the union rectangle and the rectangle to be positioned to the generator factory - it will define initial radius and angle. An advanced implementation may be some kind of of a force algorithm where positioning iteration goes over an increase from the force equilibrium - offset generator may compute a certain amount of positions (e.g. 1000 or 10000), compute force for each point, sort them and then return in the order of increasing energy - difference from the equilibrium where the force is zero. For border rectangles such as entry/exit points - reposition proportionally to keep them on the border. Origin diagram.gen/engineering.yml 10:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/plant-uml-layout Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generators Workable"
    },
    "increments/2022/children/Q2/children/may/index.html": {
        "path": "Increments/2022/Q2/May",
        "title": "May",
        "content": "Origin engineering/nasdanika.yml 120:13 Uri engineering://nasdanika/increments/2022/children/Q2/children/may Start May 1, 2022 End Jun 1, 2022 Duration 31 days"
    },
    "modules/core/modules/exec/modules/model/issues/includes/index.html": {
        "path": "Products/Core/Exec/Model/Issues/Includes",
        "title": "Includes",
        "content": "Fenced blocks for includes similar to Interpolator - include, include-markdown. No need in include-styled-markdown. Handle include-markdown not as tokens but by actually including markdown, include recursively. Origin exec/engineering.yml 8:5 Uri engineering://nasdanika/modules/core/modules/exec/modules/model/issues/includes Target Model Workable"
    },
    "modules/core/modules/mxgraph/index.html": {
        "path": "Products/Core/mxgraph",
        "title": "mxgraph",
        "content": "Origin mxgraph/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/mxgraph Dependants Generators"
    },
    "modules/core/modules/exec/modules/model/resources/File.html": {
        "path": "Products/Core/Exec/Model/Resources/File",
        "title": "File",
        "content": "org.nasdanika.exec.resources.File File is a named container of binary contents (bytes) which can be set and retrieved as an input stream. Example resources-container:\n  name: my-container\n  contents:\n    - resources-file:\n        name: my-file.txt\n        contents:\n          content-text: Hello, World!\n Supertypes Resource Uses Container"
    },
    "issue-statuses/in-progress/index.html": {
        "path": "Issue/Statuses/In Progress",
        "title": "In Progress",
        "content": "Origin engineering/nasdanika.yml 54:5 Uri engineering://nasdanika/issue-statuses/in-progress"
    },
    "modules/engineering/issues/branch-progress/index.html": {
        "path": "Products/Engineering/Issues/Branch progress",
        "title": "Branch progress",
        "content": "Add to features - branch progress, e.g. feature branch - earned but not yet released value/benefit. Origin engineering.yml 20:6 Uri engineering://nasdanika/modules/engineering/issues/branch-progress Target Engineering Workable"
    },
    "modules/core/modules/flow/End.html": {
        "path": "Products/Core/Flow/End",
        "title": "End",
        "content": "org.nasdanika.flow.End Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\end.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "increments/2022/children/Q2/children/apr/index.html": {
        "path": "Increments/2022/Q2/April",
        "title": "April",
        "content": "Origin engineering/nasdanika.yml 116:13 Uri engineering://nasdanika/increments/2022/children/Q2/children/apr Start Apr 1, 2022 End May 1, 2022 Duration 30 days"
    },
    "modules/core/modules/flow/features/visualizations/index.html": {
        "path": "Products/Core/Flow/Features/Visualizations",
        "title": "Visualizations",
        "content": "Origin flow/engineering/engineering.yml 15:5 Uri engineering://nasdanika/modules/core/modules/flow/features/visualizations PlantUML and Draw.io. TODO - how to configure representations and how to edit Draw.io diagrams - where to place."
    },
    "modules/engineering/modules/model/issues/increment-matching/index.html": {
        "path": "Products/Engineering/Model/Issues/Increment matching",
        "title": "Increment matching",
        "content": "Defined at either engineer or increment level. Options - explicit/none - endeavor must specify increment, validation of end or overlap, start, end, duration (shall fit into the increment for the entire duration). Explicit assignment overrides matching - can be used for endeavors spanning several increments and perhaps not matching any. E.g. a long running feature spanning two or more years. Origin model/engineering.yml 17:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/increment-matching Target Model Workable"
    },
    "modules/core/modules/emf/issues/homogenous-to-typed/index.html": {
        "path": "Products/Core/EMF/Issues/Homogenous to typed",
        "title": "Homogenous to typed",
        "content": "With introduction of type maps and type selectors homogenous became a misnomer. Drop \"homogenous\" in favor of \"typed\" with default value true and change homogenous=true to typed=false annotation. Typed would mean that the type shall be explicitly provided by elements and false would mean that it will be computed from reference type and type map/selector annotations. Or use reference-type annotation with string value \"reference\" indicating that type shall be taking from EReference - the same as homogenous. Replace isHomogenous with isTyped (with negation). Origin emf/engineering.yml 28:7 Uri engineering://nasdanika/modules/core/modules/emf/issues/homogenous-to-typed Target EMF Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Div.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Div",
        "title": "Div",
        "content": "org.nasdanika.html.model.bootstrap.Div HTML DIV with bootstrap styling Supertypes Tag Subtypes ActionGroup Alert Badge Button Card Carousel Slide"
    },
    "modules/html/modules/flow/issues/generation-api/index.html": {
        "path": "Products/HTML/Flow/Issues/Generation API",
        "title": "Generation API",
        "content": "Convert unit tests into a generation API in the main codebase and documentation. Consider also Maven plug-in and CLI. Origin flow/engineering.yml 8:5 Uri engineering://nasdanika/modules/html/modules/flow/issues/generation-api Target Flow Workable"
    },
    "increments/2022/children/Q2/index.html": {
        "path": "Increments/2022/Q2",
        "title": "Q2",
        "content": "Origin engineering/nasdanika.yml 111:9 Uri engineering://nasdanika/increments/2022/children/Q2 Start Apr 1, 2022 End Jul 1, 2022 Duration 91 days"
    },
    "issue-priorities.html": {
        "path": "Issue/Priorities",
        "title": "Priorities",
        "content": "Low Medium High"
    },
    "modules/core/modules/ncore/MapProperty.html": {
        "path": "Products/Core/Ncore/MapProperty",
        "title": "MapProperty",
        "content": "org.nasdanika.ncore.MapProperty Supertypes Property Map"
    },
    "modules/html/modules/models/modules/html/modules/gen/index.html": {
        "path": "Products/HTML/Models/HTML/Generation Adapters",
        "title": "Generation Adapters",
        "content": "Origin model/html.gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/html/modules/gen Dependencies Model HTML Generation Adapters Dependants Generation Adapters"
    },
    "modules/togaf/index.html": {
        "path": "Products/TOGAF",
        "title": "TOGAF",
        "content": "Origin engineering.yml 1:1 Uri engineering://nasdanika/modules/togaf"
    },
    "modules/core/modules/flow/Fork.html": {
        "path": "Products/Core/Flow/Fork",
        "title": "Fork",
        "content": "org.nasdanika.flow.Fork Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\fork.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/engineering/modules/model/issues/relative-dates-feature/index.html": {
        "path": "Products/Engineering/Model/Issues/Relative dates feature",
        "title": "Relative dates feature",
        "content": "Create a feature explaining relative dates (temporals), bounds, and validations. Origin model/engineering.yml 11:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/relative-dates-feature Target Model Workable"
    },
    "modules/togaf/modules/adm/issues/engineering-link/index.html": {
        "path": "Products/TOGAF/ADM/Issues/Engineering Link",
        "title": "Engineering Link",
        "content": "Link to the NSD TOGAF Engineering product on the NSD site. On the eng. site mention that created with NSD Flow. In readme link to eng, generated doc, and flow. Origin adm/engineering.yml 5:5 Uri engineering://nasdanika/modules/togaf/modules/adm/issues/engineering-link Target ADM Workable"
    },
    "increments/2022/children/Q4/children/dec/index.html": {
        "path": "Increments/2022/Q4/December",
        "title": "December",
        "content": "Origin engineering/nasdanika.yml 158:13 Uri engineering://nasdanika/increments/2022/children/Q4/children/dec Start Dec 1, 2022 End Jan 1, 2023 Duration 31 days"
    },
    "modules/core/modules/mxgraph/issues/bundle-resources/index.html": {
        "path": "Products/Core/mxgraph/Issues/Bundle resources",
        "title": "Bundle resources",
        "content": "Modify pom.xml to include non-java files from the source folder - take a look at git history for model projects. Will need to modify version, e.g. 4.2.2.1 or 4.2.2-a Origin mxgraph/engineering.yml 5:5 Uri engineering://nasdanika/modules/core/modules/mxgraph/issues/bundle-resources Target mxgraph Workable"
    },
    "modules/core/modules/flow/issues/in-browser-editing/index.html": {
        "path": "Products/Core/Flow/Issues/In-browsing editing feature",
        "title": "In-browsing editing feature",
        "content": "Collaboration, inner source. Create pull request. Related to Data Provenance. Origin flow/engineering/engineering.yml 110:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/in-browser-editing Target Flow Workable"
    },
    "modules/core/modules/common/features/execution-model/index.html": {
        "path": "Products/Core/Common/Features/Execution Model",
        "title": "Execution Model",
        "content": "Origin common/engineering/engineering.yml 6:5 Uri engineering://nasdanika/modules/core/modules/common/features/execution-model This page explains the Nasdanika execution model, which is used by a number of Nasdanika products and modules, e.g. Exec. The execution process consists of the following steps: Create a participant factory (org.nasdanika.common.ExecutionParticipantFactory). Factories can be composed as explained in the subsequent sections. Create an instance of org.nasdanika.common.Context. Pass the context to the factory create() method to create a participant. Create an instance of org.nasdanika.common.ProgressMonitor. Walk the participant through the lifecycle methods. All lifecycle methods except execute() have the same signature for all paricipant types. diagnose() - performs diagnostic of the participant configuration and returns org.nasdanika.common.Diagnostic. If the diagnostic status is ERROR further execution is aborted. Diagnose may prepare the participant for further execution by initializing internal structures, e.g. resolving URL\u2019s. However, this method shall not perform any modifications in resources which might have to be rolled back, e.g. it shall not create or delete files or database records. The default implementation returns status SUCCESS. execute() - Executes participant\u2019s logic. May modify resources, e.g. write to files, create database records. Different participant types have different signatures of this method. There is no default implementation for this method. commit() - Commits changes performed by execute() if all execution participants were executed successfully, i.e. without throwing an exception. The default implementation does nothing. rollback() - Rolls back changes performed by execute() if some other participant executed after this one has thrown an exception. Returns boolean value indicating whether rollback was successful or not. The default implementation does nothing and returns true. close() - Releases any resources used during execution. E.g. closes database connections, shuts down executor pulls. Overrides close() in java.lang.AutoCloseable so participants can be used in try-with-resources. The default implementation does nothing. Execution participant types org.nasdanika.common.Supplier<T> - T execute(ProgressMonitor) - returns value. org.nasdanika.common.Function<T,R> - R execute(T,ProgressMonitor) - takes an argument and returns value. org.nasdanika.common.Consumer<T> - void execute(T,ProgressMonitor) - takes an argument, does not return value. org.nasdanika.common.Command - void execute(ProgressMonitor) Composition Execution participants can be composed using subclasses of org.nasdanika.common.CompoundExecutionParticipant. Result producing participants - suppliers and functions - can be composed as lists or maps. Consumers can be composed as list and maps. Commands are always composed as lists. Chaining Result producing participants (supplier and function) and their factories have then method which takes value-consuming participant (function or consumer) and returns a participant (or a factory for such a participant) which executes the first participant, takes the returned value and passes it to the second participant. The participants can be chained as follows: Supplier<T>.then(Function<? super T,R>) -> Supplier<R> Supplier<T>.then(Consumer<? super T>) -> Command Function<T,R>.then(Function<? super R,V>) -> Function<T,V> Function<T,R>.then(Consumer<? super R>) -> Consumer<T> asFunction Suppler and Consumer have asFunction methods and their factories have asFunctionFactory methods to allow chaining of supplier and consumer execution. For suppliers asFunction method returns org.nasdanika.common.BiSupplier with the function argument available via getFirst() method and the supplier result via getSecond(). For consumers asFunction creates a pass-through function which executes the consumer and then returns its argument. Contextification Contextification is a form of chaining of execution participant factories where the first factory is a SupplierFactory<Context>. Context returned by the first factory\u2019s supplier is passed to the execution participant created by the second factory. Contextification is done using contextify() method of execution participant factories. Bridging to java.util.function Execution participants have static fromXXX methods for constructing from objects implementing java.util.function interfaces, e.g. java.util.function.Function. Utility methods org.nasdanika.common.Util class contains methods for walking execution participants through their lifecycle (call methods) as well as helper execution participant factories. Client code Client code shall walk the top-level execution participant through the lifecycle methods. Composition and chaining classes methods take care of invoking lifecycle methods of their constituents. The below code snippet shows how to call Supplier: Context context = ...;\t\t\nSupplierFactory<InputStream> supplierFactory = ...;\nProgressMonitor monitor = ...;\n\ntry (Supplier<InputStream> supplier = supplierFactory.create(context); ProgressMonitor progressMonitor = monitor.split(\"Calling \" + supplier.name(), 3 * supplier.size())) {\n\tDiagnostic diagnostic = supplier.splitAndDiagnose(progressMonitor);\n\tif (diagnostic.getStatus() == Status.ERROR) {\n\t\t// Handle diagnostic error - dump to console or log, throw an exception or return error code or status.\n\t\tdiagnostic.dump(System.err, 4);\n\t\t// Calling JUnit.fail() here\n\t\tfail(\"Supplier diagnostic failed: \" + diagnostic.getMessage());\n\t}\n\t\t\t\n\ttry {\n\t\tInputStream result = supplier.splitAndExecute(progressMonitor);\n\t\t// process result here\n\t\t...\n\t\tsupplier.splitAndCommit(progressMonitor);\t\t\t\t\t\t\n\t} catch (Exception e) {\n\t\t// Rollback and handle exception. \n\t\t// In some cases diagnostic exception may be thrown during execution.\n\t\tif (e instanceof DiagnosticException) {\n\t\t\t((DiagnosticException) e).getDiagnostic().dump(System.err, 4);\n\t\t}\n\t\tif (supplier.splitAndRollback(progressMonitor)) {\n\t\t\tfail(\"Exception \" + e + \", rollback successful\");\n\t\t} else {\n\t\t\t// Automated cleanup failed - perhaps notify somebody/something to performs manual/external cleanup\n\t\t\tfail(\"Exception \" + e + \", rollback failed\");\t\t\t\t\t\t\n\t\t}\n\t}\n}"
    },
    "modules/core/modules/flow/issues/style-inheritance-from-templates/index.html": {
        "path": "Products/Core/Flow/Issues/Artifact inheritance of representation properties from templates",
        "title": "Artifact inheritance of representation properties from templates",
        "content": "Cascading inheritance, merging of properties. Would allow to define a library of artifact templates (building blocks) and assemble composite artifacts from them. E.g. cloud components - storage, compute, cache, networking. Generated diagrams would have styles like images readily available. Origin flow/engineering/engineering.yml 52:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/style-inheritance-from-templates Target Flow Workable"
    },
    "personas.html": {
        "title": "Personas",
        "content": "Java Developer"
    },
    "modules/core/modules/exec/modules/gen/issues/include-base/index.html": {
        "path": "Products/Core/Exec/Generation Adapters/Issues/Include base",
        "title": "Include base",
        "content": "Base shall be resolved relative to the target resource or marker. Use marker first. Origin exec.gen/engineering.yml 11:5 Uri engineering://nasdanika/modules/core/modules/exec/modules/gen/issues/include-base Target Generation Adapters Workable"
    },
    "modules/engineering/issues/skills-and-technologies/index.html": {
        "path": "Products/Engineering/Issues/Skills and Technologies",
        "title": "Skills and Technologies",
        "content": "Engineers have skills which may reference technologies and have level. Projects use technologies. Trees for both skills and technologies. Maybe not skills, but expertise - can be with technologies or other things such as engineered elements - modules, products. Origin engineering.yml 24:6 Uri engineering://nasdanika/modules/engineering/issues/skills-and-technologies Target Engineering Workable"
    },
    "issue-priorities/medium/index.html": {
        "path": "Issue/Priorities/Medium",
        "title": "Medium",
        "content": "Origin engineering/nasdanika.yml 38:5 Uri engineering://nasdanika/issue-priorities/medium"
    },
    "modules/html/modules/models/modules/bootstrap/index.html": {
        "path": "Products/HTML/Models/Bootstrap",
        "title": "Bootstrap",
        "content": "Origin model/engineering.yml 11:5 Uri engineering://nasdanika/modules/html/modules/models/modules/bootstrap"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/inheritance/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/Ability to inherit action hierarchies and override specific actions",
        "title": "Ability to inherit action hierarchies and override specific actions",
        "content": "Override by ID. Children will have to be derived and will need \"ownChildren\" reference with \"children\" load key. Origin model/app/engineering.yml 13:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/inheritance Target Model Workable"
    },
    "modules/core/modules/emf/issues/default-features-with-e-keys/index.html": {
        "path": "Products/Core/EMF/Issues/Add support of default features with e-keys",
        "title": "Add support of default features with e-keys",
        "content": "ReferenceList. Implemented for homogenous - needs to be tested, implement for heterogenous. Origin emf/engineering.yml 15:7 Uri engineering://nasdanika/modules/core/modules/emf/issues/default-features-with-e-keys Target EMF Workable"
    },
    "modules/core/modules/flow/features/validation/index.html": {
        "path": "Products/Core/Flow/Features/Validation",
        "title": "Validation",
        "content": "Origin flow/engineering/engineering.yml 43:5 Uri engineering://nasdanika/modules/core/modules/flow/features/validation"
    },
    "modules/core/modules/flow/issues/builders/index.html": {
        "path": "Products/Core/Flow/Issues/Builders",
        "title": "Builders",
        "content": "A list of EObjects adapted to Consumer and invoked in apply(). Context and progress monitor, apply and createInstance either throws Exception or wraps it maybe in ConfigurationException and injects builder's marker. InterpolatingBuilder - interpolates tokens in features. Own properties, flag to chain with context and path. Features to interpolate - all String features by default. CallBuilder - similar to Call in Exec, possibly extract common functionality to Ncore or use Call as-is - shall be adaptable to consumer then. Origin flow/engineering/engineering.yml 88:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/builders Target Flow Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/InputGroup.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/InputGroup",
        "title": "InputGroup",
        "content": "org.nasdanika.html.model.bootstrap.InputGroup"
    },
    "modules/core/modules/diagram/modules/model/End.html": {
        "path": "Products/Core/Diagram/Model/End",
        "title": "End",
        "content": "org.nasdanika.diagram.End End pseudo-state. Supertypes DiagramElement"
    },
    "modules/core/modules/diagram/modules/gen/issues/support-mermaid-js/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Add support of Mermaid-js",
        "title": "Add support of Mermaid-js",
        "content": "https://mermaid-js.github.io/mermaid/#/, Specifically add support of user journey diagram to use in flows - https://mermaid-js.github.io/mermaid/#/user-journey. Sentiment value and participants from properties or element description. Origin diagram.gen/engineering.yml 49:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/support-mermaid-js Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generators Workable"
    },
    "modules/html/modules/models/modules/html/modules/model/index.html": {
        "path": "Products/HTML/Models/HTML/Model",
        "title": "Model",
        "content": "HTML model Origin model/html/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/html/modules/model Dependencies HTML Exec Dependants Generation Adapters Model"
    },
    "modules/core/modules/flow/issues/model-documentation/index.html": {
        "path": "Products/Core/Flow/Issues/Fully document the model",
        "title": "Fully document the model",
        "content": "Link to this file - template-action. Origin flow/engineering/engineering.yml 57:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/model-documentation Increment December Target Flow Workable"
    },
    "modules/html/modules/models/modules/app/modules/gen/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters",
        "title": "Generation Adapters",
        "content": "Origin model/app.gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen Dependencies Model Generation Adapters jsTree"
    },
    "modules/core/modules/flow/EntryPoint.html": {
        "path": "Products/Core/Flow/EntryPoint",
        "title": "EntryPoint",
        "content": "org.nasdanika.flow.EntryPoint Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\entry-point.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/engineering/modules/gen/index.html": {
        "path": "Products/Engineering/Generation Adapters",
        "title": "Generation Adapters",
        "content": "Origin gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/engineering/modules/gen Dependencies Model Flow"
    },
    "modules/core/modules/common/features.html": {
        "path": "Products/Core/Common/Features",
        "title": "Features",
        "content": "Execution Model"
    },
    "modules/engineering/modules/gen/issues/git-marker-message-enrichment/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/GitMarker Message Enrichment",
        "title": "GitMarker Message Enrichment",
        "content": "Enrhich topic messages and topics themselves with GitMarker information - author, date if not set. May not work correctly with pull requests - need to check - maybe author remains and only committer changes. Origin gen/engineering.yml 47:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/git-marker-message-enrichment Target Generation Adapters Workable"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/carousel-section-style/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/Carousel section style",
        "title": "Carousel section style",
        "content": "Origin model/app/engineering.yml 8:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/carousel-section-style Target Model Workable"
    },
    "modules/core/modules/common/index.html": {
        "path": "Products/Core/Common",
        "title": "Common",
        "content": "Origin common/engineering/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/common Dependants CLI Ncore HTML"
    },
    "modules/core/modules/ncore/issues/action-prototype/index.html": {
        "path": "Products/Core/Ncore/Issues/Action prototype",
        "title": "Action prototype",
        "content": "ModelElement action prototype reference. If set and is Action then the action would be copied and then populated. If set and is not action, then adapted to ActionProvider. If not set, then an new action is created using AppFactory. This allows to merge actions generated by other tools or manually authored. E.g. ecore documentation actions or actions referencing ecore documentation. Origin ncore/engineering.yml 29:5 Uri engineering://nasdanika/modules/core/modules/ncore/issues/action-prototype Available Completion 100% Releases 2021.12.2 Status Done Target Ncore Workable"
    },
    "modules/core/modules/diagram/modules/gen/index.html": {
        "path": "Products/Core/Diagram/Generators",
        "title": "Generators",
        "content": "Origin diagram.gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen Dependencies Model mxgraph Model Dependants Flow"
    },
    "modules/engineering/modules/gen/issues/rest-api/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/REST API",
        "title": "REST API",
        "content": "Generate static cross-refrencing JSON files which can be used for programmatic access by, say, single-page applications. For example, an issues table with filtering and sorting or by charts. May also generate a JavaScript API on top of the JSON \"dumb\" data - read-only properties returning promises. Ideally, the JSON should be loadable back to the model. Also may publish XMI at the root of the generated site - an alternative to Maven repository. Origin gen/engineering.yml 18:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/rest-api Target Generation Adapters Workable"
    },
    "modules/core/modules/flow/issues/inputs-outputs-validation/index.html": {
        "path": "Products/Core/Flow/Issues/Inputs/Outputs validation",
        "title": "Inputs/Outputs validation",
        "content": "If both element and transitions/calls specify artifacts - input, output, payload, response - then validate consistency, e.g. that transition payload is in the list of activity output artifacts. Take resources into account which serve as artifact repositories. The goal is to catch situations when input artifacts appear from nowhere - don't come through inputs or call responses and cannot be retrieved from repository resorces. For output artifacts - make sure that an artifact does not disappear - it shall either be listed as a payload of a call or transition, or stored into a repository resource. Origin flow/engineering/engineering.yml 82:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/inputs-outputs-validation Target Flow Workable"
    },
    "increments/2022/children/Q3/children/aug/index.html": {
        "path": "Increments/2022/Q3/August",
        "title": "August",
        "content": "Origin engineering/nasdanika.yml 137:13 Uri engineering://nasdanika/increments/2022/children/Q3/children/aug Start Aug 1, 2022 End Sep 1, 2022 Duration 31 days"
    },
    "modules/core/modules/flow/issues/durations/index.html": {
        "path": "Products/Core/Flow/Issues/Durations",
        "title": "Durations",
        "content": "Activity and transition durations. Create DurationProbability class extending Duration in Flow, or just Duration with weight. Weight default value is 1. For flows without explicitly provided durations compute durations from elements. For a low number of permutations use all permutations, for a high use something like Monte Carlo method. In both cases computed results can be grouped into \"slices\" with different weights. Number of computed durations is an attribute with default value, say 10 or 20. Slicing may use the same weight for slices with a large number of samples and make the number of samples equal in each slice. For the tails of distribution and outliers it would use lower weights. The number of simulations to run shall be configurable via flow attribute(s). Options - total number, absolute, relative number - computed from the number of elements, time bound - no more than, say, 10 seconds, combination of thereof, e.g. no more than 10 seconds, but at least 1000 iterations even if it takes more than 10 seconds. Create a feature explaining how it works and how to use it. getDuration(double) method returning duration for a number between 0 and 1 - sum all weights, find an entry which the argument \"falls in\" and return it - running weight (sum) previous is lower, next is higher or there is no next (1). For a single element simply return its duration. Transition type - end-to-start (default), the other 3. Not applicable to calls - may have a diagnostic or throw an error if used on calls. Consider adding support of Duration Observation - value, when, maybe description. Derive distribution from observations if no durations were specified. Consider using some weight scale based on how far in the past, i.e. recent observations have more weight. Maybe a generic observation in Flow or Ncore model which may have individual named metrics - duration, sentiment (rating). Metrics may have individual comments. Observations may be captured in some system using, say, URI as a correlation id, and then be \"injected\" into the model during load. Then clear feature cache. Clear it on any mutation or have some dependency thing to know which mutations clear which cached feature - annotation, say \"depends\"? Origin flow/engineering/engineering.yml 94:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/durations Target Flow Workable"
    },
    "modules/core/modules/flow/features/inheritance/index.html": {
        "path": "Products/Core/Flow/Features/Inheritance",
        "title": "Inheritance",
        "content": "Origin flow/engineering/engineering.yml 22:5 Uri engineering://nasdanika/modules/core/modules/flow/features/inheritance Nasdanika Flow supports package multiple inheritance, i.e. a package may extend one or more other packages. Flow inheritance can be useful in hierarchies such as organizational hierarchies and technology hierarchies. In an organizational hierarchy higher levels can define generic processes and specify which elements can be customized at lower levels and which cannot - final elements. Lower levels of the organization would customize what they need to their specifics, e.g. local regulations. Similar to that, in the world of technology one can define, say, a generic flow explaining how to develop and deploy a SpringBoot microservice. Then that flow can be customized to different ways to deploy, e.g. different cloud providers - private and public, and their offerings. For example, a package containing flows for agile software development using a particular technology, say SpringBoot on AWS, may extends a package containing generic agile flows as well as a package containing AWS-specific flows and other element which are agnostic to a particular development methodology. Extension packages may: * Add elements. * Override elements - replace definitions. * Suppress (remove) elements. This is similar to inheritance in object-oriented languages like lava where subclasses can add and override inherited methods. Method suppression is not available in lava. Similar to Java, elements can be defined as final and abstract - final elements cannot be overridden, and abstract elements must be overridden. For example, there might be an abstract flow for developing a cloud application with concrete elements which are common for different cloud providers and abstract elements which are provider or technology specific. Flow inheritance is also similar to basing Docker images on other images using FRROM, but with support of \u201cmix-in\u201d images with multiple inheritance. Inheritance allows multiple teams to incrementally build a \u201cwhole end-to-end picture\u201d for flow participants. Example AWS Agile Development extends Core Agile Development."
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Theme.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Theme",
        "title": "Theme",
        "content": "org.nasdanika.html.bootstrap.Theme Uses Page"
    },
    "modules/core/modules/emf/issues/multiple-e-keys/index.html": {
        "path": "Products/Core/EMF/Issues/Add support of multiple e-keys",
        "title": "Add support of multiple e-keys",
        "content": "ReferenceList - 98. Nested maps. Origin emf/engineering.yml 12:7 Uri engineering://nasdanika/modules/core/modules/emf/issues/multiple-e-keys Target EMF Workable"
    },
    "modules/html/modules/ecore/issues/action-template-annotation/index.html": {
        "path": "Products/HTML/Ecore/Issues/Action template annotation - location of an action resource to load a template from instead of using AppFactory.createAction(). Would allow to merge, say, navigation actions.",
        "title": "Action template annotation - location of an action resource to load a template from instead of using AppFactory.createAction(). Would allow to merge, say, navigation actions.",
        "content": "Origin ecore/engineering.yml 29:5 Uri engineering://nasdanika/modules/html/modules/ecore/issues/action-template-annotation Target Ecore Workable"
    },
    "modules/core/modules/exec/modules/gen/index.html": {
        "path": "Products/Core/Exec/Generation Adapters",
        "title": "Generation Adapters",
        "content": "Origin exec.gen/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/exec/modules/gen Dependencies Exec Dependants Flow Generation Adapters"
    },
    "modules/core/modules/common/issues/nsdiagram-dialect/index.html": {
        "path": "Products/Core/Common/Issues/Add support of nsdiagram dialect",
        "title": "Add support of nsdiagram dialect",
        "content": "Diagram YAML in a fenced block - might be easier to author in some cases than, say, PlantUML. As it will result in a circular dependency use a service or some other type of registration. A more radical way is to drop the enum altogether and switch to services. Origin common/engineering/engineering.yml 16:5 Uri engineering://nasdanika/modules/core/modules/common/issues/nsdiagram-dialect Target Common Workable"
    },
    "modules/html/modules/models/modules/app/index.html": {
        "path": "Products/HTML/Models/Application",
        "title": "Application",
        "content": "Origin model/engineering.yml 17:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app"
    },
    "modules/html/modules/html/index.html": {
        "path": "Products/HTML/HTML",
        "title": "HTML",
        "content": "Origin html/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/html Dependencies Common Dependants Bootstrap EMF jsTree Model Generation Adapters"
    },
    "principles/ecore-data/index.html": {
        "path": "Principles/Stateful objects shall be modeled in ECore",
        "title": "Stateful objects shall be modeled in ECore",
        "content": "Generation of documentation, validation, multiple source formats, multiple editors - tree, form, diagram, web-based. TODO - to Markdown, links to resources. Name/statement/rationale/implications. Origin engineering/nasdanika.yml 62:5 Uri engineering://nasdanika/principles/ecore-data"
    },
    "modules/core/modules/diagram/modules/gen/issues/drawio-customize-editor-url/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Customize drawio editor URL",
        "title": "Customize drawio editor URL",
        "content": "Ability to send to edit to a site other than diagrams.net Origin diagram.gen/engineering.yml 64:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/drawio-customize-editor-url Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generators Workable"
    },
    "objectives.html": {
        "title": "Objectives",
        "content": "Test Objective"
    },
    "modules/core/modules/ncore/issues/object-signing/index.html": {
        "path": "Products/Core/Ncore/Issues/Object signing",
        "title": "Object signing",
        "content": "Similar to code signing - during the load process digests are computed for objects and stored in the object if it implements Signed interface. For nested objects signatures are used in computing the container signature for contained objects which implement Signed. Signing is performed if the loading context provides Signer service. Object signing can be used in combination with markers to track and prove data provenance. Possibly use JWT - build a JSON Object, sign, get the signature and store in the object. Perhaps sign the root object and just compute hashes of contained objects. Origin ncore/engineering.yml 8:5 Uri engineering://nasdanika/modules/core/modules/ncore/issues/object-signing Target Ncore Workable"
    },
    "modules/html/modules/emf/issues/uri-copy-to-clipboard/index.html": {
        "path": "Products/HTML/EMF/Issues/URI copy to clipboard icon",
        "title": "URI copy to clipboard icon",
        "content": "navigator.clipboard.writeText(\"Australia\"); far fa-clipboard or far fa-copy as on GitHub. Use data-uri attribute? this.getAttribute('data-uri') Origin emf/engineering.yml 24:5 Uri engineering://nasdanika/modules/html/modules/emf/issues/uri-copy-to-clipboard Available Completion 100% Releases 2021.12.3 Status Done Target EMF Workable"
    },
    "modules/html/modules/flow/issues/unresolved-proxies/index.html": {
        "path": "Products/HTML/Flow/Issues/Unresolved proxies",
        "title": "Unresolved proxies",
        "content": "NPE at FlowStateDiagramGenerator.wire() in the grouping lambda because of unresolved proxy. Unresolved proxies shall be caught earlier in the pipeline. Origin flow/engineering.yml 12:5 Uri engineering://nasdanika/modules/html/modules/flow/issues/unresolved-proxies Target Flow Workable"
    },
    "modules/html/modules/models/index.html": {
        "path": "Products/HTML/Models",
        "title": "Models",
        "content": "Origin model/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models"
    },
    "modules/html/modules/emf/issues/uri-copy-to-clipboard-relative/index.html": {
        "path": "Products/HTML/EMF/Issues/Relative URI copy to clipboard",
        "title": "Relative URI copy to clipboard",
        "content": "Drop-down or a dialog with a base URI field to compute relative URI's. Use of relative URI's may be preferred in models which are intended to be reused and the root URI may change. Origin emf/engineering.yml 29:5 Uri engineering://nasdanika/modules/html/modules/emf/issues/uri-copy-to-clipboard-relative Target EMF Workable"
    },
    "modules/engineering/modules/model/issues/technology-stack/index.html": {
        "path": "Products/Engineering/Model/Issues/Technology Stack",
        "title": "Technology Stack",
        "content": "Containment reference in Engineer, similar to Domains, render in the navigation menu - idented table or a tree. Experts/expertise - a way track skills. Origin model/engineering.yml 31:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/technology-stack Target Model Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Tooltip.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Tooltip",
        "title": "Tooltip",
        "content": "org.nasdanika.html.model.bootstrap.Tooltip"
    },
    "increments/2022/index.html": {
        "path": "Increments/2022",
        "title": "2022",
        "content": "Origin engineering/nasdanika.yml 89:5 Uri engineering://nasdanika/increments/2022 Start Jan 1, 2022 End Jan 1, 2023 Duration 365 days"
    },
    "modules/html/modules/models/modules/bootstrap/modules/gen/issues/slide-captions/index.html": {
        "path": "Products/HTML/Models/Bootstrap/Generation Adapters/Issues/Carousel slide captions",
        "title": "Carousel slide captions",
        "content": "Origin model/bootstrap.gen/engineering.yml 10:6 Uri engineering://nasdanika/modules/html/modules/models/modules/bootstrap/modules/gen/issues/slide-captions Target Generation Adapters Workable"
    },
    "modules/core/issues/persistence-service/index.html": {
        "path": "Products/Core/Issues/Persistence Service",
        "title": "Persistence Service",
        "content": "A service for storing state by single-page applications generated from YAML models Likely a template/framework. Space (origin), reference/environment (branch, tag), containment path. REST API, backed by container. Container is configurable - file system, NO-SQL, Git, relational, ... MongoDB - JSON/Map entity container? Rating, analytics (page visits). SpringBoot, Waffle for windows authentication For file/git containers extension means file, e.g. something.yml. Ability to CRUD on internal pieces, e.g. something.json/mything Some kind of application-level auth - what an application can do, specified at generation time - JWT? Origin engineering.yml 34:5 Uri engineering://nasdanika/modules/core/issues/persistence-service Target Core Workable"
    },
    "modules/engineering/modules/model/journey/Journey.html": {
        "path": "Products/Engineering/Model/Journey/Journey",
        "title": "Journey",
        "content": "org.nasdanika.engineering.journey.Journey Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.engineering\\model\\doc\\flow\\journey.md (The system cannot find the path specified) Supertypes Flow"
    },
    "modules/core/modules/flow/issues/group-by/index.html": {
        "path": "Products/Core/Flow/Issues/Group-by",
        "title": "Group-by",
        "content": "Support of grouping by not only participants, but, say, responsible. Origin flow/engineering/engineering.yml 116:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/group-by Target Flow Workable"
    },
    "modules/core/modules/flow/Start.html": {
        "path": "Products/Core/Flow/Start",
        "title": "Start",
        "content": "org.nasdanika.flow.Start Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\start.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/core/modules/exec/index.html": {
        "path": "Products/Core/Exec",
        "title": "Exec",
        "content": "Origin engineering.yml 20:8 Uri engineering://nasdanika/modules/core/modules/exec Dependants Generation Adapters Model"
    },
    "increments/2022/children/Q1/children/jan/index.html": {
        "path": "Increments/2022/Q1/January",
        "title": "January",
        "content": "Origin engineering/nasdanika.yml 99:13 Uri engineering://nasdanika/increments/2022/children/Q1/children/jan Start Jan 1, 2022 End Feb 1, 2022 Duration 31 days"
    },
    "issue-severities/low/index.html": {
        "path": "Issue/Severities/Low",
        "title": "Low",
        "content": "Origin engineering/nasdanika.yml 49:5 Uri engineering://nasdanika/issue-severities/low"
    },
    "issue-severities.html": {
        "path": "Issue/Severities",
        "title": "Severities",
        "content": "Critical Major Medium Low"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/ListGroup.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/ListGroup",
        "title": "ListGroup",
        "content": "org.nasdanika.html.model.bootstrap.ListGroup"
    },
    "increments/2021/children/Q4/children/dec/objectives/test-objective/key-results/do-something/index.html": {
        "path": "Increments/2021/Q4/December/Objectives/Test Objective/Key Results/Do something",
        "title": "Do something",
        "content": "Origin engineering/nasdanika.yml 87:21 Uri engineering://nasdanika/increments/2021/children/Q4/children/dec/objectives/test-objective/key-results/do-something"
    },
    "modules/core/modules/flow/ExpansionInput.html": {
        "path": "Products/Core/Flow/ExpansionInput",
        "title": "ExpansionInput",
        "content": "org.nasdanika.flow.ExpansionInput Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\expansion-input.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/core/modules/flow/issues/categories/index.html": {
        "path": "Products/Core/Flow/Issues/Categories",
        "title": "Categories",
        "content": "Grouping mechanism, maybe have it in Ncore. A category is a named element with id (use uuid?). Elements have a list of categories. If it is not empty, elements may be grouped into categories with categories list being a (tree) path. Can be used to group service activities into \"domains\". Categorization does not affect URI's. Origin flow/engineering/engineering.yml 119:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/categories Target Flow Workable"
    },
    "modules/html/modules/models/modules/html/modules/model/Stylesheet.html": {
        "path": "Products/HTML/Models/HTML/Model/Stylesheet",
        "title": "Stylesheet",
        "content": "org.nasdanika.html.model.html.Stylesheet CSS stylesheet with code stored in the model element code attribute. Supertypes Filter"
    },
    "increments/2022/children/Q1/children/mar/index.html": {
        "path": "Increments/2022/Q1/March",
        "title": "March",
        "content": "Origin engineering/nasdanika.yml 107:13 Uri engineering://nasdanika/increments/2022/children/Q1/children/mar Start Mar 1, 2022 End Apr 1, 2022 Duration 30 days 23 hours"
    },
    "modules/core/modules/ncore/Adaptable.html": {
        "path": "Products/Core/Ncore/Adaptable",
        "title": "Adaptable",
        "content": "org.nasdanika.common.Adaptable Subtypes ModelElement"
    },
    "modules/engineering/modules/gen/issues/element-icons/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Element icons from action prototypes",
        "title": "Element icons from action prototypes",
        "content": "Update action providers to set an icon only if it is not already set by a prototype action. Origin gen/engineering.yml 59:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/element-icons Target Generation Adapters Workable"
    },
    "modules/html/modules/models/modules/app/modules/model/index.html": {
        "path": "Products/HTML/Models/Application/Model",
        "title": "Model",
        "content": "Application model. Origin model/app/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model Dependencies Model Dependants Generation Adapters Model"
    },
    "modules/engineering/modules/gen/issues/configurable-tables/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Configurable tables",
        "title": "Configurable tables",
        "content": "Sortable, filterable, pagination, column selection - remember in local storage. Consider using Vue, Knockout is obsolete - https://v3.vuejs.org/guide/introduction.html#getting-started Forms doc: https://vuejs.org/v2/guide/forms.html, https://bootstrap-vue.org/docs/components/form-checkbox, https://vuejs.org/v2/guide/events.html Form example: https://codepen.io/riix/pen/MeYogB https://codepen.io/zhaoqize/pen/JWGGrL, https://codepen.io/beyondverage0908/pen/ebWzYj https://codepen.io/pespantelis/pen/ojwgPB, see my modifications in vue.md https://www.raymondcamden.com/2018/02/08/building-table-sorting-and-pagination-in-vuejs Paginated table: https://codepen.io/cslinmiso/pen/pbqALW React is also an option, but Vue seems to be simpler: https://codesandbox.io/embed/table-sorting-example-ur2z9?fontsize=14&hidenavigation=1&theme=dark https://github.com/wenzhixin/bootstrap-table Make a reusable component? Or a method, say buildDynamicTable() similar to buildTable(). Table configuration also bordered, striped, condensed, etc. https://cdnjs.com/libraries/vue https://techformist.com/use-vue-from-url-simple-app/ https://cdn.jsdelivr.net/npm/vue@3.2.24 Also render data as either hidden text or static table for search indexing - configurable. Origin gen/engineering.yml 30:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/configurable-tables Target Generation Adapters Workable"
    },
    "issue-priorities/high/index.html": {
        "path": "Issue/Priorities/High",
        "title": "High",
        "content": "Origin engineering/nasdanika.yml 40:5 Uri engineering://nasdanika/issue-priorities/high"
    },
    "modules/core/modules/diagram/modules/gen/issues/drawio-diagram-processing/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Processing of Drawio diagrams",
        "title": "Processing of Drawio diagrams",
        "content": "For existing diagrams - loading, building a graph, passing it to a method which returns a graph - the same or a different. If returned graph is not null then its model gets encoded. Optionally replace the original file with the processed one if file URI. Default implementation iterates over all cells and passes them to a cell processing/filtering method. The cell processing method shall return boolean to indicate that the cell was changed. The graph processing method shall return the same graph if any of the cells were modified or null. URI processing - if a cell has uri attribute - resolve, set relative links. If there is style - merge. Element style overrides uri style entries. Size - boolean property to indicate that cell shall be resized if element at the URI specifies size. This approach would allow to create manual diagrams referencing existing model elements and have a consistent appearance of diagram elements across multiple diagrams. Also element look will be automatically updated on all diagrams if it changes. Sync boolean property in diagram elements and diagrams - if true the diagram (representation) and the element shall be updated when the backing model changes, e.g. label, or deleted if the element is not present in the model anymore. True by default, can be set to false by the modeler in the model (YAML) or in Drawio editor. URI is used for correlation. Perhaps sync may be a list of what should be synced with true meaning all, false nothing and a comma-separated list for fine-grained definitions. For example, it might be needed to update style if it was generated from the model and the model definition changed. One option of deling with style is to compute style digest during generation and store as a property. Update style only if the style was not changed since last generation, i.e. computed digest is the same as stored digest. In this case sync style would have some value e.g. sync=style=unmodified;label=true - i.e. sync style only if it was not changed manually and always update label. May use the same approach for label - label-digest (or hash) property. Users can force update of style or label by removing/clearing respective -hash property. One more aspect of processing is validation. E.g. validation of links, especially relative links. Origin diagram.gen/engineering.yml 21:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/drawio-diagram-processing Total cost 8.0 Effort 8.0 Remaining effort 8.0 Target Generators Workable"
    },
    "issue-priorities/low/index.html": {
        "path": "Issue/Priorities/Low",
        "title": "Low",
        "content": "Origin engineering/nasdanika.yml 36:5 Uri engineering://nasdanika/issue-priorities/low"
    },
    "modules/core/releases.html": {
        "path": "Products/Core/Releases",
        "title": "Releases",
        "content": "2021.12.2"
    },
    "increments/2022/children/Q4/index.html": {
        "path": "Increments/2022/Q4",
        "title": "Q4",
        "content": "Origin engineering/nasdanika.yml 145:9 Uri engineering://nasdanika/increments/2022/children/Q4 Start Oct 1, 2022 End Jan 1, 2023 Duration 92 days 1 hour"
    },
    "modules/core/modules/exec/modules/gen/issues/link-validator/index.html": {
        "path": "Products/Core/Exec/Generation Adapters/Issues/Link Validator",
        "title": "Link Validator",
        "content": "Validation of links. Should work on a file system and on a resource model. Base (target) URI for link resolution and a predicate for URL's to validate, e.g. all URL's under a particular URL (internal links). Use Jsoup. Origin exec.gen/engineering.yml 17:5 Uri engineering://nasdanika/modules/core/modules/exec/modules/gen/issues/link-validator Target Generation Adapters Workable"
    },
    "modules/html/modules/models/modules/app/modules/gen/issues/section-styles/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters/Issues/Implement support of remaining section styles and section columns in the Content panel",
        "title": "Implement support of remaining section styles and section columns in the Content panel",
        "content": "table, cards, card tabs, card pills. Origin model/app.gen/engineering.yml 10:6 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen/issues/section-styles Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generation Adapters Workable"
    },
    "modules/core/modules/diagram/modules/gen/issues/styling-of-mxcells/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Implement styling of mxcells",
        "title": "Implement styling of mxcells",
        "content": "DrawioGenerator - for diagram elements and connections. Translation of style types to shapes, e.g. node to cube. Shapes for start and end. A library of styles - from the drawio palette, exensible. Protected method in the generator, perhaps a service so multiple jars can contribute. Create a feature with documentation how to use. Or maybe Drawio support feature and document there, or a hierarchy of features. Origin diagram.gen/engineering.yml 42:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/styling-of-mxcells Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generators Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/TextAlignment.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/TextAlignment",
        "title": "TextAlignment",
        "content": "org.nasdanika.html.bootstrap.Text.Alignment Uses Text"
    },
    "increments/2022/children/Q3/children/jul/index.html": {
        "path": "Increments/2022/Q3/July",
        "title": "July",
        "content": "Origin engineering/nasdanika.yml 133:13 Uri engineering://nasdanika/increments/2022/children/Q3/children/jul Start Jul 1, 2022 End Aug 1, 2022 Duration 31 days"
    },
    "modules/core/modules/diagram/index.html": {
        "path": "Products/Core/Diagram",
        "title": "Diagram",
        "content": "Origin engineering.yml 13:8 Uri engineering://nasdanika/modules/core/modules/diagram"
    },
    "modules/html/modules/bootstrap/index.html": {
        "path": "Products/HTML/Bootstrap",
        "title": "Bootstrap",
        "content": "Origin bootstrap/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/bootstrap Dependencies HTML Dependants Model Generation Adapters"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/vue-table-component-column-filtering/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/Vue table component column filtering",
        "title": "Vue table component column filtering",
        "content": "Column-level filtering - funnel icon in the header opens a modal. If filter is applied the funnel icon changes las la-filter if no filter is applied fas fa-filter if applied. May also simply change color os stack icons, e.g. put in a circle Choices in column specs, e.g. issue statuses. Support of trees - checkbox lists or jsTree with checkboxes. Host as CSS and other JS - GitHub -> jsdelivr. Option to apply filters on columns which are not visible. Clear all filters button. Origin model/app/engineering.yml 26:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/vue-table-component-column-filtering Total cost 6.0 Effort 6.0 Remaining effort 6.0 Target Model Workable"
    },
    "modules/html/modules/models/modules/app/modules/gen/issues/document-search/index.html": {
        "path": "Products/HTML/Models/Application/Generation Adapters/Issues/Document search",
        "title": "Document search",
        "content": "Document how to implement search. Origin model/app.gen/engineering.yml 34:6 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/gen/issues/document-search Total cost 4.0 Effort 4.0 Remaining effort 4.0 Target Generation Adapters Workable"
    },
    "modules/core/modules/exec/modules/model/resources/package-summary.html": {
        "path": "Products/Core/Exec/Model/Resources",
        "title": "Resources",
        "content": "Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.exec\\model\\doc\\resources\\package-summary.md (The system cannot find the file specified)"
    },
    "modules/engineering/modules/model/issues/blog/index.html": {
        "path": "Products/Engineering/Model/Issues/Blog",
        "title": "Blog",
        "content": "The same reference type as discussion forum. The difference is that a blog starts with an \"answer\" topic and may contain questions, and discussion typicall starts with a question and then contains answers. Origin model/engineering.yml 35:5 Uri engineering://nasdanika/modules/engineering/modules/model/issues/blog Target Model Workable"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Tag.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Tag",
        "title": "Tag",
        "content": "org.nasdanika.html.model.bootstrap.Tag HTML tag with Bootstrap appearance Supertypes Tag BootstrapElement Subtypes Div"
    },
    "modules/html/modules/flow/index.html": {
        "path": "Products/HTML/Flow",
        "title": "Flow",
        "content": "Origin flow/engineering.yml 1:1 Uri engineering://nasdanika/modules/html/modules/flow Dependencies EMF Dependants Generation Adapters"
    },
    "modules/engineering/modules/gen/issues/appearance/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Configurable appearance",
        "title": "Configurable appearance",
        "content": "Showing/hiding/placement - child, navigation, section, .../styling - icons. Perhaps appearance model and not specific just to engineering, but generic and handled at EObjectActionProvider with extensibility. References with eKeys shall make it easy to build such a model - class(ifier) and feature keys. More complex with operations, but it is an edge case. Modal actions. Cascading appearance. Ability to define Bootstrap appearance - extend? Custom properties, e.g. to show/hide columns in issue tables. Origin gen/engineering.yml 9:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/appearance Target Generation Adapters Workable"
    },
    "issue-severities/major/index.html": {
        "path": "Issue/Severities/Major",
        "title": "Major",
        "content": "Origin engineering/nasdanika.yml 45:5 Uri engineering://nasdanika/issue-severities/major"
    },
    "modules/engineering/modules/gen/issues/help-dialogs/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Help dialogs",
        "title": "Help dialogs",
        "content": "Markdown help resource. Superscript question mark if present. Origin gen/engineering.yml 24:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/help-dialogs Target Generation Adapters Workable"
    },
    "increments/2022/children/Q4/children/nov/index.html": {
        "path": "Increments/2022/Q4/November",
        "title": "November",
        "content": "Origin engineering/nasdanika.yml 154:13 Uri engineering://nasdanika/increments/2022/children/Q4/children/nov Start Nov 1, 2022 End Dec 1, 2022 Duration 30 days 1 hour"
    },
    "modules/core/modules/flow/features/raci/index.html": {
        "path": "Products/Core/Flow/Features/Responsibility Assignments (RACI)",
        "title": "Responsibility Assignments (RACI)",
        "content": "Origin flow/engineering/engineering.yml 29:5 Uri engineering://nasdanika/modules/core/modules/flow/features/raci TODO -"
    },
    "modules/html/releases.html": {
        "path": "Products/HTML/Releases",
        "title": "Releases",
        "content": "2021.12.3"
    },
    "modules/core/modules/diagram/modules/gen/issues/gantt-representation/index.html": {
        "path": "Products/Core/Diagram/Generators/Issues/Gantt representation",
        "title": "Gantt representation",
        "content": "With support of events and relative durations. Transition durations. Origin diagram.gen/engineering.yml 74:5 Uri engineering://nasdanika/modules/core/modules/diagram/modules/gen/issues/gantt-representation Target Generators Workable"
    },
    "modules/core/modules/flow/ExpansionOutput.html": {
        "path": "Products/Core/Flow/ExpansionOutput",
        "title": "ExpansionOutput",
        "content": "org.nasdanika.flow.ExpansionOutput Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\expansion-output.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/core/modules/ncore/ListProperty.html": {
        "path": "Products/Core/Ncore/ListProperty",
        "title": "ListProperty",
        "content": "org.nasdanika.ncore.ListProperty Supertypes Property List"
    },
    "modules/core/modules/flow/Join.html": {
        "path": "Products/Core/Flow/Join",
        "title": "Join",
        "content": "org.nasdanika.flow.Join Error loading documentation: java.io.FileNotFoundException: C:\\Users\\Pavel\\git\\nasdanika.github.io\\target\\models\\org.nasdanika.flow\\model\\doc\\flow\\join.md (The system cannot find the path specified) Supertypes PseudoState"
    },
    "modules/engineering/modules/gen/issues/element-tables/index.html": {
        "path": "Products/Engineering/Generation Adapters/Issues/Element table methods",
        "title": "Element table methods",
        "content": "Similar to issue tables. Include aggregated things, e.g. reportedIssues, messages, assignments for engineers - numbers linking to respective pages. Create child issues for each model element. Origin gen/engineering.yml 56:5 Uri engineering://nasdanika/modules/engineering/modules/gen/issues/element-tables Target Generation Adapters Workable"
    },
    "modules/core/modules/ncore/IMarked.html": {
        "path": "Products/Core/Ncore/IMarked",
        "title": "IMarked",
        "content": "org.nasdanika.common.persistence.Marked Subtypes Marked"
    },
    "modules/core/modules/ncore/index.html": {
        "path": "Products/Core/Ncore",
        "title": "Ncore",
        "content": "Nasdanika Ncore model contains foundational model elements used in other models. Origin ncore/engineering.yml 1:1 Uri engineering://nasdanika/modules/core/modules/ncore Dependencies Common Dependants Model EMF"
    },
    "modules/html/modules/models/modules/bootstrap/modules/model/Breadcrumb.html": {
        "path": "Products/HTML/Models/Bootstrap/Model/Breadcrumb",
        "title": "Breadcrumb",
        "content": "org.nasdanika.html.model.bootstrap.Breadcrumb"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/site-map/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/Site map",
        "title": "Site map",
        "content": "Site map model element by default uses actions contained by the root action. Path to override this behavior - relative to self. Maybe also specify what to include - navigation, children, anonymous, ... And format - jsTree with search, list Origin model/app/engineering.yml 10:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/site-map Target Model Workable"
    },
    "modules/core/issues/update-dependencies/index.html": {
        "path": "Products/Core/Issues/Update dependencies - end of 2021",
        "title": "Update dependencies - end of 2021",
        "content": "Origin engineering.yml 32:5 Uri engineering://nasdanika/modules/core/issues/update-dependencies Target Core Workable"
    },
    "modules/core/modules/flow/issues/document-features/index.html": {
        "path": "Products/Core/Flow/Issues/Document features",
        "title": "Document features",
        "content": "Origin flow/engineering/engineering.yml 67:5 Uri engineering://nasdanika/modules/core/modules/flow/issues/document-features Target Flow Workable"
    },
    "modules/core/modules/ncore/issues/git-marker/index.html": {
        "path": "Products/Core/Ncore/Issues/GitMarker",
        "title": "GitMarker",
        "content": "Extends Marker. Method to NcoreUtil to scan a model and replace Markers with GitMarkers leveraging jGit. Method takes Web UI URL computer function - Git provider specific - GitHub uses path, Bitbucket query parameters. Origin(s), references, author, date, commit, blame - line number author. A way to compute line range for an object - from own marker to the next sibling marker. Shall be done at YAML lavel, maybe too involved. Info dialog in the UI showing Git info. Remotes, origin remote is a special case. Or take the first remote and use it as the property label. Analyze whether Marker is GitMarker at the time of injection to EObject. Another option is to handle it at even lower level - YAML/persistence. Would need GitMarker interface and impl. class at that level as well. Optional behavior, true by default - may slow down loading, but should be worth it. Can be used for (remote) branch-specific publishing, e.g. origin/branches/master or origin/branches/tags/rel-1.0 Origin ncore/engineering.yml 16:5 Uri engineering://nasdanika/modules/core/modules/ncore/issues/git-marker Target Ncore Workable"
    },
    "modules/html/modules/models/modules/app/modules/model/issues/vue-table-component/index.html": {
        "path": "Products/HTML/Models/Application/Model/Issues/Vue table component",
        "title": "Vue table component",
        "content": "Takes storage key and two JSON arrays - columns and items. Column default visibility from column specs, overriden by info from local storage if storage key is specified. Filtering, sorting, configuration in a dialog. Vue/BootstrapVue. Store configuration in local storage. Have local storage operations in own methods so it is easy in the future to replace/augment storage mechanism. E.g. store to profile for authenticated users. Origin model/app/engineering.yml 19:5 Uri engineering://nasdanika/modules/html/modules/models/modules/app/modules/model/issues/vue-table-component Total cost 6.0 Effort 6.0 Remaining effort 6.0 Target Model Workable"
    },
    "issue-categories/development/index.html": {
        "path": "Issue/Categories/Development",
        "title": "Development",
        "content": "Origin engineering/nasdanika.yml 31:5 Uri engineering://nasdanika/issue-categories/development"
    }
}