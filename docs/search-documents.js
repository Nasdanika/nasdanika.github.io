var searchDocuments = {"html/index.html":{"action-uuid":"dbed895b-e99e-49bb-8853-53e985b1625b","title":"HTML","content":"TODO"},"models/gitlab/index.html":{"path":"Models/GitLab","action-uuid":"58a7fa4a-5562-4ebf-9aa3-01342e80fc67","title":"GitLab","content":"TODO"},"html/models/app/index.html":{"path":"HTML/Models/App","action-uuid":"f70b8be8-c761-4fb3-98c0-46cd7e90d197","title":"App","content":"TODO"},"html/models/bootstrap/index.html":{"path":"HTML/Models/Bootstrap","action-uuid":"d97cc956-b396-4f90-bd60-b4bf7a3c4b65","title":"Bootstrap","content":"TODO"},"models/echarts/index.html":{"path":"Models/ECharts","action-uuid":"e5f2f69b-1acd-452a-bec0-5d3fd982d5ee","title":"ECharts","content":"TODO"},"core/maven/index.html":{"path":"Core/Maven","action-uuid":"10c6ba6c-6f93-48d1-b5e0-32e52fa504f9","title":"Maven","content":"TODO"},"core/persistence/index.html":{"path":"Core/Persistence","action-uuid":"142a6499-7867-4630-b6c2-72688dea3258","title":"Persistence","content":"TODO"},"core/diagram/index.html":{"path":"Core/Diagram","action-uuid":"6a8ac7af-741a-4994-bf85-2d722f528808","title":"Diagram","content":"TODO"},"html/emf/index.html":{"path":"HTML/EMF","action-uuid":"bce50aff-4444-4dc9-a09a-6b3dedf227ad","title":"EMF","content":"TODO"},"models/excel/index.html":{"path":"Models/Excel","action-uuid":"ff73b580-73e0-47f2-98cc-241faeb0fb31","title":"Excel","content":"TODO"},"html/bootstrap/index.html":{"path":"HTML/Bootstrap","action-uuid":"fea42f8d-7113-4bc0-9ad4-295fc2861a3c","title":"Bootstrap","content":"TODO"},"models/family/index.html":{"path":"Models/Family","action-uuid":"60cf6784-413e-4557-996c-b64a244503ad","title":"Family","content":"TODO"},"core/resources/index.html":{"path":"Core/Resources","action-uuid":"f7865e93-8f44-4778-be56-3a39bd0ba6b0","title":"Resources","content":"TODO"},"core/emf/index.html":{"path":"Core/EMF","action-uuid":"6977dad8-d781-4ed9-992a-fefe7c27ce58","title":"EMF","content":"TODO"},"html/models/html/index.html":{"path":"HTML/Models/HTML","action-uuid":"824cfcfc-9229-4c3a-99f0-092a4930c182","title":"HTML","content":"TODO"},"index.html":{"action-uuid":"c64670f7-6a79-4bcf-a05d-bc73b82338d4","title":"Nasdanika","content":" Common Resources Persistence Ncore Diagram Graph Drawio EMF Exec Maven Capability Core HTML HTML Bootstrap App Models JsTree Bootstrap EMF HTML GitLab Family Architecture Graph Excel ECharts Nature Bank PDF Models Data Sources Loader Store Key Extractor Query Engine Requestor Generator Responder Retrieval Augmented Generation (RAG) Common Resources Persistence Ncore Diagram Graph Drawio EMF Exec Maven Capability Core HTML HTML Bootstrap App Models JsTree Bootstrap EMF HTML GitLab Family Architecture Graph Excel ECharts Nature Bank PDF Models Data Sources Loader Store Key Extractor Query Engine Requestor Generator Responder Retrieval Augmented Generation (RAG)"},"html/jstree/index.html":{"path":"HTML/JsTree","action-uuid":"38c12736-a7b8-4c14-a8fe-64b30ffbdd39","title":"JsTree","content":"TODO"},"glossary.html":{"action-uuid":"a4075bc5-03e5-4aaa-8893-0b16618843f8","title":"Glossary","content":"Clear Identifier(s) Hide UUID {{data.value.name}} {{data.value[0].value}} {{item.value}}"},"core/common/index.html":{"path":"Core/Common","action-uuid":"490e8216-74e0-4e94-8cb1-1311f3f09c98","title":"Common","content":"TODO"},"models/bank/index.html":{"path":"Models/Bank","action-uuid":"377df01e-abb6-46d1-83fc-4a9b5d2bab7c","title":"Bank","content":"A model of a bank - customers, accounts, statements, transactions. Documentation Sources"},"models/pdf/index.html":{"path":"Models/PDF","action-uuid":"09e41c8a-49e9-472b-909c-844a50774bd0","title":"PDF","content":"A model, loader, resource, and resource factory for PDF files - document, page, article, paragraph, line. Documentation Sources"},"core/drawio/index.html":{"path":"Core/Drawio","action-uuid":"9714c6b9-6f1e-4e7b-a58f-742e26f7aacc","title":"Drawio","content":"Nasdankia provides two Maven modules for working with Drawio diagrams - API and Model. The modules require Java 17 or above. API Drawio module provides Java API for reading and manipulating Drawio diagrams. It is built on top of Graph. The module provides the following interfaces representing elements of a diagram file: Document - the root object of the API representing a file/resource which contains one or more pages. Page - a page containing a diagram (Model). Model - a diagram model containing the diagram root. Root - the root of the model containing layers. Layer - a diagram may have one or more layers. Layers contain Nodes and Connections. Node - a node can be connected to other nodes with connections. A node may contain other nodes and connections. Connection - a connection between two nodes. The below diagram shows relationships between the above interfaces including their super-interfaces: Util provides utility methods such as layout() and methods to navigate and query documents and their elements. Model Drawio Model module provides an EMF Ecore model for diagrams. A model instance can be obtained from the API document by calling Document.toModelDocument() method. The model makes it more convenient to work with the diagram elements by: Making a reference between pages and model elements bi-directional. Introducing Tag class as opposed to a string in the API. Tag is contained by Page and has bi-directional reference with tagged elements. Document The root object of the API representing a file/resource which contains one or more pages Page A page containing a diagram (Model) Model A diagram model containing the diagram root Root The root of the model containing layers Layer A diagram may have one or more layers. Layers contain Nodes and Connections. Link [0..1] Layer Element Element Model Element Node A node can be connected to other nodes with connections. A node may contain other nodes and connections. Connection A connection between two nodes * source 0..1 outgoingConnections * 1 1 1..* * target 0..1 incomingConnections * Tag * * *"},"models/index.html":{"action-uuid":"373338ca-f870-4df1-82cd-f74eb87561ba","title":"Models","content":"TODO"},"core/exec/index.html":{"path":"Core/Exec","action-uuid":"f5ed6eb9-4446-47d7-8034-6e5d4dfc5d3b","title":"Exec","content":"TODO"},"core/ncore/index.html":{"path":"Core/Ncore","action-uuid":"99d7a4a0-5401-4d51-93b5-dc37837f73dd","title":"Ncore","content":"TODO"},"models/nature/index.html":{"path":"Models/Nature","action-uuid":"cd60836b-12dc-48c9-9d38-879101a75794","title":"Nature","content":"A model of a forest biome, living beings within it and their interations. This model is used for testing Ecore documentation generation. Documentation Sources"},"html/html/index.html":{"path":"HTML/HTML","action-uuid":"3edc31d8-5723-4f71-bc62-ef716dddbec6","title":"HTML","content":"TODO"},"models/graph/index.html":{"path":"Models/Graph","action-uuid":"73963b44-607b-4905-82e1-f41591afdc0c","title":"Graph","content":"TODO"},"core/capability/index.html":{"path":"Core/Capability","action-uuid":"62246d82-8df2-493f-918a-10099989bb99","title":"Capability","content":"Nasdanika Capability framework allows to discover/load capabilities which meet a requirement. Capabilities are provided by CapabilityFactory create() method. Capability factories may request other capabilities they need. As such, capabilities can be chained. Factories create CapabilityLoaders which provide Flux reactive streams of capabilities. It allows to have an infinite stream of capabilities which are consumed (and produced) as needed. Capability providers may furnish additional information about capabilities. This information can be used for filtering or sorting providers. A non-technical example of requirement/capability chain graph is a food chain/graph. Food is a requirement. Or &ldquo;I want to eat&rdquo; is a requirement. Bread and, say fried eggs are two capabilities meeting/addressing the requirement. Bread requires &ldquo;wheat&rdquo;, &ldquo;water&rdquo;, and &ldquo;bake&rdquo; capabilities. Fried eggs require &ldquo;egg&rdquo;, &ldquo;oil&rdquo;, and &ldquo;fry&rdquo; capabilities. Bread capability provider may implement Vegan marker interface which can be used for filtering. All food capabilities may implement NutritionalInformation interface - it can be used for filtering or sorting. A more technical example is Java ServiceLoader with service type being a requirement and an instance of the service class being a capability. Nasdanika capability framework can operate on top of ServiceLoader and may be thought of as a generalization of service loading. In essence, the capability framework is a backward chaining engine as shown in one of the example below. Client code - requiring a capability Capabilities are loaded by CapabilityLoader. Capability loader can take an iterable of capability factories in its constructor, or it can load them using ServiceLoader as shown in the below code snippet: CapabilityLoader capabilityLoader = new CapabilityLoader();\ncapabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\t\t\nfor (CapabilityProvider&lt;?&gt; cp: capabilityLoader.load(new TestCapabilityFactory.Requirement(&quot;Hello World&quot;), progressMonitor)) {\n\tSystem.out.println(cp);\n\tFlux&lt;?&gt; publisher = cp.getPublisher();\n\t\t\t\n\tpublisher.subscribe(System.out::println);\n}\n Factories can also be added post-construction with getFactories().add(factory). Service capabilities Service requirements and capabilities provide functionality similar to ServiceLoader - requesting instances of specific type, but extend it with ability to provide additional service requirement. This functionality is provided by ServiceCapabilityFactory and ServiceCapabilityFactory.Requirement. CapabilityLoader capabilityLoader = new CapabilityLoader();\ncapabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\nProgressMonitor progressMonitor = new PrintStreamProgressMonitor();\n\t\t\n@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })\nServiceCapabilityFactory.Requirement&lt;List&lt;Double&gt;, Double&gt; requirement = (ServiceCapabilityFactory.Requirement) ServiceCapabilityFactory.createRequirement(List.class, null,  33.0);\nfor (CapabilityProvider&lt;?&gt; cp: capabilityLoader.load(requirement, progressMonitor)) {\n\tSystem.out.println(cp);\n\tFlux&lt;?&gt; publisher = cp.getPublisher();\n\t\t\t\n\tpublisher.subscribe(System.out::println);\n}\n It is also possible to load services from ServiceLoader using subclasses of Service. You&rsquo;d need to subclass ServiceFactory in a module which uses a particular service and override stream(Class&lt;S&gt; service) method as shown below: @Override\nprotected Stream&lt;Provider&lt;S&gt;&gt; stream(Class&lt;S&gt; service) {\n\treturn ServiceLoader.load(service).stream();\n}\n Then you&rsquo;d need to add the factory to the loader: capabilityLoader.getFactories().add(new TestServiceFactory&lt;Object&gt;());\n Providing a capability As it was mentioned above, capability factories can be explicitly added to CapabilityLoader or loaded using ServiceLoader. Below is an example of a capability factory: public class TestCapabilityFactory implements CapabilityFactory&lt;TestCapabilityFactory.Requirement, Integer&gt; {\n\t\n\tpublic record Requirement(String value){};\n\t\n\t@Override\n\tpublic boolean canHandle(Object requirement) {\n\t\treturn requirement instanceof Requirement;\n\t}\n\n\t@Override\n\tpublic CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Integer&gt;&gt;&gt; create(\n\t\t\tRequirement requirement,\n\t\t\tBiFunction&lt;Object, ProgressMonitor, CompletionStage&lt;Iterable&lt;CapabilityProvider&lt;Object&gt;&gt;&gt;&gt; resolver,\n\t\t\tProgressMonitor progressMonitor) {\n\t\t\n\t\treturn resolver.apply(MyService.class, progressMonitor).thenApply(cp -&gt; {;\n\t\t\t@SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })\n\t\t\tFlux&lt;MyService&gt; myServiceCapabilityPublisher = (Flux) cp.iterator().next().getPublisher();\n\t\t\t\n\t\t\treturn Collections.singleton(new CapabilityProvider&lt;Integer&gt;() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic Flux&lt;Integer&gt; getPublisher() {\n\t\t\t\t\tFunction&lt;MyService, Integer&gt; mapper = ms -&gt; ms.count(((Requirement) requirement).value());\n\t\t\t\t\treturn myServiceCapabilityPublisher.map(mapper);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t});\n\t}\n\n}\n Applications Services Service capabilities explained above a used by Graph and Function Flow for loading node processors and connection processors for a specific requirement using NodeProcessorFactory and ConnectionProcessorFactory respectively. For example, code generation, execution, simulation. Solutions for architectures One of future application of the capability framework is creation a list of solution alternatives for an architecture/pattern. For example, there might be multiple RAG embodiments with different key types, key extractors, stores, &hellip; Some of &ldquo;design dimensions&rdquo; are listed below: Key type: Bag of words. Multiple options - just words, words with frequency, tokenized words, word stems. Embedding vector - different embedding models, different dimensions. Store - multiple stores for multiple key types. Multiple indexing and retrieval methods. Chunk size, chunk overlap, chunking algorithm. Generator - multiple models and prompts As you can see a number of potential combinations can easily go into thousands or even be infinite. Reactive approach with filtering and sorting may be helpful in selecting a solution which is a good fit for a particular use case - number and type of data sources etc. For example, if the total size of data is under a few gigabytes an in-memory store may be a better choice than, say, an external (vector) database. Also an old good bag of words might be better than embeddings. E.g. it might be cheaper. Backward chaining Family reasoning demonstrates application of the capability framework as a backward chaining engine. Family relationships such as grandfather and cousin are constructed by requiring and combining relationships such as child and sibling. Stream processing This possible application is similar to backward reasoning. Imagine an algorithmic trading strategy which uses several technical indicators, such as moving averages, to make trading decisions. Such a strategy would submit requirements for technical indicators which would include symbol, indicator configuration, time frame size. Technical indicators in turn would submit a requirement for raw trading data. A technical indicator such as moving average would start publishing its events once it receives enough trading data frames to compute its average. A trading engine would submit a requirement for strategies. A strategy factory may produce multiple strategies with different configurations. The trading engine would perform &ldquo;paper&rdquo; trades, select well-performing strategies and discard ones which perform poorly. This can be an ongoing process - if a strategy deteriorates then it is discarded and a new strategy is requested from strategy publishers - this process can be infinite."},"core/graph/index.html":{"path":"Core/Graph","action-uuid":"b0d04fe8-8865-4a6a-b388-20a631f607fd","title":"Graph","content":"TODO"},"core/index.html":{"action-uuid":"f12f5613-7269-4760-8d22-c16f3443a005","title":"Core","content":"TODO"},"html/models/index.html":{"path":"HTML/Models","action-uuid":"21e9a0d9-6e9f-4a68-8a8b-27b49eea587b","title":"Models","content":"TODO"},"models/architecture/index.html":{"path":"Models/Architecture","action-uuid":"79f5b21f-d2b0-4bbe-8c1b-ec821a9388c7","title":"Architecture","content":"TODO"}}