<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SiteGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Nasdanika Application Model Generation Adapters</a> &gt; <a href="index.source.html" class="el_package">org.nasdanika.html.model.app.gen</a> &gt; <span class="el_source">SiteGenerator.java</span></div><h1>SiteGenerator.java</h1><pre class="source lang-java linenums">package org.nasdanika.html.model.app.gen;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.TreeMap;
import java.util.UUID;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.eclipse.emf.common.notify.Notifier;
import org.eclipse.emf.common.util.ECollections;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.resource.impl.ResourceSetImpl;
import org.eclipse.emf.ecore.xmi.impl.XMIResourceFactoryImpl;
import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.nasdanika.common.Context;
import org.nasdanika.common.DefaultConverter;
import org.nasdanika.common.Diagnostic;
import org.nasdanika.common.DiagnosticException;
import org.nasdanika.common.MutableContext;
import org.nasdanika.common.NasdanikaException;
import org.nasdanika.common.ProgressMonitor;
import org.nasdanika.common.PropertyComputer;
import org.nasdanika.common.Status;
import org.nasdanika.common.SupplierFactory;
import org.nasdanika.drawio.Connection;
import org.nasdanika.drawio.Layer;
import org.nasdanika.drawio.LayerElement;
import org.nasdanika.drawio.Model;
import org.nasdanika.drawio.Node;
import org.nasdanika.drawio.Page;
import org.nasdanika.drawio.Rectangle;
import org.nasdanika.drawio.Root;
import org.nasdanika.drawio.comparators.LabelModelElementComparator;
import org.nasdanika.emf.EObjectAdaptable;
import org.nasdanika.exec.content.ContentFactory;
import org.nasdanika.exec.content.Text;
import org.nasdanika.exec.resources.Container;
import org.nasdanika.exec.resources.ReconcileAction;
import org.nasdanika.exec.resources.ResourcesFactory;
import org.nasdanika.graph.Element;
import org.nasdanika.html.HTMLFactory;
import org.nasdanika.html.Tag;
import org.nasdanika.html.TagName;
import org.nasdanika.html.emf.NcoreActionBuilder;
import org.nasdanika.html.emf.ResolutionListener;
import org.nasdanika.html.jstree.JsTreeFactory;
import org.nasdanika.html.jstree.JsTreeNode;
import org.nasdanika.html.model.app.Action;
import org.nasdanika.html.model.app.AppFactory;
import org.nasdanika.html.model.app.Label;
import org.nasdanika.html.model.app.Link;
import org.nasdanika.html.model.app.gen.Util.HTMLProcessor;
import org.nasdanika.html.model.html.gen.ContentConsumer;
import org.nasdanika.ncore.ModelElement;
import org.nasdanika.ncore.NcorePackage;
import org.nasdanika.ncore.util.ContainerInfo;
import org.nasdanika.ncore.util.NcoreUtil;
import org.nasdanika.ncore.util.SemanticIdentity;
import org.nasdanika.ncore.util.SemanticInfo;
import org.nasdanika.ncore.util.SemanticMap;
import org.nasdanika.persistence.Marker;
import org.nasdanika.resources.FileSystemContainer;
import org.w3c.dom.Attr;
import org.w3c.dom.NamedNodeMap;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.DumperOptions.FlowStyle;
import org.yaml.snakeyaml.Yaml;

import com.redfin.sitemapgenerator.ChangeFreq;

<span class="fc" id="L102">public class SiteGenerator {</span>
	
	/**
	 * Creates and configures a resource set for loading models.
	 * Override to customize, e.g. register {@link EPackage}'s and adapter factories.
	 * @param progressMonitor
	 * @return
	 */
	protected ResourceSet createResourceSet(Context context, ProgressMonitor progressMonitor) {
<span class="fc" id="L111">		ResourceSet resourceSet = Util.createResourceSet(context, progressMonitor);</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">		for (SiteGeneratorContributor contributor: getContributors()) {</span>
<span class="nc" id="L113">			contributor.configureResourceSet(resourceSet, context, progressMonitor);</span>
<span class="nc" id="L114">		}</span>
<span class="fc" id="L115">		return resourceSet;</span>
	}
	
	/**
	 * Creates a resource set for loading resource model.
	 * Override to customize, e.g. register {@link EPackage}'s and adapter factories.
	 * @param progressMonitor
	 * @return
	 */
	protected ResourceSet createResourceModelResourceSet(Context context, ProgressMonitor progressMonitor) {
<span class="fc" id="L125">		ResourceSet resourceSet = createResourceSet(context, progressMonitor);</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">		for (SiteGeneratorContributor contributor: getContributors()) {</span>
<span class="nc" id="L127">			contributor.configureResourceModelResourceSet(resourceSet, context, progressMonitor);</span>
<span class="nc" id="L128">		}</span>
<span class="fc" id="L129">		return resourceSet;</span>
	}	
	
	/**
	 * Creates a resource set for loading action model.
	 * Override to customize, e.g. register {@link EPackage}'s and adapter factories.
	 * @param progressMonitor
	 * @return
	 */
	protected ResourceSet createActionModelResourceSet(Context context, ProgressMonitor progressMonitor) {
<span class="fc" id="L139">		ResourceSet resourceSet = createResourceSet(context, progressMonitor);</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">		for (SiteGeneratorContributor contributor: getContributors()) {</span>
<span class="nc" id="L141">			contributor.configureActionModelResourceSet(resourceSet, context, progressMonitor);</span>
<span class="nc" id="L142">		}</span>
<span class="fc" id="L143">		return resourceSet;</span>
	}	
		
	/**
	 * Generates a resource model from an action model.
	 * @throws IOException 
	 * @throws Exception
	 */
	protected Resource generateResourceModel(
			Action root, 
			Iterable&lt;Map.Entry&lt;SemanticInfo, ?&gt;&gt; semanticInfoSource,
			org.nasdanika.html.model.bootstrap.Page pageTemplate,
			URI resourceURI, 
			String containerName,
			File resourceWorkDir,
			ResolutionListener resolutionListener,						
			Context context, 
			ProgressMonitor progressMonitor) throws IOException {
		
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">		for (SiteGeneratorContributor contributor: getContributors()) {</span>
<span class="nc" id="L163">			contributor.processRootAction(root, context, progressMonitor);</span>
<span class="nc" id="L164">		}</span>
		
<span class="fc" id="L166">		java.util.function.Consumer&lt;Diagnostic&gt; diagnosticConsumer = diagnostic -&gt; {</span>
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">			if (diagnostic.getStatus() == Status.FAIL || diagnostic.getStatus() == Status.ERROR) {</span>
<span class="nc" id="L168">				System.err.println(&quot;***********************&quot;);</span>
<span class="nc" id="L169">				System.err.println(&quot;*      Diagnostic     *&quot;);</span>
<span class="nc" id="L170">				System.err.println(&quot;***********************&quot;);</span>
<span class="nc" id="L171">				diagnostic.dump(System.err, 4, Status.FAIL, Status.ERROR);</span>
			}
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">			if (diagnostic.getStatus() != Status.SUCCESS) {</span>
<span class="nc" id="L174">				throw new DiagnosticException(diagnostic);</span>
			};
<span class="fc" id="L176">		};</span>
		
<span class="fc" id="L178">		Container container = ResourcesFactory.eINSTANCE.createContainer();</span>
<span class="fc" id="L179">		container.setName(containerName);</span>
<span class="fc" id="L180">		container.setReconcileAction(ReconcileAction.OVERWRITE);</span>
		
<span class="fc" id="L182">		ResourceSet resourceSet = createResourceModelResourceSet(context, progressMonitor);</span>
<span class="fc" id="L183">		Resource modelResource = resourceSet.createResource(resourceURI);</span>
<span class="fc" id="L184">		modelResource.getContents().add(container);</span>
		
		// Generating content file from action content 
		
<span class="fc" id="L188">		File pagesDir = new File(resourceWorkDir, &quot;pages&quot;);</span>
<span class="fc" id="L189">		pagesDir.mkdirs();</span>
		
<span class="fc" id="L191">		JSONArray semanticInfo = semanticInfo(root, semanticInfoSource, context);</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">		if (semanticInfo != null) {</span>
<span class="fc" id="L193">			org.nasdanika.exec.resources.File semanticMapFile = container.getFile(&quot;semantic-info.json&quot;);</span>
<span class="fc" id="L194">			Text semanticMapText = ContentFactory.eINSTANCE.createText();</span>
<span class="fc" id="L195">			semanticMapText.setContent(semanticInfo.toString(4));</span>
<span class="fc" id="L196">			semanticMapFile.getContents().add(semanticMapText);</span>
		}
		
<span class="fc" id="L199">		Util.generateSite(</span>
				root, 
				pageTemplate,
				container,
<span class="fc" id="L203">				contentProviderContext -&gt; (cAction, uriResolver, pMonitor) -&gt; getActionContent(cAction, semanticInfoURIResolver(uriResolver), semanticInfoSource, resourceWorkDir, contentProviderContext, diagnosticConsumer, resolutionListener, pMonitor),</span>
<span class="fc" id="L204">				contentProviderContext -&gt; (page, baseURI, uriResolver, pMonitor) -&gt; getPageContent(page, baseURI, semanticInfoURIResolver(uriResolver), pagesDir, contentProviderContext, progressMonitor),</span>
<span class="fc" id="L205">				Context.singleton(&quot;semantic-info&quot;, semanticInfo.toString()).compose(context),</span>
				progressMonitor);
		
<span class="fc" id="L208">		modelResource.save(null);</span>
		
		// Page model to XML conversion
<span class="fc" id="L211">		ResourceSet pageResourceSet = new ResourceSetImpl();</span>
<span class="fc" id="L212">		pageResourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());			</span>
<span class="fc" id="L213">		pageResourceSet.getAdapterFactories().add(new AppAdapterFactory());</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">		for (File pageFile: pagesDir.listFiles(f -&gt; f.getName().endsWith(&quot;.xml&quot;))) {</span>
<span class="fc" id="L215">			URI pageURI = URI.createFileURI(pageFile.getCanonicalPath());</span>
<span class="fc" id="L216">			Resource pageEResource = pageResourceSet.getResource(pageURI, true);</span>
<span class="fc" id="L217">			SupplierFactory&lt;InputStream&gt; contentFactory = org.nasdanika.common.Util.asInputStreamSupplierFactory(pageEResource.getContents());			</span>
<span class="fc" id="L218">			try (InputStream contentStream = org.nasdanika.common.Util.call(contentFactory.create(context), progressMonitor, diagnosticConsumer, Status.FAIL, Status.ERROR)) {</span>
<span class="fc" id="L219">				Files.copy(contentStream, new File(pageFile.getCanonicalPath().replace(&quot;.xml&quot;, &quot;.html&quot;)).toPath(), StandardCopyOption.REPLACE_EXISTING);</span>
<span class="fc" id="L220">				progressMonitor.worked(1, &quot;[Page xml -&gt; html] &quot; + pageFile.getName());</span>
			}
		}
		
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">		for (SiteGeneratorContributor contributor: getContributors()) {</span>
<span class="nc" id="L225">			contributor.processResourcecModel(modelResource, context, progressMonitor);</span>
<span class="nc" id="L226">		}</span>
		
<span class="fc" id="L228">		return modelResource;</span>
	}
	
	protected BiFunction&lt;Label, URI, URI&gt; semanticInfoURIResolver(BiFunction&lt;Label, URI, URI&gt; uriResolver) {		
<span class="fc" id="L232">		return (label, base) -&gt; {</span>
<span class="fc" id="L233">			URI ret = uriResolver.apply(label, base);</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">			return ret == null ? resolveSemanticInfo(label, base) : ret;</span>
		};
	}
	
	protected boolean isSemanticInfoLink(Link link) {
<span class="fc" id="L239">		return false;</span>
	}

	/**
	 * Resolves URI from a semantic info (external definitions)
	 * @param label
	 * @param base
	 * @return
	 */
	protected URI resolveSemanticInfo(Label label, URI base) {
<span class="pc bpc" id="L249" title="1 of 4 branches missed.">		if (label instanceof Link &amp;&amp; isSemanticInfoLink((Link) label)) {</span>
<span class="nc" id="L250">			String linkLocation = ((Link) label).getLocation();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(linkLocation)) {</span>
<span class="nc" id="L252">				URI locationURI = URI.createURI(linkLocation);</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">				return base == null || locationURI == null ? locationURI : locationURI.deresolve(base, true, true, true);</span>
			}
		}
<span class="fc" id="L256">		return null;</span>
	}

	/**
	 * Creates a semantic info array.
	 * Override to create aggregated semantic maps.
	 * @param root
	 * @param registry
	 * @param context
	 * @return
	 */
	protected JSONArray semanticInfo(Action root, Iterable&lt;Map.Entry&lt;SemanticInfo, ?&gt;&gt; semanticInfoSource, Context context) {
		// Semantic info
<span class="fc" id="L269">		JSONArray semanticInfo = new JSONArray();		</span>
<span class="fc" id="L270">		URI baseURI = URI.createURI(&quot;temp://&quot; + UUID.randomUUID() + &quot;/&quot; + UUID.randomUUID() + &quot;/&quot;);</span>
<span class="fc" id="L271">		Context semanticMapContext = Context.singleton(Context.BASE_URI_PROPERTY, baseURI).compose(context);</span>
<span class="fc" id="L272">		BiFunction&lt;Label, URI, URI&gt; uriResolver = semanticInfoURIResolver(org.nasdanika.html.model.app.util.Util.uriResolver(root, semanticMapContext));		</span>

<span class="pc bpc" id="L274" title="1 of 2 branches missed.">		if (semanticInfoSource != null) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">			for (Entry&lt;SemanticInfo, ?&gt; nextEntry: semanticInfoSource) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">				if (nextEntry != null) {</span>
<span class="fc" id="L277">					Object nextValue = nextEntry.getValue();</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">					if (nextValue instanceof Label) {</span>
<span class="fc" id="L279">						Label label = (Label) nextValue;</span>
<span class="fc" id="L280">						SemanticInfo semanticElementAnnotation = nextEntry.getKey();</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">						if (semanticElementAnnotation != null) {</span>
<span class="fc" id="L282">							JSONObject value = semanticElementAnnotation.toJSON();</span>
							
<span class="fc" id="L284">							String labelText = label.getText();</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">							if (!org.nasdanika.common.Util.isBlank(labelText)) {</span>
<span class="fc" id="L286">								value.put(ContainerInfo.NAME_KEY, labelText);</span>
							}
<span class="fc" id="L288">							String labelTooltip = label.getTooltip();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">							if (!org.nasdanika.common.Util.isBlank(labelTooltip)) {</span>
<span class="fc" id="L290">								value.put(SemanticInfo.DESCRIPTION_KEY, labelTooltip);</span>
							}
<span class="fc" id="L292">							String labelIcon = label.getIcon();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">							if (!org.nasdanika.common.Util.isBlank(labelIcon)) {</span>
<span class="fc" id="L294">								value.put(SemanticInfo.ICON_KEY, labelIcon);</span>
							}				
<span class="fc" id="L296">							URI linkURI = uriResolver.apply(label, baseURI);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">							if (linkURI != null) {</span>
<span class="fc" id="L298">								value.put(SemanticInfo.LOCATION_KEY, linkURI.toString());</span>
							}
							
<span class="fc" id="L301">							semanticInfo.put(value);								</span>
						}				
					}
				}
<span class="fc" id="L305">			}</span>
		}
<span class="fc" id="L307">		return semanticInfo;</span>
	}
	
	/**
	 * Creates a file with .xml extension containing page contents resource model. Creates and returns a resource with .html extension. 
	 * A later processing step shall convert .xml to .html 
	 * @param page
	 * @param baseURI
	 * @param uriResolver
	 * @param pagesDir
	 * @param progressMonitor
	 * @return
	 */
	protected EList&lt;EObject&gt; getPageContent(
			org.nasdanika.html.model.bootstrap.Page page, 
			URI baseURI, 
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			File pagesDir,
			Context contentProviderContext,
			ProgressMonitor progressMonitor) {
		
		try {
			// Saving a page to .xml and creating a reference to .html; Pages shall be processed from .xml to .html individually.
<span class="fc" id="L330">			page.setUuid(UUID.randomUUID().toString());</span>
			
<span class="fc" id="L332">			ResourceSet pageResourceSet = new ResourceSetImpl();</span>
<span class="fc" id="L333">			pageResourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION, new XMIResourceFactoryImpl());			</span>
<span class="fc" id="L334">			URI pageURI = URI.createFileURI(new File(pagesDir, page.getUuid() + &quot;.xml&quot;).getCanonicalPath());</span>
<span class="fc" id="L335">			Resource pageEResource = pageResourceSet.createResource(pageURI);</span>
<span class="fc" id="L336">			pageEResource.getContents().add(page);</span>
<span class="fc" id="L337">			pageEResource.save(null);</span>
			
<span class="fc" id="L339">			org.nasdanika.exec.content.Resource pageResource = ContentFactory.eINSTANCE.createResource();</span>
<span class="fc" id="L340">			pageResource.setLocation(&quot;pages/&quot; + page.getUuid() + &quot;.html&quot;);</span>
<span class="fc" id="L341">			progressMonitor.worked(1, &quot;[Page content] &quot; + page.getName() + &quot; -&gt; &quot; + pageResource.getLocation());</span>
<span class="fc" id="L342">			return ECollections.singletonEList(pageResource);</span>
<span class="nc" id="L343">		} catch (IOException e) {</span>
<span class="nc" id="L344">			throw new NasdanikaException(e);</span>
		}		
	}
	
	private static &lt;K,V&gt; Map.Entry&lt;K, V&gt; mapEntry(K key, V value) {
<span class="fc" id="L349">		return new Entry&lt;K, V&gt;() {</span>

			@Override
			public K getKey() {
<span class="fc" id="L353">				return key;</span>
			}

			@Override
			public V getValue() {
<span class="fc" id="L358">				return value;</span>
			}

			@Override
			public V setValue(V value) {
<span class="nc" id="L363">				throw new UnsupportedOperationException();</span>
			}
			
		};
	}
	
	// Helper method
	private static String containmentRef(SemanticIdentity se) {
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">		if (se instanceof SemanticInfo) {</span>
<span class="fc" id="L372">			ContainerInfo cInfo = ((SemanticInfo) se).getContainerInfo();</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">			if (cInfo != null) {</span>
<span class="fc" id="L374">				return cInfo.getReference();</span>
			}
		}
<span class="fc" id="L377">		return null;</span>
	}
	
	private static List&lt;Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt;&gt; createReferenceJsTreeNodes(
			Map&lt;String, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; groupedByReference,
			JsTreeFactory jsTreeFactory) {
		
<span class="fc" id="L384">		return groupedByReference</span>
<span class="fc" id="L385">			.entrySet()</span>
<span class="fc" id="L386">			.stream()</span>
<span class="fc" id="L387">			.sorted(SiteGenerator::compareReferenceEntries)</span>
<span class="fc" id="L388">			.map(e -&gt; createReferenceJsTreeNode(e, jsTreeFactory))</span>
<span class="fc" id="L389">			.collect(Collectors.toList());			</span>
	}
	
	private static int compareReferenceEntries(Entry&lt;String, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; a, Entry&lt;String, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; b) {
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">		if (a == b) {</span>
<span class="nc" id="L394">			return 0;</span>
		}
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">		if (a == null) {</span>
<span class="nc" id="L397">			return 1;</span>
		}
		
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">		if (b == null) {</span>
<span class="nc" id="L401">			return -1;</span>
		}
		
<span class="fc" id="L404">		String aRef = a.getKey();</span>
<span class="fc" id="L405">		String bRef = b.getKey();</span>
		
<span class="pc bpc" id="L407" title="3 of 4 branches missed.">		if (org.nasdanika.common.Util.isBlank(aRef) &amp;&amp; org.nasdanika.common.Util.isBlank(bRef)) {</span>
<span class="nc" id="L408">			return 0;</span>
		}

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">		if (org.nasdanika.common.Util.isBlank(aRef)) {</span>
<span class="nc" id="L412">			return 1;</span>
		}
		
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">		if (org.nasdanika.common.Util.isBlank(bRef)) {</span>
<span class="nc" id="L416">			return -1;</span>
		}
		
<span class="fc" id="L419">		return aRef.compareTo(bRef);		</span>
	}
	
	/**
	 * Creates a {@link JsTreeNode} for a reference if refEntry is not null and reference name is not null. Links value nodes under the reference node
	 * @param refEntry
	 * @param jsTreeFactory
	 * @return
	 */
	private static Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; createReferenceJsTreeNode(
			Entry&lt;String, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; refEntry,
			JsTreeFactory jsTreeFactory) {
		
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">		if (refEntry == null) {</span>
<span class="nc" id="L433">			return null;</span>
		}
		
<span class="fc bfc" id="L436" title="All 2 branches covered.">		if (org.nasdanika.common.Util.isBlank(refEntry.getKey())) {</span>
<span class="fc" id="L437">			return new Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo,JsTreeNode&gt;&gt;&gt;() {</span>
				
				@Override
				public List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt; setValue(List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt; value) {
<span class="nc" id="L441">					throw new UnsupportedOperationException();</span>
				}
				
				@Override
				public List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt; getValue() {
<span class="fc" id="L446">					return refEntry.getValue();</span>
				}
				
				@Override
				public JsTreeNode getKey() {
<span class="fc" id="L451">					return null;</span>
				}
			};
		}
		
<span class="fc" id="L456">		JsTreeNode refNode = jsTreeFactory.jsTreeNode();</span>
<span class="fc" id="L457">		refNode.text(org.nasdanika.common.Util.nameToLabel(refEntry.getKey()));</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">		for (Entry&lt;SemanticInfo, JsTreeNode&gt; ve: refEntry.getValue()) {</span>
<span class="fc" id="L459">			refNode.children().add(ve.getValue());			</span>
<span class="fc" id="L460">		}		</span>
		
<span class="fc" id="L462">		return Map.entry(refNode, refEntry.getValue());</span>
	}
		
	/**
	 * Computes site map tree script - context property computer
	 * @param context
	 * @return
	 */
	protected String computeSiteMapTreeScript(
			Context context, 
			Action action, 
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			ProgressMonitor progressMonitor) {
		// TODO - actions from action prototype, e.g. Ecore doc actions, to the tree.
		
<span class="fc" id="L478">		int maxLength = 50;</span>
<span class="fc" id="L479">		SemanticMap&lt;SemanticInfo,JsTreeNode&gt; nodeMap = new SemanticMap&lt;&gt;();</span>
		
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">		if (semanticInfoSource != null) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">			for (Entry&lt;SemanticInfo, ?&gt; entry: semanticInfoSource) {</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">				if (entry != null) {</span>
<span class="fc" id="L484">					Object value = entry.getValue();</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">					if (value instanceof Label) {</span>
<span class="fc" id="L486">						Label treeLabel = (Label) value;</span>
<span class="fc" id="L487">						SemanticInfo semanticElementAnnotation = entry.getKey();</span>
<span class="pc bpc" id="L488" title="1 of 2 branches missed.">						if (semanticElementAnnotation != null) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">							Label label = treeLabel instanceof Link ? AppFactory.eINSTANCE.createLink() : AppFactory.eINSTANCE.createLabel();</span>
<span class="fc" id="L490">							String treeLabelText = treeLabel.getText();</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">							if (org.nasdanika.common.Util.isBlank(treeLabelText)) {</span>
<span class="fc" id="L492">								treeLabelText = &quot;(blank)&quot;;</span>
							}
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">							label.setText(treeLabelText.length() &gt; maxLength ? treeLabelText.substring(0, maxLength) + &quot;...&quot; : treeLabelText);</span>
<span class="fc" id="L495">							label.setIcon(treeLabel.getIcon());</span>
							
							LabelJsTreeNodeSupplierFactoryAdapter&lt;?&gt; adapter;
<span class="fc bfc" id="L498" title="All 2 branches covered.">							if (label instanceof Link) {</span>
<span class="fc" id="L499">								URI bURI = uriResolver.apply(action, (URI) null);</span>
<span class="fc" id="L500">								URI tURI = uriResolver.apply(treeLabel, bURI);</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">								if (tURI != null) {</span>
<span class="fc" id="L502">									((Link) label).setLocation(tURI.toString());</span>
								}
<span class="fc" id="L504">								adapter = new LinkJsTreeNodeSupplierFactoryAdapter&lt;Link&gt;((Link) label);</span>
<span class="fc" id="L505">							} else {</span>
<span class="fc" id="L506">								adapter = new LabelJsTreeNodeSupplierFactoryAdapter&lt;&gt;(label);				</span>
							}
							
							try {
<span class="fc" id="L510">								JsTreeNode jsTreeNode = adapter.create(context).execute(progressMonitor);</span>
<span class="fc" id="L511">								jsTreeNode.attribute(Util.DATA_NSD_LABEL_UUID_ATTRIBUTE, treeLabel.getUuid());</span>
<span class="fc" id="L512">								nodeMap.put(semanticElementAnnotation, jsTreeNode);</span>
<span class="nc" id="L513">							} catch (Exception e) {</span>
<span class="nc" id="L514">								throw new NasdanikaException(e);</span>
<span class="fc" id="L515">							}</span>
						}
					}
				}
<span class="fc" id="L519">			}</span>
		}
				
<span class="fc" id="L522">		JsTreeFactory jsTreeFactory = context.get(JsTreeFactory.class, JsTreeFactory.INSTANCE);</span>
<span class="fc" id="L523">		SemanticMap&lt;ContainerInfo, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; groupedByContainer = new SemanticMap&lt;&gt;();</span>
<span class="fc" id="L524">		org.nasdanika.common.Util.groupBy(nodeMap.entrySet(), sea -&gt; ((SemanticInfo) sea.getKey()).getContainerInfo(), groupedByContainer);</span>
<span class="fc" id="L525">		SemanticMap&lt;ContainerInfo, List&lt;Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt;&gt;&gt; groupedByContainerAndReferenceName = new SemanticMap&lt;&gt;();</span>
<span class="fc" id="L526">		groupedByContainer</span>
<span class="fc" id="L527">			.entrySet()</span>
<span class="fc" id="L528">			.stream()</span>
<span class="fc" id="L529">			.map(e -&gt; mapEntry(e.getKey(), org.nasdanika.common.Util.groupBy(e.getValue(), ve -&gt; SiteGenerator.containmentRef(ve.getKey()))))</span>
<span class="fc" id="L530">			.forEach(e -&gt; groupedByContainerAndReferenceName.put(e.getKey(), createReferenceJsTreeNodes(e.getValue(), jsTreeFactory)));</span>
		
		// Organizing JsTreeNodes into a tree - going over all SemanticInfo entries and moving containerInfo's from groupedByContainerAndReferenceName under
<span class="fc" id="L533">		List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt; allEntries = groupedByContainerAndReferenceName</span>
<span class="fc" id="L534">				.values()</span>
<span class="fc" id="L535">				.stream()</span>
<span class="fc" id="L536">				.flatMap(Collection::stream)</span>
<span class="fc" id="L537">				.flatMap(e -&gt; e.getValue().stream())</span>
<span class="fc" id="L538">				.collect(Collectors.toList());</span>
		
<span class="fc bfc" id="L540" title="All 2 branches covered.">		for (Entry&lt;SemanticInfo, JsTreeNode&gt; entry: allEntries) {</span>
			@SuppressWarnings(&quot;unlikely-arg-type&quot;)
<span class="fc" id="L542">			List&lt;Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt;&gt; children = groupedByContainerAndReferenceName.remove(entry.getKey());</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">			if (children != null) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">				for (Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; childEntry: children) {</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">					if (childEntry != null) {</span>
<span class="fc" id="L546">						JsTreeNode refNode = childEntry.getKey();</span>
<span class="fc" id="L547">						List&lt;JsTreeNode&gt; entryValueChildren = entry.getValue().children();</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">						if (refNode == null) {</span>
<span class="nc" id="L549">							List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt; grandChildren = childEntry.getValue();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">							if (grandChildren != null) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">								for (Entry&lt;SemanticInfo, JsTreeNode&gt; grandChild: grandChildren) {</span>
<span class="nc" id="L552">									entryValueChildren.add(grandChild.getValue());</span>
<span class="nc" id="L553">								}</span>
							}
<span class="nc" id="L555">						} else {</span>
<span class="fc" id="L556">							entryValueChildren.add(refNode);</span>
						}
					}
<span class="fc" id="L559">				}</span>
			}
<span class="fc" id="L561">		}</span>
		
<span class="fc" id="L563">		List&lt;JsTreeNode&gt; roots = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">		for (Entry&lt;JsTreeNode, List&lt;Entry&lt;SemanticInfo, JsTreeNode&gt;&gt;&gt; re: groupedByContainerAndReferenceName.values().stream().flatMap(Collection::stream).collect(Collectors.toList())) {</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">			if (re != null) {</span>
<span class="fc" id="L566">				JsTreeNode reKey = re.getKey();</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">				if (reKey == null) {</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">					for (Entry&lt;SemanticInfo, JsTreeNode&gt; childEntry: re.getValue()) {</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">						if (childEntry != null) {</span>
<span class="fc" id="L570">							roots.add(childEntry.getValue());</span>
						}
<span class="fc" id="L572">					}</span>
				} else {
<span class="nc" id="L574">					roots.add(reKey);</span>
				}
			}
<span class="fc" id="L577">		}		</span>
		
<span class="fc" id="L579">		JSONObject jsTree = jsTreeFactory.buildJsTree(roots);</span>

<span class="fc" id="L581">		List&lt;String&gt; plugins = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L582">		plugins.add(&quot;state&quot;);</span>
<span class="fc" id="L583">		plugins.add(&quot;search&quot;);</span>
<span class="fc" id="L584">		JSONObject searchConfig = new JSONObject();</span>
<span class="fc" id="L585">		searchConfig.put(&quot;show_only_matches&quot;, true);</span>
<span class="fc" id="L586">		jsTree.put(&quot;search&quot;, searchConfig);</span>
<span class="fc" id="L587">		jsTree.put(&quot;plugins&quot;, plugins); 		</span>
<span class="fc" id="L588">		jsTree.put(&quot;state&quot;, Collections.singletonMap(&quot;key&quot;, &quot;nsd-site-map-tree&quot;));</span>
		
		// Deletes selection from state
<span class="fc" id="L591">		String filter = NavigationPanelConsumerFactoryAdapter.CLEAR_STATE_FILTER + &quot; tree.search.search_callback = (results, node) =&gt; results.split(' ').includes(node.original['data-nsd-label-uuid']);&quot;;</span>
		
<span class="fc" id="L593">		return jsTreeFactory.bind(&quot;#nsd-site-map-tree&quot;, jsTree, filter, null).toString();					</span>
	}
	
	protected boolean isParentReference(EReference eReference) {
<span class="nc bnc" id="L597" title="All 4 branches missed.">		return eReference.isContainment() || eReference == NcorePackage.Literals.REFERENCE__TARGET;</span>
	}
	
	/**
	 * Computes a table of contents for a Drawio element
	 * @param element
	 * @param context
	 * @return
	 */
	protected Object computeTableOfContents(org.nasdanika.drawio.Element element, Context context) {
<span class="nc" id="L607">		HTMLFactory htmlFactory = context.get(HTMLFactory.class, HTMLFactory.INSTANCE);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">		if (element instanceof org.nasdanika.drawio.Document) {</span>
<span class="nc" id="L609">			List&lt;Page&gt; pages = ((org.nasdanika.drawio.Document) element).getPages();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">			if (pages.size() == 1) {</span>
<span class="nc" id="L611">				return computeTableOfContents(pages.get(0), context);</span>
			}
<span class="nc" id="L613">			Tag ol = htmlFactory.tag(TagName.ol);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">			for (Page page: pages) {</span>
<span class="nc" id="L615">				Tag li = htmlFactory.tag(TagName.li, page.getName(), computeTableOfContents(page, context));</span>
<span class="nc" id="L616">				ol.content(li);</span>
<span class="nc" id="L617">			}</span>
<span class="nc" id="L618">			return ol;</span>
		}
		
<span class="nc bnc" id="L621" title="All 2 branches missed.">		if (element instanceof Page) {</span>
<span class="nc" id="L622">			List&lt;Layer&gt; layers = new ArrayList&lt;&gt;(((Page) element).getModel().getRoot().getLayers());</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">			if (layers.size() == 1) {</span>
<span class="nc" id="L624">				return computeTableOfContents(layers.get(0), context);</span>
			}
<span class="nc" id="L626">			Collections.reverse(layers);</span>
<span class="nc" id="L627">			Tag ol = htmlFactory.tag(TagName.ol);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">			for (Layer layer: layers) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">				if (org.nasdanika.common.Util.isBlank(layer.getLabel())) {</span>
<span class="nc" id="L630">					ol.content(computeTableOfContents(layer, context));</span>
				} else {
<span class="nc" id="L632">					Tag li = htmlFactory.tag(</span>
							TagName.li, 
<span class="nc bnc" id="L634" title="All 4 branches missed.">							org.nasdanika.common.Util.isBlank(layer.getLink()) || layer.getLinkedPage() != null ? layer.getLabel() : htmlFactory.tag(TagName.a, layer.getLabel()).attribute(&quot;href&quot;, layer.getLink()),</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">							org.nasdanika.common.Util.isBlank(layer.getTooltip()) ? &quot;&quot; : &quot; - &quot; + Jsoup.parse(layer.getTooltip()).text() ,</span>
<span class="nc" id="L636">							computeTableOfContents(layer, context));</span>
<span class="nc" id="L637">					ol.content(li);								</span>
				}							
<span class="nc" id="L639">			}</span>
<span class="nc" id="L640">			return ol;</span>
		}
		
<span class="nc bnc" id="L643" title="All 2 branches missed.">		if (element instanceof Layer) { // Including nodes</span>
<span class="nc" id="L644">			List&lt;LayerElement&gt; layerElements = new ArrayList&lt;&gt;(((Layer) element).getElements());</span>
<span class="nc" id="L645">			Collections.sort(layerElements, new LabelModelElementComparator(false)); // TODO - use &quot;sort&quot; property</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">			if (element instanceof org.nasdanika.drawio.Node) {</span>
<span class="nc" id="L647">				List&lt;LayerElement&gt; outgoingConnections = new ArrayList&lt;&gt;(((org.nasdanika.drawio.Node) element).getOutgoingConnections());</span>
<span class="nc" id="L648">				Collections.sort(outgoingConnections, new LabelModelElementComparator(false));</span>
<span class="nc" id="L649">				layerElements.addAll(outgoingConnections);</span>
			}
			
<span class="nc" id="L652">			Tag ol = htmlFactory.tag(TagName.ol);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">			for (LayerElement layerElement: layerElements) {</span>
<span class="nc bnc" id="L654" title="All 8 branches missed.">				if (layerElement instanceof org.nasdanika.drawio.Node || (layerElement instanceof Connection &amp;&amp; (((Connection) layerElement).getSource() == null || ((Connection) layerElement).getSource() == element))) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">					if (org.nasdanika.common.Util.isBlank(layerElement.getLabel())) { </span>
<span class="nc" id="L656">						ol.content(computeTableOfContents(layerElement, context));</span>
					} else {
<span class="nc" id="L658">						Tag li = htmlFactory.tag(</span>
								TagName.li,
<span class="nc bnc" id="L660" title="All 4 branches missed.">								org.nasdanika.common.Util.isBlank(layerElement.getLink()) || layerElement.getLinkedPage() != null ? Jsoup.parse(layerElement.getLabel()).text() : htmlFactory.tag(TagName.a, Jsoup.parse(layerElement.getLabel()).text()).attribute(&quot;href&quot;, layerElement.getLink()),										</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">								org.nasdanika.common.Util.isBlank(layerElement.getTooltip()) ? &quot;&quot; : &quot; - &quot; + Jsoup.parse(layerElement.getTooltip()).text() ,</span>
<span class="nc" id="L662">										computeTableOfContents(layerElement, context));</span>
<span class="nc" id="L663">						ol.content(li);								</span>
					}
				}
<span class="nc" id="L666">			}</span>
<span class="nc" id="L667">			return ol;						</span>
		}
		
<span class="nc" id="L670">		return null; 		</span>
	}
	
	/**
	 * Computes a info YAML dump for a Drawio element
	 * @param element
	 * @param context
	 * @return
	 */
	protected String computeInfo(Action action, org.nasdanika.drawio.Element element, Context context) {
<span class="nc" id="L680">		DumperOptions dumperOptions = new DumperOptions();</span>
<span class="nc" id="L681">		dumperOptions.setDefaultFlowStyle(FlowStyle.BLOCK); dumperOptions.setIndent(4);</span>
<span class="nc" id="L682">		Map&lt;String, Object&gt; infoMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L683">		Map&lt;String, Object&gt; actionMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (!org.nasdanika.common.Util.isBlank(action.getText())) {</span>
<span class="nc" id="L685">			actionMap.put(&quot;text&quot;, action.getText());</span>
		}
<span class="nc" id="L687">		List&lt;URI&gt; actionURIs = NcoreUtil.getIdentifiers(action);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if (actionURIs.size() == 1) {</span>
<span class="nc" id="L689">			actionMap.put(&quot;uri&quot;, actionURIs.get(0).toString());</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">		} else if (!actionURIs.isEmpty()) {</span>
<span class="nc" id="L691">			actionMap.put(&quot;uris&quot;, actionURIs.stream().map(Object::toString).collect(Collectors.toList()));			</span>
		}
<span class="nc" id="L693">		EList&lt;org.nasdanika.ncore.Marker&gt; actionMarkers = action.getMarkers();</span>
<span class="nc bnc" id="L694" title="All 4 branches missed.">		if (actionMarkers != null &amp;&amp; !actionMarkers.isEmpty()) {</span>
<span class="nc" id="L695">			actionMap.put(&quot;markers&quot;, actionMarkers.stream().map(am -&gt; DefaultConverter.INSTANCE.toMap(am, null)).toArray());</span>
		}
<span class="nc" id="L697">		infoMap.put(&quot;action&quot;, actionMap);</span>
<span class="nc" id="L698">		Map&lt;String, Object&gt; elementInfo = element.accept((el, childInfo) -&gt; this.elementInfo(el, childInfo, actionURIs));</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">		if (elementInfo != null) {</span>
<span class="nc" id="L700">			infoMap.put(&quot;element&quot;, elementInfo);</span>
		}
<span class="nc" id="L702">		StringWriter out = new StringWriter();</span>
<span class="nc" id="L703">		try (out) {</span>
<span class="nc" id="L704">			new Yaml(dumperOptions).dump(infoMap, out);</span>
<span class="nc" id="L705">		} catch (Exception e) {</span>
<span class="nc" id="L706">			return &quot;Error computing representation info: &quot; + e;			</span>
<span class="nc" id="L707">		}		</span>
<span class="nc" id="L708">		return out.toString();</span>
	}
	
	private Map&lt;String, Object&gt; elementInfo(Element element, Map&lt;? extends Element, Map&lt;String, Object&gt;&gt; childInfo, List&lt;URI&gt; actionURIs) {
<span class="nc" id="L712">		Map&lt;String, Object&gt; info = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L713">		info.put(&quot;type&quot;, element.getClass().getName());</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">		if (element instanceof org.nasdanika.drawio.Element) {</span>
<span class="nc" id="L715">			org.nasdanika.drawio.Element drawioElement = (org.nasdanika.drawio.Element) element;</span>
<span class="nc" id="L716">			URI uri = drawioElement.getURI();</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">			if (uri != null) {</span>
<span class="nc" id="L718">				info.put(&quot;uri&quot;, uri.toString());</span>
			}
<span class="nc" id="L720">			List&lt;? extends Marker&gt; markers = drawioElement.getMarkers();</span>
<span class="nc bnc" id="L721" title="All 4 branches missed.">			if (markers != null &amp;&amp; !markers.isEmpty()) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">				info.put(&quot;markers&quot;, markers.stream().map(em -&gt; em instanceof EObject ? DefaultConverter.INSTANCE.toMap((EObject) em, null) : String.valueOf(em)).toArray());				</span>
			}
		}
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (element instanceof org.nasdanika.drawio.Page) {</span>
<span class="nc" id="L726">			org.nasdanika.drawio.Page page = (org.nasdanika.drawio.Page) element;</span>
<span class="nc" id="L727">			String pageName = page.getName();</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(pageName)) {</span>
<span class="nc" id="L729">				info.put(&quot;name&quot;, pageName);</span>
			}
<span class="nc" id="L731">			String id = page.getId();</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(id)) {</span>
<span class="nc" id="L733">				info.put(&quot;id&quot;, id);</span>
			}
		}
<span class="nc bnc" id="L736" title="All 2 branches missed.">		if (element instanceof org.nasdanika.drawio.ModelElement) {</span>
<span class="nc" id="L737">			org.nasdanika.drawio.ModelElement modelElement = (org.nasdanika.drawio.ModelElement) element;</span>
<span class="nc" id="L738">			String id = modelElement.getId();</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(id)) {</span>
<span class="nc" id="L740">				info.put(&quot;id&quot;, id);</span>
			}
			
<span class="nc" id="L743">			String label = modelElement.getLabel();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(label)) {</span>
<span class="nc" id="L745">				info.put(&quot;label&quot;, label);</span>
			}
			
<span class="nc" id="L748">			String tooltip = modelElement.getTooltip();</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">			if (!org.nasdanika.common.Util.isBlank(tooltip)) {</span>
<span class="nc" id="L750">				info.put(&quot;tooltip&quot;, tooltip);</span>
			}
			
<span class="nc bnc" id="L753" title="All 2 branches missed.">			if (modelElement.isPageLink()) {</span>
<span class="nc" id="L754">				info.put(&quot;linked-page&quot;, modelElement.getLinkedPage().toString());</span>
			} else {
<span class="nc" id="L756">				String link = modelElement.getLink();</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">				if (!org.nasdanika.common.Util.isBlank(link)) {</span>
<span class="nc" id="L758">					info.put(&quot;link&quot;, link);</span>
				}				
			}
<span class="nc" id="L761">			Map&lt;String, String&gt; style = modelElement.getStyle();</span>
<span class="nc bnc" id="L762" title="All 4 branches missed.">			if (style != null &amp;&amp; !style.isEmpty()) {</span>
<span class="nc" id="L763">				info.put(&quot;style&quot;, style);</span>
			}
			
<span class="nc" id="L766">			Set&lt;String&gt; tags = modelElement.getTags();</span>
<span class="nc bnc" id="L767" title="All 4 branches missed.">			if (tags != null &amp;&amp; !tags.isEmpty()) {</span>
<span class="nc" id="L768">				info.put(&quot;tags&quot;, tags);</span>
			}
			
<span class="nc" id="L771">			info.put(&quot;visible&quot;, modelElement.isVisible());		</span>

			// Properties
<span class="nc" id="L774">			NamedNodeMap attributes = modelElement.getElement().getAttributes();</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">			if (attributes != null) {</span>
<span class="nc" id="L776">				Map&lt;String, String&gt; properties = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">				for (int i = 0; i &lt; attributes.getLength(); ++i) {</span>
<span class="nc" id="L778">					org.w3c.dom.Node attribute = attributes.item(i);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">					if (attribute instanceof Attr) {</span>
<span class="nc" id="L780">						String propertyName = ((Attr) attribute).getName();</span>
<span class="nc" id="L781">						String propertyValue = modelElement.getProperty(propertyName);</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">						if (!org.nasdanika.common.Util.isBlank(propertyValue)) {</span>
<span class="nc" id="L783">							properties.put(propertyName, propertyValue);</span>
						}
					}
				}
<span class="nc bnc" id="L787" title="All 2 branches missed.">				if (!properties.isEmpty()) {</span>
<span class="nc" id="L788">					info.put(&quot;properties&quot;, properties);</span>
				}
			}
			
<span class="nc" id="L792">			Collection&lt;URI&gt; elementActionURIs = NcoreActionBuilder.resolveURIs(NcoreActionBuilder.ACTION_URI_KEY, modelElement, actionURIs, false);</span>
<span class="nc bnc" id="L793" title="All 4 branches missed.">			if (elementActionURIs != null &amp;&amp; !elementActionURIs.isEmpty()) {</span>
<span class="nc" id="L794">				info.put(&quot;action-uris&quot;, elementActionURIs.stream().map(Object::toString).toArray());</span>
			}
			
<span class="nc" id="L797">			Collection&lt;URI&gt; elementActionUriBases = NcoreActionBuilder.resolveURIs(NcoreActionBuilder.ACTION_URI_KEY, modelElement, actionURIs, true);</span>
<span class="nc bnc" id="L798" title="All 4 branches missed.">			if (elementActionUriBases != null &amp;&amp; !elementActionUriBases.isEmpty()) {</span>
<span class="nc" id="L799">				info.put(&quot;action-uri-bases&quot;, elementActionUriBases.stream().map(Object::toString).toArray());</span>
			}
			
<span class="nc" id="L802">			Collection&lt;URI&gt; elementTargetURIs = NcoreActionBuilder.resolveURIs(NcoreActionBuilder.TARGET_URI_KEY, modelElement, actionURIs, false);</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">			if (elementTargetURIs != null &amp;&amp; !elementTargetURIs.isEmpty()) {</span>
<span class="nc" id="L804">				info.put(&quot;target-uris&quot;, elementTargetURIs.stream().map(Object::toString).toArray());</span>
			}
			
<span class="nc" id="L807">			Collection&lt;URI&gt; elementTargetUriBases = NcoreActionBuilder.resolveURIs(NcoreActionBuilder.TARGET_URI_KEY, modelElement, actionURIs, true);</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">			if (elementTargetUriBases != null &amp;&amp; !elementTargetUriBases.isEmpty()) {</span>
<span class="nc" id="L809">				info.put(&quot;target-uri-bases&quot;, elementTargetUriBases.stream().map(Object::toString).toArray());</span>
			}
			
		}
<span class="nc bnc" id="L813" title="All 2 branches missed.">		if (element instanceof Connection) {</span>
<span class="nc" id="L814">			Node source = ((Connection) element).getSource();</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">			if (source != null) {</span>
<span class="nc" id="L816">				info.put(&quot;source&quot;, source.toString());</span>
			}
<span class="nc" id="L818">			Node target = ((Connection) element).getTarget();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">			if (target != null) {</span>
<span class="nc" id="L820">				info.put(&quot;target&quot;, target.toString());</span>
			}
		}
<span class="nc bnc" id="L823" title="All 2 branches missed.">		if (element instanceof Node) {</span>
<span class="nc" id="L824">			List&lt;Connection&gt; incomingConnections = ((Node) element).getIncomingConnections();</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">			if (incomingConnections != null &amp;&amp; !incomingConnections.isEmpty()) {</span>
<span class="nc" id="L826">				info.put(&quot;incoming-connections&quot;, incomingConnections.stream().map(Object::toString).toArray());</span>
			}
<span class="nc" id="L828">			List&lt;Connection&gt; outgoingConnections = ((Node) element).getOutgoingConnections();</span>
<span class="nc bnc" id="L829" title="All 4 branches missed.">			if (outgoingConnections != null &amp;&amp; !outgoingConnections.isEmpty()) {</span>
<span class="nc" id="L830">				info.put(&quot;outgoing-connections&quot;, outgoingConnections.stream().map(Object::toString).toArray());</span>
			}
		}
		
<span class="nc bnc" id="L834" title="All 4 branches missed.">		if (childInfo != null &amp;&amp; !childInfo.isEmpty()) {</span>
<span class="nc" id="L835">			info.put(&quot;children&quot;, childInfo.values().stream().toArray());</span>
		}
<span class="nc" id="L837">		return info;</span>
	}
	
	/**
	 * Computes semantic link. This implementation uses the registry and uriResolver. 
	 * Override to add support of resolving external semantic links, e.g. loaded from semantic maps of dependency sites.
	 * @param context
	 * @param key
	 * @param path
	 * @param action
	 * @param baseSemanticURI
	 * @param uriResolver
	 * @param registry
	 * @return
	 */
	protected String computeSemanticLink(
			Context context, 
			String key, 
			String path, 
			Action action,
			Collection&lt;URI&gt; baseSemanticURIs,
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			ResolutionListener resolutionListener,
			ProgressMonitor progressMonitor) {
		
<span class="nc" id="L863">		int spaceIdx = path.indexOf(' ');</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">		String targetUriStr = spaceIdx == -1 ? path : path.substring(0, spaceIdx);</span>

<span class="nc bnc" id="L866" title="All 4 branches missed.">		if (baseSemanticURIs == null || baseSemanticURIs.isEmpty()) {</span>
<span class="nc" id="L867">			baseSemanticURIs = Collections.singleton(null);</span>
		}
<span class="nc bnc" id="L869" title="All 2 branches missed.">		for (URI baseSemanticURI: baseSemanticURIs) {</span>
<span class="nc" id="L870">			URI targetURI = URI.createURI(targetUriStr);</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">			if (baseSemanticURI != null &amp;&amp; targetURI.isRelative()) {</span>
<span class="nc" id="L872">				targetURI = targetURI.resolve(baseSemanticURI.appendSegment(&quot;&quot;));</span>
			}	
<span class="nc" id="L874">			URI bURI = uriResolver.apply(action, (URI) null);				</span>
	
<span class="nc bnc" id="L876" title="All 2 branches missed.">			if (semanticInfoSource != null) {</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">				for (Entry&lt;SemanticInfo, ?&gt; entry: semanticInfoSource) {</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">					if (entry != null) {</span>
<span class="nc" id="L879">						Object value = entry.getValue();</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">						if (value instanceof Label) {</span>
<span class="nc" id="L881">							Label targetLabel = (Label) value;</span>
<span class="nc" id="L882">							SemanticInfo semanticElementAnnotation = entry.getKey();</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">							if (semanticElementAnnotation != null) {</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">								for (URI semanticURI: semanticElementAnnotation.getIdentifiers()) {</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">									if (Objects.equals(targetURI, semanticURI)) {</span>
<span class="nc" id="L886">										Label tLabel = Util.createLabel(targetLabel, action, uriResolver, null, null, false, false, false);</span>
<span class="nc" id="L887">										SupplierFactory&lt;Tag&gt; tagSupplierFactory = EObjectAdaptable.adaptToSupplierFactory(tLabel, Tag.class, new AppAdapterFactory());</span>
										Tag tag; 
<span class="nc bnc" id="L889" title="All 2 branches missed.">										if (tagSupplierFactory == null) {</span>
<span class="nc" id="L890">											HTMLFactory htmlFactory = context.get(HTMLFactory.class, HTMLFactory.INSTANCE);</span>
<span class="nc" id="L891">											URI targetActionURI = uriResolver.apply(targetLabel, bURI);</span>
<span class="nc bnc" id="L892" title="All 4 branches missed.">											tag = htmlFactory.tag(targetActionURI == null ? TagName.span : TagName.a, spaceIdx == -1 ? targetLabel.getText() : path.substring(spaceIdx + 1));</span>
<span class="nc" id="L893">											String targetActionTooltip = targetLabel.getTooltip();</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">											if (!org.nasdanika.common.Util.isBlank(targetActionTooltip)) {</span>
<span class="nc" id="L895">												tag.attribute(&quot;title&quot;, targetActionTooltip);</span>
											}
<span class="nc bnc" id="L897" title="All 2 branches missed.">											if (targetActionURI != null) {</span>
<span class="nc" id="L898">												tag.attribute(&quot;href&quot;, targetActionURI.toString());</span>
											}
<span class="nc" id="L900">										} else {</span>
<span class="nc" id="L901">											tag = tagSupplierFactory.create(context).execute(progressMonitor);</span>
										}
<span class="nc bnc" id="L903" title="All 2 branches missed.">										if (resolutionListener != null) {</span>
<span class="nc" id="L904">											URI rawTargetURI = uriResolver.apply(targetLabel, null);</span>
<span class="nc" id="L905">											URI backLinkURI = uriResolver.apply(action, rawTargetURI);</span>
<span class="nc" id="L906">											resolutionListener.onSemanticReferenceResolution(action, path, targetLabel, targetURI, backLinkURI);</span>
										}										
<span class="nc" id="L908">										return tag.toString(); </span>
									}
<span class="nc" id="L910">								}</span>
							}
						}
					}
<span class="nc" id="L914">				}</span>
			}
					
<span class="nc" id="L917">			String semanticLink = computeSemanticLink(targetURI, bURI, context, resolutionListener);</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">			if (semanticLink != null) {				</span>
<span class="nc" id="L919">				return semanticLink;</span>
			}
<span class="nc" id="L921">		}</span>
		
<span class="nc" id="L923">		String message = &quot;Unresolved semantic URI: &quot; + targetUriStr;</span>
<span class="nc" id="L924">		progressMonitor.worked(Status.ERROR, 1, message, action);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">		if (resolutionListener != null) {</span>
<span class="nc" id="L926">			resolutionListener.onSemanticReferenceResolution(action, targetUriStr, null, null, null);</span>
		}
		
<span class="nc" id="L929">		return null;</span>
	}
	
	/**
	 * Computes semantic links for external URI's. This implementation returns null;
	 * @param targetURI 
	 * @param baseURI Base URI to deresolve link's reference to make it relative.
	 * @param context
	 * @return
	 */
	protected String computeSemanticLink(
			URI targetURI, 
			URI baseURI, 
			Context context,
			ResolutionListener resolutionListener) {
		
<span class="nc" id="L945">		return null;</span>
	}	

	/**
	 * Computes semantic reference. This implementation uses the registry and uriResolver. 
	 * Override to add support of resolving external semantic references, e.g. loaded from semantic maps of dependency sites.
	 * @param context
	 * @param key
	 * @param path
	 * @param action
	 * @param baseSemanticURI
	 * @param uriResolver
	 * @param registry
	 * @return
	 */
	protected URI computeSemanticReferfence(
			Context context, 
			String key, 
			String path,
			Action action,
			Collection&lt;URI&gt; baseSemanticURIs,
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			ResolutionListener resolutionListener,
			ProgressMonitor progressMonitor) {

<span class="pc bpc" id="L971" title="2 of 4 branches missed.">		if (baseSemanticURIs == null || baseSemanticURIs.isEmpty()) {</span>
<span class="fc" id="L972">			baseSemanticURIs = Collections.singleton(null);</span>
		}
<span class="fc bfc" id="L974" title="All 2 branches covered.">		for (URI baseSemanticURI: baseSemanticURIs) {</span>
<span class="fc" id="L975">			URI targetURI = URI.createURI(path);</span>
<span class="pc bpc" id="L976" title="3 of 4 branches missed.">			if (baseSemanticURI != null &amp;&amp; targetURI.isRelative()) {</span>
<span class="nc" id="L977">				targetURI = targetURI.resolve(baseSemanticURI.appendSegment(&quot;&quot;));</span>
			}	
<span class="fc" id="L979">			URI bURI = uriResolver.apply(action, (URI) null);		</span>
<span class="pc bpc" id="L980" title="1 of 2 branches missed.">			if (semanticInfoSource != null) {</span>
<span class="fc bfc" id="L981" title="All 2 branches covered.">				for (Entry&lt;SemanticInfo, ?&gt; entry: semanticInfoSource) {</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">					if (entry != null) {</span>
<span class="fc" id="L983">						Object value = entry.getValue();</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">						if (value instanceof Label) {</span>
<span class="fc" id="L985">							Label targetLabel = (Label) value;</span>
<span class="fc" id="L986">							SemanticInfo semanticElementAnnotation = entry.getKey();</span>
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">							if (semanticElementAnnotation != null) {</span>
<span class="fc bfc" id="L988" title="All 2 branches covered.">								for (URI semanticURI: semanticElementAnnotation.getIdentifiers()) {</span>
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">									if (Objects.equals(targetURI, semanticURI)) {</span>
<span class="nc" id="L990">										URI targetActionURI = uriResolver.apply(targetLabel, bURI);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">										if (targetActionURI != null) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">											if (resolutionListener != null) {</span>
<span class="nc" id="L993">												URI rawTargetURI = uriResolver.apply(targetLabel, null);</span>
<span class="nc" id="L994">												URI backLinkURI = uriResolver.apply(action, rawTargetURI);</span>
<span class="nc" id="L995">												resolutionListener.onSemanticReferenceResolution(action, path, targetLabel, targetURI, backLinkURI);</span>
											}
											
<span class="nc" id="L998">											return targetActionURI;</span>
										}
									}
<span class="fc" id="L1001">								}</span>
							}
						}
					}
<span class="fc" id="L1005">				}</span>
			}
			
<span class="fc" id="L1008">			URI ref = computeSemanticReference(targetURI, context);		</span>
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">			if (ref != null) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">				if (bURI != null) {</span>
<span class="nc" id="L1011">					ref = ref.deresolve(bURI, true, true, true);</span>
				}
<span class="nc bnc" id="L1013" title="All 2 branches missed.">				if (resolutionListener != null) {</span>
<span class="nc" id="L1014">					resolutionListener.onSemanticReferenceResolution(action, path, null, ref, null);</span>
				}				
<span class="nc" id="L1016">				return ref;</span>
			}
<span class="fc" id="L1018">		}</span>
		
<span class="fc" id="L1020">		String message = &quot;Unresolved semantic URI: &quot; + path;</span>
<span class="fc" id="L1021">		progressMonitor.worked(Status.ERROR, 1, message, action);</span>
<span class="pc bpc" id="L1022" title="1 of 2 branches missed.">		if (resolutionListener != null) {</span>
<span class="fc" id="L1023">			resolutionListener.onSemanticReferenceResolution(action, path, null, null, null);</span>
		}
<span class="fc" id="L1025">		return null;</span>
		
	}

	/**
	 * Computes semantic links for external URI's. This implementation returns null;
	 * @param targetURI
	 * @param context
	 * @return
	 */
	protected URI computeSemanticReference(URI targetURI, Context context) { 
<span class="fc" id="L1036">		return null;</span>
	}	
	
	/**
	 * {@link ActionContentProvider} method
	 * @param action
	 * @param uriResolver
	 * @param progressMonitor
	 * @return
	 */
	protected EList&lt;EObject&gt; getActionContent(
			Action action, 
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			File resourceWorkDir,
			Context context,
			java.util.function.Consumer&lt;Diagnostic&gt; diagnosticConsumer,
			ResolutionListener resolutionListener,						
			ProgressMonitor progressMonitor) {

<span class="fc" id="L1056">		List&lt;Object&gt; contentContributions = new ArrayList&lt;&gt;();</span>
		
<span class="fc" id="L1058">		Context actionContentContext = createActionContentContext(</span>
				action, 
				uriResolver, 
				semanticInfoSource, 
<span class="fc" id="L1062">				(ContentConsumer) contentContributions::add, </span>
				resolutionListener, 
				context, 
				progressMonitor);
		
<span class="fc" id="L1067">		File contentDir = new File(resourceWorkDir, &quot;content&quot;);</span>
<span class="fc" id="L1068">		contentDir.mkdirs();</span>
		
<span class="fc" id="L1070">		String fileName = action.getUuid() + &quot;.html&quot;;</span>
<span class="fc" id="L1071">		SupplierFactory&lt;InputStream&gt; contentFactory = org.nasdanika.common.Util.asInputStreamSupplierFactory(action.getContent());			</span>
<span class="fc" id="L1072">		try (InputStream contentStream = org.nasdanika.common.Util.call(contentFactory.create(actionContentContext), progressMonitor, diagnosticConsumer, Status.FAIL, Status.ERROR)) {</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">			if (contentContributions.isEmpty()) {</span>
<span class="fc" id="L1074">				Files.copy(contentStream, new File(contentDir, fileName).toPath(), StandardCopyOption.REPLACE_EXISTING);</span>
			} else {
<span class="nc" id="L1076">				Stream&lt;InputStream&gt; pageBodyContributionsStream = contentContributions.stream().filter(Objects::nonNull).map(e -&gt; {</span>
					try {
<span class="nc" id="L1078">						return DefaultConverter.INSTANCE.toInputStream(e.toString());</span>
<span class="nc" id="L1079">					} catch (IOException ex) {</span>
<span class="nc" id="L1080">						throw new NasdanikaException(&quot;Error converting element to InputStream: &quot; + ex, ex);</span>
					}
				});
<span class="nc" id="L1083">				Stream&lt;InputStream&gt; concatenatedStream = Stream.concat(pageBodyContributionsStream, Stream.of(contentStream));</span>
<span class="nc" id="L1084">				Files.copy(org.nasdanika.common.Util.join(concatenatedStream), new File(contentDir, fileName).toPath(), StandardCopyOption.REPLACE_EXISTING);</span>
			}
<span class="nc" id="L1086">		} catch (Exception e) {</span>
<span class="nc" id="L1087">			throw new NasdanikaException(e);</span>
<span class="fc" id="L1088">		}</span>
		
<span class="fc" id="L1090">		org.nasdanika.exec.content.Resource contentResource = ContentFactory.eINSTANCE.createResource();</span>
<span class="fc" id="L1091">		contentResource.setLocation(&quot;../content/&quot; + fileName);</span>
<span class="fc" id="L1092">		progressMonitor.worked(1, &quot;[Action content] &quot; + action.getText() + &quot; -&gt; &quot; + fileName);</span>
<span class="fc" id="L1093">		return ECollections.singletonEList(contentResource);					</span>
	}
	
	
	/**
	 * @param context
	 * @param key
	 * @param path
	 * @param action
	 * @param baseSemanticURI
	 * @param uriResolver
	 * @param registry
	 * @return
	 */
	protected Object computeRepresentation(
			Map&lt;String, Object&gt; representations,
			Context context, 
			String key, 
			String path, 
			Action action,
			Collection&lt;URI&gt; baseSemanticURIs,
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			ResolutionListener resolutionListener) {

<span class="fc" id="L1118">		String[] pathSegments = path.split(&quot;/&quot;);</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">		if (pathSegments.length == 1) {</span>
			// Non drawio representation, just a key
<span class="nc" id="L1121">			return representations.get(path);</span>
		}
		try {
<span class="fc" id="L1124">			org.nasdanika.drawio.Document valueDocument = (org.nasdanika.drawio.Document) representations.get(pathSegments[0]);</span>
<span class="pc bpc" id="L1125" title="1 of 2 branches missed.">			if (resolutionListener != null) {</span>
<span class="fc" id="L1126">				resolutionListener.onComputingDrawioRepresentation(action, pathSegments[0], valueDocument);</span>
			}
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">			if (valueDocument == null) {</span>
<span class="nc" id="L1129">				valueDocument = org.nasdanika.drawio.Document.create(false, null);</span>
<span class="nc" id="L1130">				Page page = valueDocument.createPage();</span>
<span class="nc" id="L1131">				page.setName(&quot;Error&quot;);</span>
				
<span class="nc" id="L1133">				Model model = page.getModel();</span>
<span class="nc" id="L1134">				Root root = model.getRoot();</span>
<span class="nc" id="L1135">				List&lt;Layer&gt; layers = root.getLayers();</span>
						
<span class="nc" id="L1137">				Node errorNode = layers.get(0).createNode();</span>
<span class="nc" id="L1138">				errorNode.setLabel(&quot;Representation not found: &quot; + pathSegments[0]);</span>
<span class="nc" id="L1139">				errorNode.getStyle().put(&quot;fillColor&quot;, &quot;#f8cecc&quot;);</span>
<span class="nc" id="L1140">				errorNode.getStyle().put(&quot;strokeColor&quot;, &quot;#b85450&quot;);</span>
				
<span class="nc" id="L1142">				Rectangle errorGeometry = errorNode.getGeometry();</span>
<span class="nc" id="L1143">				errorGeometry.setX(10);</span>
<span class="nc" id="L1144">				errorGeometry.setY(10);</span>
<span class="nc" id="L1145">				errorGeometry.setWidth(300);</span>
<span class="nc" id="L1146">				errorGeometry.setHeight(30);</span>
			}		
			
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">			if (pathSegments.length == 2) {</span>
				// Document
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">				if (&quot;diagram&quot;.equals(pathSegments[1])) {</span>
<span class="fc" id="L1152">					return valueDocument.save(true);</span>
				}
				
<span class="nc bnc" id="L1155" title="All 2 branches missed.">				if (&quot;toc&quot;.equals(pathSegments[1])) {</span>
<span class="nc" id="L1156">					return String.valueOf(computeTableOfContents(valueDocument, context));</span>
				}
									
<span class="nc bnc" id="L1159" title="All 2 branches missed.">				if (&quot;info&quot;.equals(pathSegments[1])) {</span>
<span class="nc" id="L1160">					return computeInfo(action, valueDocument, context);</span>
				}
				
<span class="nc" id="L1163">				return null;</span>
			} 
			
<span class="nc bnc" id="L1166" title="All 2 branches missed.">			if (pathSegments.length == 3) {</span>
				// Page
<span class="nc bnc" id="L1168" title="All 2 branches missed.">				for (Page page: valueDocument.getPages()) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">					if (pathSegments[1].equals(page.getName())) {</span>
<span class="nc" id="L1170">						org.nasdanika.drawio.Document pageDocument = org.nasdanika.drawio.Document.create(true, valueDocument.getURI());</span>
<span class="nc" id="L1171">						pageDocument.getPages().add(page);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">						if (&quot;diagram&quot;.equals(pathSegments[2])) {</span>
<span class="nc" id="L1173">							return pageDocument.save(true);</span>
						}
						
<span class="nc bnc" id="L1176" title="All 2 branches missed.">						if (&quot;toc&quot;.equals(pathSegments[2])) {</span>
<span class="nc" id="L1177">							return String.valueOf(computeTableOfContents(pageDocument, context));</span>
						}
						
<span class="nc bnc" id="L1180" title="All 2 branches missed.">						if (&quot;info&quot;.equals(pathSegments[2])) {</span>
<span class="nc" id="L1181">							return computeInfo(action, pageDocument, context);</span>
						}
					}
<span class="nc" id="L1184">				}</span>
			}
<span class="nc" id="L1186">		} catch (TransformerException | IOException | ParserConfigurationException e) {</span>
<span class="nc" id="L1187">			throw new NasdanikaException(e);</span>
<span class="nc" id="L1188">		}</span>
		
<span class="nc" id="L1190">		return null;		</span>
	}	
	
	protected SemanticInfo getSemanticInfoAnnotation(Action action) {
<span class="fc" id="L1194">		return SemanticInfo.getAnnotation(action);</span>
	}
	
	/**
	 * Registers semantic-link and semantic-ref property computers
	 * @param action
	 * @param uriResolver
	 * @param registry
	 * @param mctx
	 */
	protected Context createActionContentContext(
			Action action, 
			BiFunction&lt;Label, URI, URI&gt; uriResolver,
			Iterable&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; semanticInfoSource,
			ContentConsumer contentConsumer,
			ResolutionListener resolutionListener,						
			Context context,
			ProgressMonitor progressMonitor) {
		
<span class="fc" id="L1213">		MutableContext mctx = context.fork();</span>
<span class="fc" id="L1214">		mctx.put(&quot;nsd-site-map-tree-script&quot;, (Function&lt;Context, String&gt;) ctx -&gt; computeSiteMapTreeScript(ctx, action, uriResolver, semanticInfoSource, progressMonitor));</span>
		
<span class="pc bpc" id="L1216" title="1 of 2 branches missed.">		if (contentConsumer != null) {</span>
<span class="fc" id="L1217">			mctx.register(ContentConsumer.class, contentConsumer);</span>
		}
		
<span class="fc" id="L1220">		SemanticInfo semanticInfo = getSemanticInfoAnnotation(action);</span>
<span class="pc bpc" id="L1221" title="2 of 6 branches missed.">		Collection&lt;URI&gt; baseSemanticURIs = semanticInfo == null ? Collections.emptyList() : semanticInfo.getIdentifiers().stream().filter(u -&gt; !u.isRelative() &amp;&amp; u.isHierarchical()).collect(Collectors.toList());					</span>
		
<span class="fc" id="L1223">		Map&lt;String, Object&gt; representations = NcoreActionBuilder.resolveRepresentationLinks(</span>
				action, 
				semanticInfoSource,
				uriResolver, 
				resolutionListener, 
				progressMonitor);
		
<span class="fc" id="L1230">		PropertyComputer representationsPropertyComputer = new PropertyComputer() {</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T compute(Context ctx, String key, String path, Class&lt;T&gt; type) {
<span class="pc bpc" id="L1235" title="2 of 4 branches missed.">				if (type == null || type.isAssignableFrom(String.class)) {</span>
<span class="fc" id="L1236">					return (T) computeRepresentation(</span>
							representations, 
							ctx, 
							key, 
							path, 
							action, 
							baseSemanticURIs, 
							uriResolver, 
							semanticInfoSource,
							resolutionListener);			
				}
<span class="nc" id="L1247">				return null;</span>
			}
		}; 
		
<span class="fc" id="L1251">		mctx.put(&quot;representations&quot;, representationsPropertyComputer);</span>
		
<span class="fc" id="L1253">		PropertyComputer semanticLinkPropertyComputer = new PropertyComputer() {</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T compute(Context ctx, String key, String path, Class&lt;T&gt; type) {
<span class="nc bnc" id="L1258" title="All 4 branches missed.">				if (type == null || type.isAssignableFrom(String.class)) {</span>
<span class="nc" id="L1259">					return (T) computeSemanticLink(</span>
							ctx, 
							key, 
							path, 
							action, 
							baseSemanticURIs, 
							uriResolver, 
							semanticInfoSource, 
							resolutionListener,  
							progressMonitor);			
				}
<span class="nc" id="L1270">				return null;</span>
			}
		}; 
		
<span class="fc" id="L1274">		mctx.put(&quot;semantic-link&quot;, semanticLinkPropertyComputer);</span>
					
<span class="fc" id="L1276">		PropertyComputer semanticReferencePropertyComputer = new PropertyComputer() {</span>
			
			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			public &lt;T&gt; T compute(Context propertyComputerContext, String key, String path, Class&lt;T&gt; type) {
<span class="pc bpc" id="L1281" title="2 of 4 branches missed.">				if (type == null || type.isAssignableFrom(String.class)) {</span>
<span class="fc" id="L1282">					URI sRef = computeSemanticReferfence(</span>
							propertyComputerContext, 
							key, 
							path, 
							action, 
							baseSemanticURIs, 
							uriResolver, 
							semanticInfoSource, 
							resolutionListener,  
							progressMonitor);
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">					return sRef == null ? null : (T) sRef.toString();</span>
				}
<span class="nc" id="L1294">				return null;</span>
			}
		};
		
<span class="fc" id="L1298">		mctx.put(&quot;semantic-ref&quot;, semanticReferencePropertyComputer);</span>
		
<span class="fc" id="L1300">		return mctx;</span>
	}	
	
	/**
	 * Generates files from the previously generated resource model.
	 * @throws org.eclipse.emf.common.util.DiagnosticException 
	 * @throws IOException 
	 * @throws Exception
	 */
	protected Map&lt;String, Collection&lt;String&gt;&gt; generateContainer(
			Resource resourceModel,
			// TODO backlinks info provided by the resolution listener
			File workDir,
			File outputDir,
			Predicate&lt;String&gt; cleanPredicate,
			String siteMapDomain,
			String containerName, 
			Context context, 
			ProgressMonitor progressMonitor) throws org.eclipse.emf.common.util.DiagnosticException, IOException {
<span class="fc" id="L1319">		Map&lt;String, Collection&lt;String&gt;&gt; errors = new TreeMap&lt;&gt;();</span>
		
<span class="fc" id="L1321">		Util.generateContainer(</span>
				resourceModel, 
				new FileSystemContainer(workDir), 
				context, 
				progressMonitor);
		
<span class="fc" id="L1327">		org.nasdanika.common.Util.copy(new File(workDir, containerName), outputDir, true, cleanPredicate, null);</span>
		
<span class="fc" id="L1329">		Util.generateSitemapAndSearch(</span>
				outputDir, 
				siteMapDomain, 
				this::isSiteMap, 
<span class="fc" id="L1333">				getChangeFrequency(), </span>
				this::isSearch, 
				(path, error) -&gt;  {
<span class="fc" id="L1336">					progressMonitor.worked(Status.ERROR, 1, &quot;[&quot; + path +&quot;] &quot; + error);</span>
<span class="fc" id="L1337">					errors.computeIfAbsent(path, p -&gt; new ArrayList&lt;&gt;()).add(error);</span>
<span class="fc" id="L1338">				});</span>
		
<span class="fc" id="L1340">		HTMLProcessor htmlProcessor = new HTMLProcessor() {</span>
			
			@Override
			public boolean process(File file, String path, Document document) {
//				System.out.println(path + &quot; -&gt; &quot; + file.getAbsolutePath());
				// TODO - Backlinks injection
<span class="fc" id="L1346">				return false;</span>
			}
		};
		
<span class="fc" id="L1350">		Util.processHTML(htmlProcessor, outputDir.listFiles());</span>
		
<span class="fc" id="L1352">		return errors;</span>
	}
	
	protected ChangeFreq getChangeFrequency() {
<span class="fc" id="L1356">		return ChangeFreq.WEEKLY;</span>
	}
	
	protected boolean isSiteMap(File file, String path) {
<span class="fc" id="L1360">		return path.endsWith(&quot;.html&quot;);</span>
	}
	
	protected boolean isSearch(File file, String path) {
<span class="fc bfc" id="L1364" title="All 4 branches covered.">		return path.endsWith(&quot;.html&quot;) &amp;&amp; !&quot;search.html&quot;.equals(path);</span>
	}
	
	// --- Utility methods
	
	/**
	 * Wraps iterator
	 * @param &lt;T&gt;
	 * @param iterator
	 * @return
	 */
	public static &lt;T,U&gt; Iterator&lt;U&gt; wrap(Iterator&lt;T&gt; iterator, Function&lt;? super T,U&gt; mapper) {
<span class="fc" id="L1376">		return new Iterator&lt;U&gt;() {</span>

			@Override
			public boolean hasNext() {
<span class="fc" id="L1380">				return iterator.hasNext();</span>
			}

			@Override
			public U next() {
<span class="fc" id="L1385">				return mapper.apply(iterator.next());</span>
			}
			
			@Override
			public void remove() {
<span class="nc" id="L1390">				iterator.remove();</span>
<span class="nc" id="L1391">			}</span>
			
		};
	}

	public static &lt;T&gt; Iterable&lt;T&gt; asIterable(Resource resource, Function&lt;? super EObject, T&gt; mapper) {
<span class="nc" id="L1397">		return () -&gt; wrap(resource.getAllContents(), mapper);</span>
	}

	public static &lt;T&gt; Iterable&lt;T&gt; asIterable(ResourceSet resourceSet, Function&lt;? super Notifier, T&gt; mapper) {
<span class="fc" id="L1401">		return () -&gt; wrap(resourceSet.getAllContents(), mapper);</span>
	}
	
	/**
	 * @param object
	 * @return Semantic info or self info
	 */
	protected Map.Entry&lt;SemanticInfo, Label&gt; semanticInfo(Notifier object) {
<span class="fc bfc" id="L1409" title="All 2 branches covered.">		if (object instanceof Label) {</span>
<span class="fc" id="L1410">			Label label = (Label) object;</span>
<span class="fc" id="L1411">			SemanticInfo semanticInfo = SemanticInfo.getAnnotation(label);</span>
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">			if (semanticInfo == null) {</span>
<span class="fc" id="L1413">				semanticInfo = new SemanticInfo(label);</span>
			}
<span class="fc" id="L1415">			return Map.entry(semanticInfo, (Label) object);</span>
		}
<span class="fc" id="L1417">		return null;</span>
	}
	
	/**
	 * Override to return contributors.
	 * @return A collection of {@link SiteGeneratorContributor}s.
	 */
	protected Collection&lt;SiteGeneratorContributor&gt; getContributors() {
<span class="fc" id="L1425">		return Collections.emptyList();</span>
	}
	
	/**
	 * Override to load semantic info from external sources. This implementation iterates over the resource set and returns
	 * entries created by selfInfo 
	 * @param resourceSet
	 * @return
	 */
	protected Iterable&lt;Map.Entry&lt;SemanticInfo, ?&gt;&gt; semanticInfoSource(ResourceSet resourceSet) {
<span class="fc" id="L1435">		return composeWithSemanticInfo(asIterable(resourceSet, this::semanticInfo));</span>
	}
	
	/**
	 * Override to load semantic info from external sources. This implementation iterates over the resource set and returns
	 * entries created by selfInfo 
	 * @param resourceSet
	 * @return
	 */
	protected Iterable&lt;Map.Entry&lt;SemanticInfo, ?&gt;&gt; semanticInfoSource(Resource actionResource) {
<span class="nc" id="L1445">		return composeWithSemanticInfo(asIterable(actionResource, this::semanticInfo));</span>
	}
	
	/**
	 * @return External {@link SemanticInfo}'s for referencing. 
	 */
	protected Iterable&lt;SemanticInfo&gt; getSemanticInfos() {
<span class="fc" id="L1452">		return null;</span>
	}
	
	protected Iterable&lt;Entry&lt;SemanticInfo, ?&gt;&gt; composeWithSemanticInfo(Iterable&lt;Entry&lt;SemanticInfo, ?&gt;&gt; semanticInfoSource) {
<span class="fc" id="L1456">		Iterable&lt;SemanticInfo&gt; semanticInfos = getSemanticInfos();</span>
<span class="pc bpc" id="L1457" title="1 of 2 branches missed.">		if (semanticInfos == null) {</span>
<span class="fc" id="L1458">			return semanticInfoSource;</span>
		}
<span class="nc" id="L1460">		return new Iterable&lt;Entry&lt;SemanticInfo, ?&gt;&gt;() {</span>
			
			@Override
			public Iterator&lt;Entry&lt;SemanticInfo, ?&gt;&gt; iterator() {
<span class="nc" id="L1464">				return new Iterator&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt;() {</span>
					
<span class="nc" id="L1466">					private Iterator&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; firstIterator = semanticInfoSource.iterator();</span>
<span class="nc" id="L1467">					private Iterator&lt;Map.Entry&lt;SemanticInfo,?&gt;&gt; secondIterator = wrap(semanticInfos.iterator(), this::mapToLabel);</span>
					
					private Map.Entry&lt;SemanticInfo,Label&gt; mapToLabel(SemanticInfo semanticInfo) {
<span class="nc" id="L1470">						URI location = semanticInfo.getLocation();</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">						Label label = location == null ? AppFactory.eINSTANCE.createLabel() : AppFactory.eINSTANCE.createLink();</span>
<span class="nc" id="L1472">						label.setText(semanticInfo.getName());</span>
<span class="nc" id="L1473">						label.setTooltip(semanticInfo.getDescription());</span>
<span class="nc" id="L1474">						label.setIcon(semanticInfo.getIcon());</span>

<span class="nc bnc" id="L1476" title="All 2 branches missed.">						if (location != null) {</span>
<span class="nc" id="L1477">							((Link) label).setLocation(location.toString());</span>
						}
<span class="nc" id="L1479">						return Map.entry(semanticInfo, label); </span>
					}
					
					@Override
					public Entry&lt;SemanticInfo, ?&gt; next() {								
<span class="nc bnc" id="L1484" title="All 4 branches missed.">						if (firstIterator != null &amp;&amp; firstIterator.hasNext()) {</span>
							
						}
<span class="nc bnc" id="L1487" title="All 2 branches missed.">						return (firstIterator.hasNext() ? firstIterator : secondIterator).next();</span>
					}
					
					@Override
					public boolean hasNext() {
<span class="nc bnc" id="L1492" title="All 4 branches missed.">						return firstIterator.hasNext() || secondIterator.hasNext();</span>
					}
				};
			}
			
		};
	}
	
	/**
	 * Creates a resolution listener. Used by subclasses.
	 * @param errorConsumer location, error message
	 * @param context
	 * @param progressMonitor
	 * @return
	 */
	protected ResolutionListener createResolutionListener(BiConsumer&lt;String,String&gt; errorConsumer, Context context, ProgressMonitor progressMonitor) {
				
<span class="fc" id="L1509">		return new ResolutionListener() {</span>
			/**
			 * Called on resolution of &quot;target-uri&quot; property of a diagram element.
			 * If target is null then resolution was unsuccessful.
			 * @param element
			 * @param action
			 * @param targetUriPropertyValue
			 * @param target
			 */
			public void onTargetURIResolution(
					Action action, 
					org.nasdanika.drawio.ModelElement modelElement, 
					String targetURI, 
					EObject target) {
								
<span class="nc bnc" id="L1524" title="All 2 branches missed.">				if (target == null) {</span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">					String location = modelElement == null ? NcoreActionBuilder.actionMarker(action) : modelElement.toString() + &quot; &quot; + modelElement.getMarkers().toString();				</span>
<span class="nc" id="L1526">					errorConsumer.accept(location, &quot;Element with URI not found: &quot; + targetURI);</span>
				}
<span class="nc" id="L1528">			}</span>

			/**
			 * Called on resoulution of semantic-uuid property.
			 * @param element
			 * @param action
			 * @param semanticUUID
			 * @param semanticModelElement If null then there is no element with a given UUID.
			 * @param semanticModelElementAction If null and the previous argument is not null, then there is a semantic element, but there is not action for it.
			 */
			public void onTargetUUIDResolution(
					Action action, 
					org.nasdanika.drawio.ModelElement modelElement, 
					String semanticUUID, 
					ModelElement semanticModelElement,
					Action semanticModelElementAction) {
				
<span class="nc bnc" id="L1545" title="All 2 branches missed.">				if (semanticModelElementAction == null) {</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">					String location = modelElement == null ? NcoreActionBuilder.actionMarker(action) : modelElement.toString() + &quot; &quot; + modelElement.getMarkers().toString();				</span>
<span class="nc" id="L1547">					errorConsumer.accept(location, &quot;Action for semantic UUID not found: &quot; + semanticUUID);</span>
				}
<span class="nc" id="L1549">			}</span>

			/**
			 * Called on resolution of action URI
			 * @param action Source action
			 * @param modelElement Source model element if resolution is done for diagram element properties
			 * @param targetURIStr Target URI string resolved relative to action URI's.
			 * @param target Target, null if not found.
			 * @param targetURI Target URI relative to the source action. Null of target is not found or doesn't have a URI.
			 * @param backLinkURI Backlink from the target action to the source action.
			 */
			public void onActionURIResolution(
					Action action, 
					org.nasdanika.drawio.ModelElement modelElement, 
					String targetURIStr, 
					Label target, 
					URI targetURI, 
					URI backLinkURI) {
				
<span class="fc bfc" id="L1568" title="All 2 branches covered.">				if (target == null) {</span>
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">					String location = modelElement == null ? NcoreActionBuilder.actionMarker(action) : modelElement.toString() + &quot; &quot; + modelElement.getMarkers().toString();				</span>
<span class="fc" id="L1570">					errorConsumer.accept(location, &quot;Action with URI not found: &quot; + targetURIStr);</span>
				}
<span class="fc" id="L1572">			}</span>

			/**
			 * Called on resolution of action UUID
			 * @param action
			 * @param modelElement
			 * @param actionUUID
			 * @param target
			 * @param targetURI
			 * @param backLinkURI
			 */
			public void onActionUUIDResolution(
					Action action, 
					org.nasdanika.drawio.ModelElement modelElement, 
					String actionUUID,
					Label target,
					URI targetURI,
					URI backLinkURI) {
				
<span class="nc bnc" id="L1591" title="All 2 branches missed.">				if (target == null) {</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">					String location = modelElement == null ? NcoreActionBuilder.actionMarker(action) : modelElement.toString() + &quot; &quot; + modelElement.getMarkers().toString();				</span>
<span class="nc" id="L1593">					errorConsumer.accept(location, &quot;Action with UUID not found: &quot; + actionUUID);</span>
				}
<span class="nc" id="L1595">			}</span>

			/**
			 * Called on resolution of semantic reference or link
			 * @param action
			 * @param targetURIStr
			 * @param target
			 * @param targetURI
			 * @param backLinkURI
			 */
			public void onSemanticReferenceResolution(
					Action action, 
					String targetURIStr, 
					Label target, 
					URI targetURI, 
					URI backLinkURI) {
				
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">				if (target == null) {</span>
<span class="fc" id="L1613">					errorConsumer.accept(NcoreActionBuilder.actionMarker(action), &quot;Unresolved semantic reference: &quot; + targetURIStr);</span>
				}
<span class="fc" id="L1615">			}</span>
			
			@Override
			public void onComputingDrawioRepresentation(
					Action action, 
					String key,
					org.nasdanika.drawio.Document document) {
				
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">				if (document == null) {</span>
<span class="nc" id="L1624">					errorConsumer.accept(NcoreActionBuilder.actionMarker(action), &quot;Unresolved representation: &quot; + key);</span>
				}
<span class="fc" id="L1626">			}</span>
			
		};		
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>